<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<meta name="theme-color" content="#0a0a0f"/>
<meta name="apple-mobile-web-app-capable" content="yes"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<meta name="apple-mobile-web-app-title" content="Vault Dex"/>
<title>Vault Dex</title>
<link rel="manifest" href="./manifest.json"/>
<link rel="preconnect" href="https://fonts.googleapis.com"/>
<link href="https://fonts.googleapis.com/css2?family=Syne:wght@400;600;700;800&family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet"/>
<style>
  :root{
    --bg:#0a0a0f;--bg2:#111118;--bg3:#1a1a24;
    --accent:#00ff88;--warn:#ffaa00;--danger:#ff4466;
    --text:#e8e8f0;--muted:#555570;--border:#22223a;--radius:14px;
    --font-display:'Syne',sans-serif;--font-mono:'JetBrains Mono',monospace;
  }
  /* Light theme override */
  [data-theme="light"]{
    --bg:#f2f2f7;--bg2:#ffffff;--bg3:#e5e5ea;
    --accent:#00994d;--warn:#b87800;--danger:#cc2244;
    --text:#0a0a18;--muted:#8e8ea0;--border:#c8c8d8;
  }
  /* Auto: resolved by time-of-day via JS */
  *{box-sizing:border-box;margin:0;padding:0;-webkit-tap-highlight-color:transparent}
  html,body{height:100%;background:var(--bg);color:var(--text);font-family:var(--font-display);overflow-x:hidden;transition:background .3s,color .3s;overscroll-behavior-y:none}
  body::before{content:'';position:fixed;inset:0;z-index:0;pointer-events:none;
    background-image:url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.04'/%3E%3C/svg%3E");opacity:.4}
  #app{position:relative;z-index:1;max-width:480px;margin:0 auto;height:100dvh;display:flex;flex-direction:column;padding:env(safe-area-inset-top,0) 0 env(safe-area-inset-bottom,0)}

  header{padding:20px 20px 12px;display:flex;align-items:center;justify-content:space-between;border-bottom:1px solid var(--border);flex-shrink:0}
  .header-left{display:flex;flex-direction:column;gap:2px}
  .header-title{font-size:24px;font-weight:800;letter-spacing:-.5px}
  .header-date{font-size:12px;font-family:var(--font-mono);color:var(--muted);text-transform:uppercase;letter-spacing:1px}
  .header-actions{display:flex;gap:8px}
  .icon-btn{width:38px;height:38px;border-radius:10px;border:1px solid var(--border);background:var(--bg2);color:var(--text);font-size:18px;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all .15s}
  .icon-btn:active{transform:scale(.92);background:var(--bg3)}

  .reconnect-area-wrap{flex-shrink:0}

  .card{background:var(--bg2);border:1px solid var(--border);border-radius:var(--radius);overflow:hidden;animation:fadeUp .4s ease both;flex-shrink:0}
  .card-header{padding:12px 16px;display:flex;align-items:center;justify-content:space-between;border-bottom:1px solid var(--border)}
  .card-header.clickable{cursor:pointer;user-select:none;border-bottom:none}
  .card-header.clickable:active{background:var(--bg3)}
  .card-label{font-size:11px;font-family:var(--font-mono);text-transform:uppercase;letter-spacing:1.5px;color:var(--muted)}
  .card-body{padding:16px}
  .card-body.collapsed{display:none}
  .collapse-arrow{font-size:11px;color:var(--muted);transition:transform .25s;display:inline-block;font-family:var(--font-mono)}
  .collapse-arrow.open{transform:rotate(180deg)}

  /* countdown */
  .cw{display:flex;flex-direction:column;gap:10px}
  .ca{font-size:19px;font-weight:700;line-height:1.3}
  .cm{display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:8px}
  .cl{font-size:13px;font-family:var(--font-mono);color:var(--muted)}
  .ct{font-size:42px;font-weight:800;font-family:var(--font-mono);color:#4a9eff;letter-spacing:-1px;line-height:1;font-variant-numeric:tabular-nums}
  .ct.active{color:var(--accent)}
  .ct.urgent{color:var(--warn);animation:pulse 1s ease infinite}
  .pb-wrap{height:3px;background:var(--bg3);border-radius:2px;overflow:hidden}
  .pb-fill{height:100%;background:var(--accent);border-radius:2px;transition:width 1s linear}
  .snooze-row{display:flex;gap:8px;flex-wrap:wrap}
  .sn-btn{padding:6px 14px;background:var(--bg3);border:1px solid var(--border);border-radius:8px;color:var(--muted);font-size:12px;font-family:var(--font-mono);cursor:pointer;transition:all .15s}
  .sn-btn:active{background:var(--border);color:var(--text);transform:scale(.95)}
  .snoozed-badge{display:inline-flex;align-items:center;gap:6px;padding:4px 10px;background:rgba(255,170,0,.12);border:1px solid rgba(255,170,0,.3);border-radius:20px;font-size:11px;font-family:var(--font-mono);color:var(--warn)}

  /* habits */
  .habits-grid{display:flex;gap:8px;justify-content:center;flex-wrap:wrap;padding:4px 2px 8px}
  .habit-col{display:flex;flex-direction:column;align-items:center;gap:4px;cursor:pointer}
  .habit-bar-track{width:44px;height:5px;background:var(--bg3);border-radius:3px;position:relative;overflow:hidden;border:1px solid var(--border);flex-shrink:0}
  .habit-bar-fill{position:absolute;top:0;left:0;bottom:0;border-radius:3px;background:linear-gradient(to right,var(--accent),rgba(0,255,136,.6));transition:width .4s cubic-bezier(.34,1.56,.64,1)}
  .habit-bar-fill.complete{background:var(--accent)}
  .habit-icon{font-size:26px;cursor:pointer;transition:transform .2s cubic-bezier(.34,1.56,.64,1);user-select:none;line-height:1;width:48px;height:48px;display:flex;align-items:center;justify-content:center;border-radius:12px;border:1.5px solid var(--border);background:var(--bg2);position:relative;flex-shrink:0}
  .habit-icon.complete{border-color:rgba(0,255,136,.4);background:rgba(0,255,136,.06)}
  .habit-icon:active{transform:scale(1.25)}
  .habit-val{font-size:10px;font-family:var(--font-mono);color:var(--muted);background:var(--bg3);padding:1px 4px;border-radius:10px}
  .habit-val.complete{color:var(--accent)}
  /* habit edit mode */
  .habit-remove-btn{position:absolute;top:-6px;right:-6px;width:18px;height:18px;border-radius:50%;background:var(--danger);color:#fff;font-size:10px;font-weight:700;border:2px solid var(--bg2);cursor:pointer;display:flex;align-items:center;justify-content:center;z-index:2;padding:0;box-shadow:0 1px 4px rgba(0,0,0,.35)}
  .habit-remove-btn:active{transform:scale(.88)}
  .habit-add-col{display:flex;flex-direction:column;align-items:center;gap:6px;width:56px;cursor:pointer}
  .habit-add-btn{width:44px;height:44px;border-radius:12px;background:rgba(0,255,136,.08);border:1.5px dashed rgba(0,255,136,.35);color:var(--accent);font-size:22px;display:flex;align-items:center;justify-content:center;transition:all .15s}
  .habit-add-btn:active{background:rgba(0,255,136,.18);transform:scale(.92)}
  .habit-add-label{font-size:9px;font-family:var(--font-mono);color:var(--muted)}
  /* habit edit done pill â€” small, tucked into card header area */
  .habit-done-pill{display:none;align-items:center;gap:6px;padding:5px 12px;background:var(--accent);color:var(--bg);border:none;border-radius:20px;font-size:11px;font-family:var(--font-mono);font-weight:700;cursor:pointer;transition:all .15s;flex-shrink:0}
  .habit-done-pill:active{transform:scale(.93)}
  .habit-done-pill.visible{display:flex}

  /* pomodoro */
  .pomo-btn{width:22px;height:22px;border-radius:50%;border:2px solid var(--border);background:var(--bg3);cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all .2s;flex-shrink:0;padding:0}
  @keyframes pomoActivePulse{0%,100%{box-shadow:0 0 0 3px rgba(0,255,136,.12),0 0 0 0 rgba(0,255,136,.0)}50%{box-shadow:0 0 0 3px rgba(0,255,136,.25),0 0 8px 2px rgba(0,255,136,.18)}}
  .pomo-btn.active{border-color:var(--accent);background:rgba(0,255,136,.15);animation:pomoActivePulse 2.4s ease-in-out infinite}
  .pomo-btn .pomo-dot{width:8px;height:8px;border-radius:50%;background:var(--muted);transition:background .2s}
  .pomo-btn.active .pomo-dot{background:var(--accent)}
  .pomo-ring{position:relative;width:60px;height:60px;flex-shrink:0}
  .pomo-ring svg{position:absolute;inset:0;transform:rotate(-90deg)}
  .pomo-ring-label{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:11px;font-family:var(--font-mono);font-weight:700;color:var(--accent)}

  /* schedule */
  .sched-list{display:flex;flex-direction:column;gap:2px}
  .sched-item{display:flex;align-items:center;gap:12px;padding:10px 12px;border-radius:10px;position:relative}
  .sched-item.current{background:rgba(0,255,136,.07)}
  .sched-item.past{opacity:.4}
  .sched-item.current::before{content:'';position:absolute;left:0;top:50%;transform:translateY(-50%);width:3px;height:60%;background:var(--accent);border-radius:2px}
  .sched-time{font-size:11px;font-family:var(--font-mono);color:var(--text);min-width:52px}
  .sched-item.current .sched-time{color:var(--accent)}
  .sched-item.past .sched-time{color:var(--muted)}
  .sched-act{font-size:14px;flex:1;line-height:1.3}
  .sched-preview{padding:10px 16px 12px;font-size:13px;font-family:var(--font-mono);display:flex;align-items:center;gap:8px;border-top:1px solid var(--border)}

  /* modal */
  .modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.8);z-index:500;display:flex;align-items:flex-end;justify-content:center;backdrop-filter:blur(6px);animation:fadeIn .2s ease}
  .modal-overlay.center{align-items:center}
  .modal{background:var(--bg2);border:1px solid var(--border);border-radius:20px 20px 0 0;width:100%;max-width:480px;padding:20px 20px calc(20px + env(safe-area-inset-bottom,0px));animation:slideUp .3s cubic-bezier(.34,1.56,.64,1);max-height:92dvh;overflow-y:auto}
  .modal.cm-modal{border-radius:20px;animation:scaleIn .25s cubic-bezier(.34,1.56,.64,1);margin:16px}
  .modal-handle{width:40px;height:4px;background:var(--border);border-radius:2px;margin:0 auto 20px}
  .modal-title{font-size:20px;font-weight:800;margin-bottom:6px}
  .alarm-activity{font-size:18px;font-weight:700;padding:16px;background:var(--bg3);border-radius:12px;text-align:center;margin-bottom:8px;line-height:1.4}
  .alarm-time{font-size:13px;font-family:var(--font-mono);color:var(--accent);text-align:center;margin-bottom:20px}

  /* buttons */
  .btn{padding:12px 22px;border-radius:12px;border:none;cursor:pointer;font-family:var(--font-display);font-size:15px;font-weight:700;transition:all .15s;min-height:48px;display:flex;align-items:center;justify-content:center;gap:6px}
  .btn:active{transform:scale(.95)}
  .btn-green{background:var(--accent);color:var(--bg)}
  .btn-red{background:var(--danger);color:#fff}
  .btn-ghost{background:var(--bg3);color:var(--text);border:1px solid var(--border)}
  .btn-icon{width:52px;height:52px;padding:0;font-size:22px;border-radius:14px;flex-shrink:0}
  .btn-row{display:flex;gap:10px;flex-wrap:wrap;justify-content:center}

  /* reconnect banner */
  .reconnect-banner{margin:12px 20px 0;background:rgba(255,170,0,.07);border:1px solid rgba(255,170,0,.2);border-radius:12px;padding:12px 16px;display:flex;align-items:center;gap:12px;animation:fadeUp .3s ease}
  .rb-text{flex:1;font-size:12px;color:var(--warn);font-family:var(--font-mono);line-height:1.5}
  .rb-sub{font-size:11px;color:var(--muted);margin-top:2px}
  .reconnect-btn{padding:8px 16px;background:var(--warn);color:#000;border:none;border-radius:8px;font-size:13px;font-weight:700;cursor:pointer;white-space:nowrap;font-family:var(--font-display);flex-shrink:0}
  .reconnect-btn:active{transform:scale(.95)}

  /* alarm status banner */
  /* first-run setup */
  .setup-screen{position:fixed;inset:0;background:var(--bg);z-index:300;overflow-y:auto;padding:48px 24px calc(48px + env(safe-area-inset-bottom,0px));display:flex;flex-direction:column;align-items:center;justify-content:center}
  .setup-inner{width:100%;max-width:360px;display:flex;flex-direction:column;gap:20px;align-items:center}
  .setup-icon{font-size:72px;line-height:1}
  .setup-title{font-size:28px;font-weight:800;letter-spacing:-.5px;text-align:center}
  .setup-desc{font-size:13px;color:var(--muted);line-height:1.7;text-align:center;font-family:var(--font-mono)}
  .setup-note{font-size:11px;color:var(--muted);font-family:var(--font-mono);line-height:1.7;padding:14px;background:var(--bg2);border:1px solid var(--border);border-radius:10px;width:100%}
  .setup-note b{color:var(--warn)}

  /* install guide */
  .install-guide{position:fixed;inset:0;background:rgba(0,0,0,.85);z-index:400;display:flex;align-items:flex-end;justify-content:center;backdrop-filter:blur(8px);animation:fadeIn .2s ease}
  .install-modal{background:var(--bg2);border:1px solid var(--border);border-radius:20px 20px 0 0;width:100%;max-width:480px;padding:24px 24px calc(24px + env(safe-area-inset-bottom,0px));max-height:90dvh;overflow-y:auto;animation:slideUp .3s cubic-bezier(.34,1.56,.64,1)}
  .install-step{display:flex;gap:14px;padding:14px 0;border-bottom:1px solid var(--border)}
  .install-step:last-child{border-bottom:none}
  .install-num{width:28px;height:28px;border-radius:8px;background:rgba(0,255,136,.12);border:1px solid rgba(0,255,136,.25);display:flex;align-items:center;justify-content:center;font-size:11px;font-family:var(--font-mono);color:var(--accent);flex-shrink:0;margin-top:2px}
  .install-text{font-size:13px;line-height:1.6;color:var(--text)}
  .install-text b{color:var(--accent)}
  .install-text small{display:block;margin-top:4px;font-size:11px;font-family:var(--font-mono);color:var(--muted)}
  .platform-tabs{display:flex;gap:8px;margin-bottom:20px;flex-wrap:wrap}
  .ptab{padding:7px 14px;border-radius:8px;border:1px solid var(--border);background:var(--bg3);color:var(--muted);font-size:12px;font-family:var(--font-mono);cursor:pointer;transition:all .15s}
  .ptab.active{background:rgba(0,255,136,.12);border-color:rgba(0,255,136,.3);color:var(--accent)}
  .ptab:active{transform:scale(.95)}
  .platform-steps{display:none}
  .platform-steps.active{display:block}
  .notif-fix{background:rgba(255,170,0,.07);border:1px solid rgba(255,170,0,.2);border-radius:10px;padding:12px 14px;font-size:12px;font-family:var(--font-mono);color:var(--warn);line-height:1.6;margin-top:8px}
  .notif-fix b{color:var(--text)}

  /* settings */
  .s-section{margin-bottom:24px}
  .s-section-title{font-size:10px;font-family:var(--font-mono);color:var(--muted);text-transform:uppercase;letter-spacing:1.5px;margin-bottom:10px}
  .s-row{display:flex;align-items:center;justify-content:space-between;padding:14px 0;border-bottom:1px solid var(--border);gap:12px}
  .s-row:last-child{border-bottom:none}
  .s-label{font-size:15px;font-weight:600}
  .s-sub{font-size:12px;color:var(--muted);margin-top:2px;font-family:var(--font-mono);word-break:break-all}
  .pill{display:inline-flex;align-items:center;padding:4px 10px;border-radius:20px;font-size:11px;font-family:var(--font-mono);font-weight:600;white-space:nowrap}
  .pill-green{background:rgba(0,255,136,.12);color:var(--accent);border:1px solid rgba(0,255,136,.25)}
  .pill-red{background:rgba(255,68,102,.12);color:var(--danger);border:1px solid rgba(255,68,102,.25)}
  .pill-amber{background:rgba(255,170,0,.12);color:var(--warn);border:1px solid rgba(255,170,0,.25)}
  /* theme segment control */
  .theme-seg{display:flex;background:var(--bg3);border-radius:10px;padding:3px;gap:2px}
  .theme-seg-btn{flex:1;padding:7px 10px;border-radius:7px;border:none;background:transparent;color:var(--muted);font-size:11px;font-family:var(--font-mono);font-weight:600;cursor:pointer;transition:all .15s;text-align:center}
  .theme-seg-btn.active{background:var(--bg2);color:var(--text);box-shadow:0 1px 4px rgba(0,0,0,.18)}
  .empty-state{text-align:center;padding:40px 20px;color:var(--muted);font-size:14px;line-height:1.6}
  .toast{position:fixed;top:calc(16px + env(safe-area-inset-top,0px));left:50%;transform:translateX(-50%);background:var(--bg2);border:1px solid var(--border);border-radius:12px;padding:10px 18px;font-size:13px;font-family:var(--font-mono);color:var(--text);z-index:1000;white-space:normal;max-width:calc(100vw - 40px);text-align:center;box-shadow:0 4px 24px rgba(0,0,0,.5);animation:toastIn .3s ease;pointer-events:none}

  /* â”€â”€ OFFLINE BANNER â”€â”€ */
  #offline-banner{position:fixed;bottom:calc(16px + env(safe-area-inset-bottom,0px));left:50%;transform:translateX(-50%);background:#1a1006;border:1.5px solid rgba(255,170,0,.5);border-radius:14px;padding:10px 18px 10px 14px;font-size:13px;font-family:var(--font-mono);color:var(--warn);z-index:2000;white-space:nowrap;max-width:calc(100vw - 32px);box-shadow:0 4px 28px rgba(0,0,0,.6);animation:slideUpBanner .35s cubic-bezier(.34,1.4,.64,1);display:flex;align-items:center;gap:10px;pointer-events:auto}
  #offline-banner.dismissing{animation:slideDownBanner .28s ease forwards}
  #offline-banner .ob-icon{font-size:17px;flex-shrink:0}
  #offline-banner .ob-text{flex:1;line-height:1.3}
  #offline-banner .ob-text b{color:var(--text);display:block;font-size:13px;margin-bottom:1px}
  #offline-banner .ob-text span{font-size:11px;color:var(--muted)}
  #offline-banner .ob-close{width:24px;height:24px;border-radius:7px;border:1px solid rgba(255,170,0,.3);background:rgba(255,170,0,.08);color:var(--warn);font-size:12px;cursor:pointer;display:flex;align-items:center;justify-content:center;flex-shrink:0;transition:background .12s}
  #offline-banner .ob-close:active{background:rgba(255,170,0,.2)}
  @keyframes slideUpBanner{from{opacity:0;transform:translateX(-50%) translateY(24px)}to{opacity:1;transform:translateX(-50%) translateY(0)}}
  @keyframes slideDownBanner{from{opacity:1;transform:translateX(-50%) translateY(0)}to{opacity:0;transform:translateX(-50%) translateY(24px)}}

  @keyframes fadeUp{from{opacity:0;transform:translateY(16px)}to{opacity:1;transform:translateY(0)}}
  @keyframes fadeIn{from{opacity:0}to{opacity:1}}
  @keyframes slideUp{from{transform:translateY(100%)}to{transform:translateY(0)}}
  @keyframes scaleIn{from{opacity:0;transform:scale(.88)}to{opacity:1;transform:scale(1)}}
  @keyframes toastIn{from{opacity:0;transform:translateX(-50%) translateY(-10px)}to{opacity:1;transform:translateX(-50%) translateY(0)}}
  @keyframes pulse{0%,100%{opacity:1}50%{opacity:.5}}
  @keyframes emojiPop{0%{opacity:1;transform:translate(-50%,0) scale(1)}60%{opacity:1;transform:translate(-50%,-52px) scale(1.5)}100%{opacity:0;transform:translate(-50%,-80px) scale(.9)}}
  ::-webkit-scrollbar{width:4px}::-webkit-scrollbar-track{background:transparent}::-webkit-scrollbar-thumb{background:var(--border);border-radius:2px}

  /* â”€â”€ TABS â”€â”€ */
  .tab-bar{display:flex;border-bottom:1px solid var(--border);background:var(--bg);flex-shrink:0;z-index:10}
  .tab-btn{flex:1;padding:12px 8px;font-size:12px;font-family:var(--font-mono);font-weight:600;letter-spacing:.5px;color:var(--muted);background:none;border:none;cursor:pointer;border-bottom:2px solid transparent;transition:all .2s;text-transform:uppercase}
  .tab-btn.active{color:var(--accent);border-bottom-color:var(--accent)}
  .tab-btn:active{background:var(--bg3)}
  .tabs-container{flex:1;overflow:hidden;display:flex;flex-direction:column;min-height:0}
  .tab-panels{position:relative;flex:1;min-height:0;overflow:hidden}
  .tab-panel{position:absolute;top:0;left:0;width:100%;height:100%;overflow-y:auto;overflow-x:hidden;padding:16px 20px 120px;display:flex;flex-direction:column;gap:16px;-webkit-overflow-scrolling:touch;transform:translateX(100%);transition:transform .28s cubic-bezier(.4,0,.2,1);will-change:transform}
  .tab-panel.active{transform:translateX(0%)}
  .tab-panel.left{transform:translateX(-100%)}
  .tab-panel.dragging{transition:none!important}

  /* â”€â”€ SCHEDULE TAB â”€â”€ */
  .sched-tab-list{display:flex;flex-direction:column;gap:6px}
  /* View mode items â€” card-like, bigger */
  .sched-tab-item{display:flex;align-items:center;gap:14px;padding:14px 16px;border-radius:14px;background:var(--bg2);border:1px solid var(--border);position:relative;transition:background .15s,border-color .15s}
  .sched-tab-item.current{background:rgba(0,255,136,.07);border-color:rgba(0,255,136,.25)}
  .sched-tab-item.past{opacity:.38}
  .sched-tab-item.current::before{content:'';position:absolute;left:0;top:50%;transform:translateY(-50%);width:3px;height:50%;background:var(--accent);border-radius:0 2px 2px 0}
  .sched-tab-time-block{display:flex;flex-direction:column;align-items:flex-start;gap:2px;min-width:64px;flex-shrink:0}
  .sched-tab-time{font-size:13px;font-family:var(--font-mono);font-weight:700;color:var(--text)}
  .sched-tab-item.current .sched-tab-time{color:var(--accent)}
  .sched-tab-item.past .sched-tab-time{color:var(--muted)}
  .sched-tab-divider{width:1px;height:32px;background:var(--border);flex-shrink:0}
  .sched-tab-act{font-size:15px;font-weight:600;flex:1;line-height:1.35;color:var(--text)}
  .sched-current-label{font-size:9px;font-family:var(--font-mono);text-transform:uppercase;letter-spacing:1px;color:var(--accent);font-weight:700}
  /* Delete button â€” only in edit mode */
  .sched-tab-del{width:34px;height:34px;border-radius:9px;border:1px solid rgba(255,68,102,.3);background:rgba(255,68,102,.08);color:var(--danger);font-size:15px;cursor:pointer;display:flex;align-items:center;justify-content:center;flex-shrink:0;transition:all .15s}
  .sched-tab-del:active{background:rgba(255,68,102,.2);transform:scale(.9)}
  /* FABs */
  .edit-fab{position:fixed;bottom:calc(24px + env(safe-area-inset-bottom,0px));right:20px;height:50px;min-width:50px;border-radius:16px;background:var(--accent);color:var(--bg);font-size:20px;font-weight:800;border:none;cursor:pointer;display:flex;align-items:center;justify-content:center;padding:0 18px;box-shadow:0 4px 20px rgba(0,255,136,.4);transition:all .22s;z-index:50;white-space:nowrap;gap:6px}
  .edit-fab:active{transform:scale(.92)}
  .edit-fab.editing{background:var(--warn);box-shadow:0 4px 20px rgba(255,170,0,.4);font-size:14px;font-weight:700}
  .add-fab{position:fixed;bottom:calc(24px + env(safe-area-inset-bottom,0px));right:20px;height:50px;min-width:50px;border-radius:16px;background:var(--accent);color:var(--bg);font-size:26px;font-weight:800;border:none;cursor:pointer;display:none;align-items:center;justify-content:center;padding:0 18px;box-shadow:0 4px 20px rgba(0,255,136,.4);transition:all .22s;z-index:50}
  .add-fab:active{transform:scale(.92)}
  .add-fab.visible{display:flex}
  .schedule-empty{text-align:center;padding:60px 20px;color:var(--muted);font-size:14px;line-height:1.8}
  /* Inline edit row */
  .sched-edit-row{background:var(--bg3);border:1px solid var(--border);border-radius:14px;padding:12px 14px;display:flex;align-items:center;gap:10px}
  .sched-edit-fields{display:flex;gap:8px;align-items:center;flex:1;min-width:0}
  .sched-edit-time{width:96px;flex-shrink:0;background:var(--bg2);border:1px solid var(--border);border-radius:8px;padding:8px 10px;color:var(--text);font-family:var(--font-mono);font-size:12px;outline:none;transition:border-color .15s}
  .sched-edit-time:focus{border-color:var(--accent)}
  .sched-edit-act{flex:1;min-width:0;background:var(--bg2);border:1px solid var(--border);border-radius:8px;padding:8px 10px;color:var(--text);font-family:var(--font-display);font-size:14px;outline:none;transition:border-color .15s}
  .sched-edit-act:focus{border-color:var(--accent)}
  /* Add modal */
  .add-sched-modal{position:fixed;inset:0;background:rgba(0,0,0,.7);z-index:200;display:flex;align-items:flex-end;justify-content:center;backdrop-filter:blur(6px);animation:fadeIn .2s ease}
  .add-sched-sheet{background:var(--bg2);border:1px solid var(--border);border-radius:20px 20px 0 0;width:100%;max-width:480px;padding:20px 20px calc(20px + env(safe-area-inset-bottom,0px));animation:slideUp .3s cubic-bezier(.34,1.56,.64,1)}
  .add-sched-sheet input,.sched-edit-sheet input{width:100%;background:var(--bg3);border:1px solid var(--border);border-radius:10px;padding:13px 14px;color:var(--text);font-family:var(--font-mono);font-size:14px;outline:none;margin-bottom:10px;transition:border-color .15s}
  .add-sched-sheet input:focus{border-color:var(--accent)}
  .add-sched-sheet input::placeholder{color:var(--muted)}

  /* â”€â”€ LOGS TAB â”€â”€ */
  .logs-toolbar{display:flex;gap:8px;align-items:center;margin-bottom:12px;flex-shrink:0}
  .logs-search{flex:1;background:var(--bg2);border:1px solid var(--border);border-radius:10px;padding:9px 13px;color:var(--text);font-family:var(--font-mono);font-size:13px;outline:none;transition:border-color .15s}
  .logs-search:focus{border-color:var(--accent)}
  .logs-search::placeholder{color:var(--muted)}
  .logs-container{flex:1;overflow:hidden;position:relative;border:1px solid var(--border);border-radius:12px;background:var(--bg2)}
  .logs-viewport{height:100%;overflow-y:auto;overflow-x:hidden;-webkit-overflow-scrolling:touch}
  .logs-spacer{position:relative}
  .log-item{position:absolute;left:0;right:0;padding:10px 14px;border-bottom:1px solid var(--border);cursor:pointer;transition:background .12s;display:flex;flex-direction:column;gap:3px}
  .log-item:last-child{border-bottom:none}
  .log-item:active,.log-item.hovered{background:var(--bg3)}
  .log-item-header{display:flex;align-items:center;justify-content:space-between;gap:8px}
  .log-item-time{font-size:11px;font-family:var(--font-mono);color:var(--accent);flex-shrink:0}
  .log-item-filename{font-size:10px;font-family:var(--font-mono);color:var(--muted);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:140px}
  .log-item-preview{font-size:12px;color:var(--text);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;opacity:.8}
  .log-item-tags{display:flex;gap:4px;flex-wrap:wrap;margin-top:2px}
  .log-item-tag{font-size:10px;font-family:var(--font-mono);color:var(--accent);background:rgba(0,255,136,.08);border:1px solid rgba(0,255,136,.2);border-radius:10px;padding:1px 7px}
  .logs-empty{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;color:var(--muted);font-size:13px;line-height:1.8;text-align:center;padding:20px}
  .logs-status{font-size:11px;font-family:var(--font-mono);color:var(--muted);text-align:right;margin-top:6px;flex-shrink:0}
  /* log detail modal */
  .log-detail-body{font-size:13px;font-family:var(--font-mono);line-height:1.7;color:var(--text);white-space:pre-wrap;word-break:break-word;max-height:55dvh;overflow-y:auto;background:var(--bg3);border:1px solid var(--border);border-radius:10px;padding:12px 14px;margin-bottom:14px}
  /* output format input */
  .fmt-input{width:100%;background:var(--bg3);border:1px solid var(--border);border-radius:10px;padding:10px 13px;color:var(--text);font-family:var(--font-mono);font-size:12px;outline:none;transition:border-color .15s;margin-top:6px}
  .fmt-input:focus{border-color:var(--accent)}
  .fmt-hint{font-size:10px;font-family:var(--font-mono);color:var(--muted);line-height:1.7;margin-top:5px}

  .sched-edit-popup{position:fixed;inset:0;background:rgba(0,0,0,.6);z-index:1000;display:flex;align-items:flex-end;justify-content:center}
  .sched-edit-sheet{background:var(--bg2);border-radius:20px 20px 0 0;padding:20px 20px 32px;width:100%;max-width:480px;max-height:90dvh;overflow-y:auto}
  .time-picker-wrap{display:flex;gap:6px;align-items:center;justify-content:center;padding:8px 0 16px}
  .time-drum-col{display:flex;flex-direction:column;align-items:center;gap:4px}
  .time-drum-label{font-size:9px;font-family:var(--font-mono);color:var(--muted);text-transform:uppercase;letter-spacing:1px}
  .time-drum{height:140px;width:64px;overflow:hidden;position:relative;border-radius:10px;background:var(--bg3);border:1px solid var(--border);cursor:pointer;user-select:none;touch-action:none}
  .time-drum-inner{position:absolute;left:0;right:0;top:0;display:flex;flex-direction:column;align-items:center}
  .time-drum-item{height:44px;display:flex;align-items:center;justify-content:center;font-size:22px;font-weight:700;font-family:var(--font-mono);color:var(--muted);transition:color .15s;flex-shrink:0;width:100%}
  .time-drum-item.selected{color:var(--text)}
  .time-drum::before,.time-drum::after{content:'';position:absolute;left:0;right:0;height:44px;z-index:2;pointer-events:none}
  .time-drum::before{top:0;background:linear-gradient(to bottom,var(--bg3),transparent)}
  .time-drum::after{bottom:0;background:linear-gradient(to top,var(--bg3),transparent)}
  .time-drum-highlight{position:absolute;top:44px;left:0;right:0;height:44px;border-top:1px solid var(--accent);border-bottom:1px solid var(--accent);pointer-events:none;opacity:.5;z-index:1}
  .time-colon{font-size:28px;font-weight:800;font-family:var(--font-mono);color:var(--text);padding-bottom:4px}
  .ampm-drum{width:56px}
  .ampm-drum .time-drum-item{font-size:15px}
  /* Clickable schedule items */
  .sched-tab-item{cursor:pointer;transition:background .15s}
  .sched-tab-item:active{background:var(--bg3)}
  .sched-edit-row{display:flex;align-items:center;gap:10px;padding:10px 12px;border-bottom:1px solid var(--border)}
  .sched-edit-row .sched-item-text{flex:1;display:flex;flex-direction:column;gap:2px;cursor:pointer}
  .sched-edit-row .sched-item-time{font-size:13px;font-family:var(--font-mono);color:var(--accent);font-weight:700}
  .sched-edit-row .sched-item-act{font-size:14px;color:var(--text)}
  .sched-edit-row .sched-item-edit-hint{font-size:10px;color:var(--muted);font-family:var(--font-mono)}

  /* â”€â”€ SCHEDULE VIEW TOGGLE â”€â”€ */
  .sched-view-toggle{display:flex;background:var(--bg3);border-radius:10px;padding:3px;gap:2px;margin-bottom:12px;flex-shrink:0}
  .sched-view-btn{flex:1;padding:7px 12px;border-radius:7px;border:none;background:transparent;color:var(--muted);font-size:11px;font-family:var(--font-mono);font-weight:700;cursor:pointer;transition:all .18s;letter-spacing:.3px}
  .sched-view-btn.active{background:var(--bg2);color:var(--text);box-shadow:0 1px 4px rgba(0,0,0,.22)}

  /* â”€â”€ CALENDAR VIEW â”€â”€ */
  .cal-view-wrap{display:flex;flex-direction:column;gap:0;flex:1;min-height:0}
  .cal-grid-wrap{flex-shrink:0;background:var(--bg2);border:1px solid var(--border);border-radius:14px;padding:14px 12px 10px;margin-bottom:10px}
  .cal-grid-nav{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px}
  .cal-nav-btn{width:32px;height:32px;border-radius:8px;border:1px solid var(--border);background:var(--bg3);color:var(--text);font-size:17px;cursor:pointer;display:flex;align-items:center;justify-content:center;padding:0;transition:all .12s;flex-shrink:0}
  .cal-nav-btn:active{background:var(--border)}
  .cal-month-label{font-size:15px;font-weight:800;font-family:var(--font-mono);letter-spacing:-.3px}
  .cal-day-headers{display:grid;grid-template-columns:repeat(7,1fr);gap:2px;margin-bottom:4px}
  .cal-day-hdr{text-align:center;font-size:9px;font-family:var(--font-mono);color:var(--muted);padding:2px 0;font-weight:700;letter-spacing:.5px}
  .cal-days{display:grid;grid-template-columns:repeat(7,1fr);gap:3px}
  .cal-day{aspect-ratio:1;border-radius:8px;display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:pointer;transition:all .15s;position:relative;min-height:34px;max-height:44px}
  .cal-day:active{transform:scale(.88)}
  .cal-day.empty{cursor:default;pointer-events:none;background:transparent!important}
  .cal-day-num{font-size:12px;font-weight:700;font-family:var(--font-mono);line-height:1;z-index:1;position:relative}
  .cal-day-dot{width:3px;height:3px;border-radius:50%;background:rgba(255,255,255,.7);margin-top:2px;z-index:1;position:relative;flex-shrink:0}
  .cal-day.today-ring{box-shadow:inset 0 0 0 2px var(--accent)}
  .cal-day.selected-day{background:var(--accent)!important;color:var(--bg)!important;box-shadow:0 2px 8px rgba(0,255,136,.4)}
  .cal-day.selected-day .cal-day-num{color:var(--bg)!important}
  .cal-day.selected-day .cal-day-dot{background:var(--bg)!important}
  /* Heat gradient: 0=free(transparent)â†’6=packed â€” theme-aware */
  .cal-heat-0{background:transparent;color:var(--muted)}
  .cal-heat-1{background:rgba(0,200,120,.10);color:var(--text)}
  .cal-heat-2{background:rgba(0,180,100,.22);color:var(--text)}
  .cal-heat-3{background:rgba(0,160,80,.38);color:var(--text)}
  .cal-heat-4{background:rgba(255,160,0,.45);color:var(--text)}
  .cal-heat-5{background:rgba(255,100,0,.60);color:#fff}
  .cal-heat-6{background:rgba(220,40,40,.80);color:#fff}
  [data-theme="light"] .cal-heat-1{background:rgba(0,140,80,.12)}
  [data-theme="light"] .cal-heat-2{background:rgba(0,140,80,.26)}
  [data-theme="light"] .cal-heat-3{background:rgba(0,130,70,.42)}
  [data-theme="light"] .cal-heat-4{background:rgba(200,120,0,.40)}
  [data-theme="light"] .cal-heat-5{background:rgba(200,70,0,.55)}
  [data-theme="light"] .cal-heat-6{background:rgba(180,20,20,.75)}
  /* Bottom half sub-tabs */
  .cal-bottom{display:flex;flex-direction:column;flex:1;min-height:180px;background:var(--bg2);border:1px solid var(--border);border-radius:14px;overflow:hidden}
  .cal-sub-tabs{display:flex;border-bottom:1px solid var(--border);flex-shrink:0;background:var(--bg)}
  .cal-sub-tab{flex:1;padding:9px 4px;font-size:11px;font-family:var(--font-mono);font-weight:700;letter-spacing:.4px;text-transform:uppercase;color:var(--muted);background:none;border:none;cursor:pointer;border-bottom:2px solid transparent;transition:all .18s}
  .cal-sub-tab.active{color:var(--accent);border-bottom-color:var(--accent)}
  .cal-sub-tab:active{background:var(--bg3)}
  /* â”€â”€ Time Blocks top-level tab bar â”€â”€ */
  .tb-tabs{display:flex;background:var(--bg3);border-radius:12px;padding:3px;gap:2px;margin-bottom:14px;flex-shrink:0}
  .tb-tab{flex:1;padding:9px 4px;font-size:11px;font-family:var(--font-mono);font-weight:700;color:var(--muted);background:none;border:none;border-radius:9px;cursor:pointer;transition:all .18s;text-align:center;letter-spacing:.3px}
  .tb-tab.active{background:var(--bg2);color:var(--accent);box-shadow:0 1px 6px rgba(0,0,0,.25)}
  .tb-tab:active{opacity:.7}
  /* â”€â”€ Scheduled tab: calendar stacked above list â”€â”€ */
  .sched-cal-wrap{display:flex;flex-direction:column;gap:0;flex:1;min-height:0;overflow-y:auto;-webkit-overflow-scrolling:touch}
  .sched-cal-grid{flex-shrink:0;background:var(--bg2);border:1px solid var(--border);border-radius:14px;padding:16px 14px 12px;margin-bottom:10px}
  .sched-event-list{flex-shrink:0;background:var(--bg2);border:1px solid var(--border);border-radius:14px;overflow:hidden;display:flex;flex-direction:column;margin-bottom:8px}
  .sched-event-list-header{display:flex;align-items:center;justify-content:space-between;padding:9px 13px;border-bottom:1px solid var(--border);flex-shrink:0;background:rgba(0,255,136,.03)}
  .sched-event-items{padding:8px 12px 12px}
  /* â”€â”€ Today Schedule popup â”€â”€ */
  .today-sched-ov{position:fixed;inset:0;background:rgba(0,0,0,.72);z-index:900;display:flex;align-items:flex-end;justify-content:center;backdrop-filter:blur(6px);animation:fadeIn .2s ease}
  .today-sched-sheet{background:var(--bg2);border-radius:20px 20px 0 0;width:100%;max-width:480px;max-height:88dvh;display:flex;flex-direction:column;animation:slideUp .28s cubic-bezier(.34,1.2,.64,1)}
  .today-sched-hdr{display:flex;align-items:center;justify-content:space-between;padding:16px 18px 10px;flex-shrink:0;border-bottom:1px solid var(--border)}
  .today-sched-title{font-size:18px;font-weight:800;letter-spacing:-.3px}
  .today-sched-close{width:32px;height:32px;border-radius:10px;border:1px solid var(--border);background:var(--bg3);color:var(--muted);font-size:17px;cursor:pointer;display:flex;align-items:center;justify-content:center;flex-shrink:0}
  .today-sched-body{flex:1;overflow-y:auto;padding:10px 16px calc(20px + env(safe-area-inset-bottom,0px));-webkit-overflow-scrolling:touch}
  .tsched-section-label{font-size:10px;font-family:var(--font-mono);font-weight:700;letter-spacing:1.5px;text-transform:uppercase;color:var(--muted);margin:12px 0 6px 2px}
  .tsched-item{display:flex;align-items:center;gap:10px;padding:11px 12px;border-radius:11px;border:1px solid var(--border);background:var(--bg3);margin-bottom:5px;cursor:pointer;transition:background .12s}
  .tsched-item.now{border-color:rgba(0,255,136,.4);background:rgba(0,255,136,.08)}
  .tsched-item.past{opacity:.38}
  .tsched-item:active{background:var(--border)}
  .tsched-time{font-size:13px;font-family:var(--font-mono);font-weight:700;color:var(--text);min-width:58px;flex-shrink:0}
  .tsched-item.now .tsched-time{color:var(--accent)}
  .tsched-act{font-size:15px;font-weight:600;flex:1;color:var(--text);line-height:1.3}
  .tsched-badge{font-size:10px;font-family:var(--font-mono);color:var(--muted);background:var(--bg2);border:1px solid var(--border);border-radius:5px;padding:2px 6px;flex-shrink:0}
  .tsched-now-pill{display:inline-flex;align-items:center;background:rgba(0,255,136,.18);border:1px solid rgba(0,255,136,.35);border-radius:6px;padding:2px 8px;font-size:10px;font-family:var(--font-mono);font-weight:800;color:var(--accent);letter-spacing:.5px;flex-shrink:0}
  /* â”€â”€ Routine / Focused list â”€â”€ */
  .tb-list{display:flex;flex-direction:column;gap:6px}
  .tb-list-item{display:flex;align-items:center;gap:10px;padding:11px 12px;border-radius:12px;border:1px solid var(--border);background:var(--bg2);transition:background .12s;cursor:default}
  .tb-list-item.now-item{border-color:rgba(0,255,136,.35);background:rgba(0,255,136,.07)}
  .tb-list-item.past-item{opacity:.38}
  .tb-list-item:active{background:var(--bg3)}
  .tb-item-time{font-size:13px;font-family:var(--font-mono);font-weight:700;color:var(--text);min-width:60px;flex-shrink:0}
  .tb-list-item.now-item .tb-item-time{color:var(--accent)}
  .tb-list-item.past-item .tb-item-time{color:var(--muted)}
  .tb-item-act{font-size:15px;flex:1;font-weight:600;color:var(--text);line-height:1.3}
  .tb-item-badge{font-size:10px;font-family:var(--font-mono);color:var(--muted);flex-shrink:0;background:var(--bg3);border:1px solid var(--border);border-radius:5px;padding:2px 6px;white-space:nowrap}
  .tb-action-btn{width:28px;height:28px;border-radius:7px;cursor:pointer;display:flex;align-items:center;justify-content:center;flex-shrink:0;padding:0;font-size:13px;transition:all .12s;border:1px solid var(--border);background:var(--bg3);color:var(--muted)}
  .tb-action-btn.del{border-color:rgba(255,68,102,.3);background:rgba(255,68,102,.08);color:var(--danger)}
  .cal-sub-content{flex:1;overflow-y:auto;overflow-x:hidden;padding:10px 12px 16px;-webkit-overflow-scrolling:touch}
  .cal-sub-item{display:flex;align-items:center;gap:10px;padding:9px 10px;border-radius:10px;border:1px solid var(--border);background:var(--bg3);margin-bottom:5px;transition:background .12s;cursor:pointer}
  .cal-sub-item.now-item{border-color:rgba(0,255,136,.35);background:rgba(0,255,136,.07)}
  .cal-sub-item.past-item{opacity:.38}
  .cal-sub-item:active{background:var(--border)}
  .cal-sub-time{font-size:13px;font-family:var(--font-mono);font-weight:700;color:var(--accent);min-width:60px;flex-shrink:0}
  .cal-sub-act{font-size:15px;flex:1;font-weight:600;color:var(--text);line-height:1.3}
  .cal-sub-repeat{font-size:10px;font-family:var(--font-mono);color:var(--muted);flex-shrink:0;background:var(--bg2);border:1px solid var(--border);border-radius:5px;padding:2px 6px;white-space:nowrap}
  .cal-sub-empty{text-align:center;padding:28px 16px;color:var(--muted);font-size:13px;font-family:var(--font-mono);line-height:1.7}
  .cal-selected-bar{padding:7px 12px 5px;border-bottom:1px solid var(--border);font-size:11px;font-family:var(--font-mono);color:var(--accent);display:flex;align-items:center;gap:6px;flex-shrink:0;background:rgba(0,255,136,.04)}
  .cal-heat-legend{display:flex;gap:4px;align-items:center;font-size:9px;font-family:var(--font-mono);color:var(--muted);margin-top:8px;flex-wrap:wrap}
  .cal-heat-swatch{width:14px;height:14px;border-radius:4px;flex-shrink:0}
</style>
</head>
<body>
<div id="app">
  <header>
    <div class="header-left">
      <div class="header-title">Vault Dex</div>
      <div class="header-date" id="header-date"></div>
    </div>
    <div class="header-actions">
      <button class="icon-btn" id="btn-reload" title="Reload">â†º</button>
      <button class="icon-btn" id="btn-settings" title="Settings">âš™</button>
    </div>
  </header>
  <div id="reconnect-area"></div>
  <div class="tabs-container">
    <div class="tab-panels" id="tab-panels">
      <div class="tab-panel active" id="main-content"></div>
    </div>
  </div>
</div>

<script>
'use strict';

// â”€â”€ STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const S = {
  config: null,
  habitData: {},
  snooze: {},
  shownAlarms: {},
  evaluatedAlarms: {},
  countdownInterval: null,
  checkInterval: null,
  vaultDirHandle: null,
  _pendingHandle: null,
  // Derived sub-handles (populated by deriveSubHandles after vault connected)
  habitTrackerDirHandle: null,  // Habit Tracker/ â€” holds config .md
  habitDataDirHandle: null,     // Habit Tracker/data/ â€” holds daily HT files
  logDirHandle: null,
  logTemplateHandle: null,
  logOutputDirHandle: null,
  eventsDirHandle: null,
  // Session permission flag â€” vault permission asked once per session
  _sessionPermissionGranted: false,
  scheduleOpen: false,
  notifPermission: Notification.permission,
};

const LS = {
  get: k => { try { return JSON.parse(localStorage.getItem(k)); } catch { return null; } },
  set: (k,v) => { try { localStorage.setItem(k, JSON.stringify(v)); } catch {} },
  del: k => { try { localStorage.removeItem(k); } catch {} },
};

// â”€â”€ IndexedDB â€” stores FileSystemDirectoryHandle (localStorage can't) â”€â”€â”€â”€â”€â”€
const IDB = (() => {
  let db = null;
  const open = () => new Promise((res,rej) => {
    if (db) { res(db); return; }
    const r = indexedDB.open('habit-tracker-v1', 2);
    r.onupgradeneeded = e => {
      const d = e.target.result;
      if (!d.objectStoreNames.contains('kv'))   d.createObjectStore('kv');
      if (!d.objectStoreNames.contains('logs'))  d.createObjectStore('logs', { keyPath: 'id' });
    };
    r.onsuccess = e => { db = e.target.result; db.onclose = () => { db = null; }; res(db); };
    r.onerror = () => rej(r.error);
  });
  return {
    set: async (k,v) => {
      const d = await open();
      return new Promise((res,rej) => {
        const tx = d.transaction('kv','readwrite');
        tx.objectStore('kv').put(v, k);
        tx.oncomplete = () => res(true);
        tx.onerror = () => rej(tx.error);
      });
    },
    get: async (k) => {
      const d = await open();
      return new Promise((res,rej) => {
        const tx = d.transaction('kv','readonly');
        const r = tx.objectStore('kv').get(k);
        r.onsuccess = () => res(r.result);
        r.onerror = () => rej(r.error);
      });
    },
    del: async (k) => {
      const d = await open();
      return new Promise((res,rej) => {
        const tx = d.transaction('kv','readwrite');
        tx.objectStore('kv').delete(k);
        tx.oncomplete = () => res(true);
        tx.onerror = () => rej(tx.error);
      });
    },
    open,
  };
})();

// â”€â”€ IDB LOG STORE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Logs saved here on ALL platforms. On desktop also written to folder.
// On Android folder write silently fails â€” IDB is the only storage.
const IDBLogs = {
  async save(log) {
    try {
      const d = await IDB.open();
      return new Promise((res,rej) => {
        const tx = d.transaction('logs','readwrite');
        tx.objectStore('logs').put(log);
        tx.oncomplete = () => res(true);
        tx.onerror = () => rej(tx.error);
      });
    } catch(e) { console.warn('IDBLogs.save failed:', e); return false; }
  },
  async getAll() {
    try {
      const d = await IDB.open();
      return new Promise((res,rej) => {
        const tx = d.transaction('logs','readonly');
        const r = tx.objectStore('logs').getAll();
        r.onsuccess = () => res(r.result || []);
        r.onerror = () => rej(r.error);
      });
    } catch(e) { console.warn('IDBLogs.getAll failed:', e); return []; }
  },
  async get(id) {
    try {
      const d = await IDB.open();
      return new Promise((res,rej) => {
        const tx = d.transaction('logs','readonly');
        const r = tx.objectStore('logs').get(id);
        r.onsuccess = () => res(r.result);
        r.onerror = () => rej(r.error);
      });
    } catch(e) { console.warn('IDBLogs.get failed:', e); return null; }
  },
  async delete(id) {
    try {
      const d = await IDB.open();
      return new Promise((res,rej) => {
        const tx = d.transaction('logs','readwrite');
        tx.objectStore('logs').delete(id);
        tx.oncomplete = () => res(true);
        tx.onerror = () => rej(tx.error);
      });
    } catch(e) { console.warn('IDBLogs.delete failed:', e); return false; }
  },
};

let _todayStrCache = '', _todayStrDate = -1;
function todayStr() {
  const d = new Date(), day = d.getDate();
  if (day !== _todayStrDate) { _todayStrDate = day; _todayStrCache = d.toISOString().slice(0,10).replace(/-/g,''); }
  return _todayStrCache;
}
function todayFilename() { return `22101995${todayStr()}HT.md`; }

function parseTime(str) {
  const [t,p] = str.split(' ');
  let [h,m] = t.split(':').map(Number);
  if (p==='PM' && h!==12) h+=12;
  if (p==='AM' && h===12) h=0;
  return {h,m};
}
function schedDate(ts) {
  const {h,m} = parseTime(ts);
  const d = new Date(); d.setHours(h,m,0,0); return d;
}
function fmtMs(ms) {
  const s=Math.floor(ms/1000), hh=Math.floor(s/3600), mm=Math.floor((s%3600)/60), ss=s%60;
  if (hh>0) return `${hh}h ${mm}m ${ss}s`;
  if (mm>0) return `${mm}m ${ss}s`;
  return `${ss}s`;
}

// â”€â”€ VAULT PATHS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// All sub-folder paths are relative to the vault root
const TB_PATHS = [
  ['0 - Personal Space', 'Time Blocks'],
  ['Time Blocks'],
  ['time blocks'],
  ['TimeBlocks'],
  ['0 - Personal Space', 'time blocks'],
];
const VAULT_PATHS = {
  habitTracker: ['0 - Personal Space', 'Habit Tracker'],
  habitData:    ['0 - Personal Space', 'Habit Tracker', 'data'],
  logOutput:    ['0 - Personal Space', 'Chrono Log', 'data'],
  events:       ['0 - Personal Space', 'Events'],
  timeBlocks:   ['0 - Personal Space', 'Time Blocks'],
};

// Navigate (and optionally create) a chain of subdirectories from a root handle.
async function _navSubDir(root, pathParts, create = true) {
  try {
    let dir = root;
    for (const seg of pathParts) {
      dir = await dir.getDirectoryHandle(seg, { create });
    }
    return dir;
  } catch { return null; }
}

// Populate all sub-handles from the vault root. Called after permission granted.
async function deriveSubHandles() {
  if (!S.vaultDirHandle) return;
  try {
    S.habitTrackerDirHandle = await _navSubDir(S.vaultDirHandle, VAULT_PATHS.habitTracker, true);
    S.habitDataDirHandle    = await _navSubDir(S.vaultDirHandle, VAULT_PATHS.habitData, true);
    S.logOutputDirHandle    = await _navSubDir(S.vaultDirHandle, VAULT_PATHS.logOutput, true);
    S.eventsDirHandle       = await _navSubDir(S.vaultDirHandle, VAULT_PATHS.events, true);
    // Try multiple candidate paths for Time Blocks
    S.timeBlocksDirHandle = null;
    for (const p of TB_PATHS) {
      S.timeBlocksDirHandle = await _navSubDir(S.vaultDirHandle, p, false);
      if (S.timeBlocksDirHandle) break;
    }
    // Log template is a file inside logOutput dir
    if (S.logOutputDirHandle) {
      try {
        S.logTemplateHandle = await S.logOutputDirHandle.getFileHandle('_Daily_Log_Template.md', { create: false });
      } catch { S.logTemplateHandle = null; }
    }
  } catch(e) { console.warn('deriveSubHandles:', e.message); }
}

// â”€â”€ VAULT FOLDER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function pickVaultFolder() {
  try {
    const dh = await window.showDirectoryPicker({ mode:'readwrite', id:'vault' });
    S.vaultDirHandle = dh;
    S._pendingHandle = null;
    S._sessionPermissionGranted = true;
    await IDB.set('vaultHandle', dh);
    LS.set('vaultFolderName', dh.name);
    await deriveSubHandles();
    showToast(`ðŸ“ ${dh.name} connected`);
    return true;
  } catch(e) {
    if (e.name !== 'AbortError') showToast('Could not open folder');
    return false;
  }
}

async function restoreVaultHandle() {
  try {
    const dh = await IDB.get('vaultHandle');
    if (!dh) return 'none';
    // Validate the handle is usable â€” bad handles from old deployments throw here
    let perm;
    try {
      perm = await dh.queryPermission({ mode: 'readwrite' });
    } catch {
      // Handle is corrupt/stale (e.g. from a different origin/deployment)
      // Clear it so user gets a clean first-run setup
      await IDB.del('vaultHandle');
      LS.del('vaultFolderName');
      return 'none';
    }
    if (perm === 'granted') {
      S.vaultDirHandle = dh;
      S._sessionPermissionGranted = true;
      return 'granted';
    }
    S._pendingHandle = dh;
    return 'needs-grant';
  } catch { return 'none'; }
}

async function reconnectVault() {
  const dh = S._pendingHandle || await IDB.get('vaultHandle').catch(()=>null);
  if (!dh) { await pickVaultFolder(); return !!S.vaultDirHandle; }
  try {
    const perm = await dh.requestPermission({ mode: 'readwrite' });
    if (perm === 'granted') {
      S.vaultDirHandle = dh;
      S._pendingHandle = null;
      S._sessionPermissionGranted = true;
      document.getElementById('reconnect-area').innerHTML = '';
      await deriveSubHandles();
      return true;
    }
  } catch {}
  return false;
}

// â”€â”€ GET DATA SUBFOLDER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Returns Habit Tracker/ handle â€” used for reading/writing the config .md
async function getDataDir() {
  if (S.habitTrackerDirHandle) return S.habitTrackerDirHandle;
  if (!S.vaultDirHandle) return null;
  S.habitTrackerDirHandle = await _navSubDir(S.vaultDirHandle, VAULT_PATHS.habitTracker, true);
  return S.habitTrackerDirHandle;
}

// Returns Habit Tracker/data/ handle â€” used for daily habit data files
async function getHabitDataDir() {
  if (S.habitDataDirHandle) return S.habitDataDirHandle;
  if (!S.vaultDirHandle) return null;
  S.habitDataDirHandle = await _navSubDir(S.vaultDirHandle, VAULT_PATHS.habitData, true);
  return S.habitDataDirHandle;
}

// â”€â”€ LOAD FROM VAULT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function loadFromVault() {
  if (!S.vaultDirHandle) return;
  LS.del('lastConfig');
  LS.del('lastScheduleEdit');
  await loadTemplate();
  await loadHabitDataFromFile();
}

async function loadTemplate() {
  if (!S.vaultDirHandle) return false;
  try {
    // â”€â”€ Load habit definitions from Habit Tracker folder â”€â”€
    const htDir = (await getDataDir()) || S.vaultDirHandle;
    let habitDefinitions = {};
    let habitTracker = { enabled: true, snoozeOptions: [5, 10] };
    for await (const entry of htDir.values()) {
      if (entry.kind === 'file' && entry.name.endsWith('.md') && !entry.name.match(/^\d{16}HT\.md$/)) {
        const file = await entry.getFile();
        const text = (await file.text()).replace(/\r\n/g, '\n').replace(/\r/g, '\n');
        // Try new kebab-case format first (habit-definition:)
        const newFmt = parseHabitTrackerMd(text);
        if (newFmt && Object.keys(newFmt.habitDefinitions || {}).length) {
          habitDefinitions = newFmt.habitDefinitions;
          habitTracker = newFmt.habitTracker || habitTracker;
          break;
        }
        // Fallback: try legacy camelCase format
        const cfg = parseMd(text);
        if (cfg && Object.keys(cfg.habitDefinitions || {}).length) {
          habitDefinitions = cfg.habitDefinitions || habitDefinitions;
          habitTracker = cfg.habitTracker || habitTracker;
          break;
        }
      }
    }

    // â”€â”€ Load schedule from Time Blocks folder â”€â”€
    // Try in order: cached handle â†’ standard path â†’ vault root (files directly in vault)
    let tbDir = S.timeBlocksDirHandle;
    if (!tbDir) {
      // Try several candidate paths before falling back to vault root
      for (const path of TB_PATHS) {
        tbDir = await _navSubDir(S.vaultDirHandle, path, false);
        if (tbDir) { S.timeBlocksDirHandle = tbDir; break; }
      }
    }
    let schedule = [];
    if (tbDir) {
      schedule = await loadScheduleFromTimeBlocksDir(tbDir);
    }
    // Fallback: scan vault root itself for time block files
    if (!schedule.length) {
        schedule = await loadScheduleFromTimeBlocksDir(S.vaultDirHandle);
    }

    // Always use freshly loaded vault data; local edits are synced to vault immediately
    S.config = { schedule, habitDefinitions, habitTracker };
    LS.del('lastScheduleEdit');
    LS.set('lastConfig', S.config);
    return true;
  } catch(e) { console.error('loadTemplate:', e); return false; }
}

// Expand a parsed scheduled-event object (with _times[] and _dates[]) into
// one schedule item per date, each carrying its own time.
// If fewer times than dates, the last time is reused for remaining dates.
// If no dates at all, creates a single item using the first time (or '9:00 AM').
function _expandScheduledEvent(cur) {
  const times  = cur._times  || [];
  const dates  = cur._dates  || [];
  const dur    = cur.duration;
  const act    = cur.activity;
  const baseId = cur._id;

  // Helper: get time for index i (clamps to last entry)
  const getTime = i => times.length === 0 ? '9:00 AM'
                     : times[Math.min(i, times.length - 1)];

  if (dates.length === 0) {
    // No dates â€” create a floating item (will always show, legacy behaviour)
    const item = { activity: act, blockType: 'scheduled', repeat: 'daily', _id: baseId, time: getTime(0) };
    if (dur) item.duration = dur;
    return [item];
  }

  return dates.map((date, i) => {
    const item = {
      _id: i === 0 ? baseId : genItemId(),
      activity: act,
      blockType: 'scheduled',
      time: getTime(i),
      repeat: 'once',
      createdOn: date,
    };
    if (dur) item.duration = dur;
    return item;
  });
}

// Parse all 3 Time Block file types from the Time Blocks folder
async function loadScheduleFromTimeBlocksDir(dir) {
  const schedule = [];
  const todayISO = new Date().toISOString().slice(0,10);
  console.log('[TimeBlocks] Scanning dir:', dir?.name);
  try {
    for await (const entry of dir.values()) {
      if (entry.kind !== 'file' || !entry.name.endsWith('.md')) continue;
        const raw = await (await entry.getFile()).text();
      const text = raw.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
      const fm = text.match(/^---\n([\s\S]+?)\n---/);
      if (!fm) { console.log('[TimeBlocks]', entry.name, 'â€” no frontmatter found'); continue; }
      const yaml = fm[1];
  
      // â”€â”€ Daily Routine â”€â”€
      if (yaml.includes('daily-routine:')) {
        const block = yaml.match(/daily-routine:\s*\n([\s\S]*?)(?=\n\w|$)/);
        if (block) {
          let cur = null;
          for (const line of block[1].split('\n')) {
            const tM = line.match(/^\s*-?\s*time:\s*['"]?(.+?)['"]?\s*$/);
            const aM = line.match(/^\s+activity:\s*['"]?(.+?)['"]?\s*$/);
            const dM = line.match(/^\s+duration:\s*(\d+)/);
            if (tM) { if (cur?.activity) schedule.push(cur); cur = { time: tM[1].trim(), blockType: 'routine', repeat: 'daily', _id: genItemId() }; }
            else if (aM && cur) cur.activity = aM[1].trim();
            else if (dM && cur) cur.duration = parseInt(dM[1]);
          }
          if (cur?.activity) schedule.push(cur);
        }
      }

      // â”€â”€ Scheduled Event â”€â”€
      if (yaml.includes('scheduled-event:')) {
        const block = yaml.match(/scheduled-event:\s*\n([\s\S]*?)(?=\n\w|$)/);
        if (block) {
          let cur = null;
          // Track which sub-list we're currently inside for the current item
          let inTimesBlock = false;
          let inDatesBlock = false;
          for (const line of block[1].split('\n')) {
            const aM  = line.match(/^\s*-?\s*activity:\s*['"]?(.+?)['"]?\s*$/);
            const tM  = line.match(/^\s+time:\s*['"]?(.+?)['"]?\s*$/);   // legacy single time
            const dM  = line.match(/^\s+duration:\s*(\d+)/);
            // Sub-list headers (e.g. "    times:" / "    dates:")
            const timesHdr  = line.match(/^\s+times:\s*$/);
            const datesHdr  = line.match(/^\s+dates:\s*$/);
            // List item inside a sub-block: "      - 'value'" or "      - 2026-01-01"
            const subItem   = line.match(/^\s{4,}-\s*['"]?(.+?)['"]?\s*$/);
            // Detect when we leave a sub-block (less indented non-empty line)
            const isSubLine = /^\s{4}/.test(line) || line.trim() === '';

            if (aM) {
              // Push previous event
              if (cur?.activity) {
                const expandedItems = _expandScheduledEvent(cur);
                expandedItems.forEach(i => schedule.push(i));
              }
              cur = { activity: aM[1].trim(), blockType: 'scheduled', _id: genItemId(), _times: [], _dates: [] };
              inTimesBlock = false; inDatesBlock = false;
            } else if (cur) {
              if (timesHdr)       { inTimesBlock = true;  inDatesBlock = false; }
              else if (datesHdr)  { inDatesBlock = true;  inTimesBlock = false; }
              else if (tM)        { cur._times.push(tM[1].trim()); inTimesBlock = false; inDatesBlock = false; } // legacy "time: X"
              else if (dM)        { cur.duration = parseInt(dM[1]); inTimesBlock = false; inDatesBlock = false; }
              else if (subItem) {
                const val = subItem[1].trim();
                if (inTimesBlock) cur._times.push(val);
                else if (inDatesBlock) cur._dates.push(val);
              } else if (!isSubLine) {
                // Non-indented line that isn't an activity = end of this event's block
                inTimesBlock = false; inDatesBlock = false;
              }
            }
          }
          if (cur?.activity) {
            const expandedItems = _expandScheduledEvent(cur);
            expandedItems.forEach(i => schedule.push(i));
          }
        }
      }

      // â”€â”€ Focused Work â”€â”€
      if (yaml.includes('focused-work:')) {
        const block = yaml.match(/focused-work:\s*\n([\s\S]*?)(?=\n\w|$)/);
        if (block) {
          let cur = null;
          for (const line of block[1].split('\n')) {
            const aM = line.match(/^\s*-?\s*activity:\s*['"]?(.+?)['"]?\s*$/);
            const dM = line.match(/^\s+duration:\s*(\d+)/);
            if (aM) { if (cur?.activity) schedule.push(cur); cur = { activity: aM[1].trim(), blockType: 'open', repeat: 'daily', time: '8:00 AM', _id: genItemId() }; }
            else if (dM && cur) cur.duration = parseInt(dM[1]);
          }
          if (cur?.activity) schedule.push(cur);
        }
      }
    }
  } catch(e) { console.warn('[TimeBlocks] Error:', e.message); }
  console.log('[TimeBlocks] Parsed', schedule.length, 'items:', schedule.map(s=>s.activity));
  // Sort by time
  try { schedule.sort((a, b) => schedDate(a.time) - schedDate(b.time)); } catch {}
  return schedule;
}

async function loadHabitDataFromFile() {
  // localStorage is always written first on every habit update â€” treat it as
  // the authoritative source for today.  Vault file may lag behind (async write)
  // so we merge: for each key take whichever value is higher.
  const lsData = LS.get('habitData_' + todayStr()) || {};

  if (S.vaultDirHandle) {
    try {
      const dataDir = await getHabitDataDir();
      if (dataDir) {
        const fh = await dataDir.getFileHandle(todayFilename(), { create:false });
        const text = (await (await fh.getFile()).text()).replace(/\r\n/g, '\n').replace(/\r/g, '\n');
        const m = text.match(/^---\n([\s\S]+?)\n---/);
        if (m) {
          const vaultData = {};
          m[1].split('\n').forEach(line => {
            const lm = line.match(/^(\w+):\s*(.+)/);
            if (lm) vaultData[lm[1]] = parseInt(lm[2]) || 0;
          });
          // Merge: take the higher value so a just-logged habit never reverts
          const merged = { ...vaultData };
          for (const k of Object.keys(lsData)) {
            merged[k] = Math.max(vaultData[k] ?? 0, lsData[k] ?? 0);
          }
          S.habitData = merged;
          return;
        }
      }
    } catch { /* file doesn't exist yet â€” created on first write */ }
  }
  S.habitData = lsData;
}

let _habitWritePending = false;
let _habitWriteQueued = false;

async function writeHabitData() {
  // Always save to localStorage immediately â€” this is instant and never fails
  LS.set('habitData_' + todayStr(), S.habitData);

  // Debounce vault writes: if one is already in flight, just flag to re-run after
  if (_habitWritePending) { _habitWriteQueued = true; return; }
  if (!S.vaultDirHandle || !S.config) return;

  _habitWritePending = true;
  try {
    const dataDir = await getHabitDataDir();
    if (dataDir) {
      const fn = todayFilename();
      const keys = Object.keys(S.config.habitDefinitions || {});
      // Snapshot habitData at write time (may have changed while awaiting)
      const snapshot = { ...S.habitData };
      const yaml = keys.map(k => `${k}: ${snapshot[k] ?? 0}`).join('\n');
      const fh = await dataDir.getFileHandle(fn, { create: true });
      await _writeFileHandle(fh, `---\n${yaml}\n---\n`);
    }
  } catch(e) {
    console.warn('Vault habit write failed (localStorage used):', e.message);
  } finally {
    _habitWritePending = false;
    if (_habitWriteQueued) {
      _habitWriteQueued = false;
      writeHabitData(); // flush the queued update
    }
  }
}

// â”€â”€ PARSE Habit Tracker.md (kebab-case format) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Handles: habit-definition: and habit-tracker: keys
function parseHabitTrackerMd(text) {
  const fm = text.match(/^---\n([\s\S]+?)\n---/);
  if (!fm) return null;
  const yaml = fm[1];
  const habitDefinitions = {};
  let habitTracker = { enabled: true, snoozeOptions: [5, 10] };

  try {
    // Parse habit-definition block (find lines between habit-definition: and next top-level key)
    const lines = yaml.split('\n');
    let inDefBlock = false, inTrackerBlock = false;
    let defLines = [], trackerLines = [];

    for (const line of lines) {
      if (/^habit-definition:\s*$/.test(line)) { inDefBlock = true; inTrackerBlock = false; continue; }
      if (/^habit-tracker:\s*$/.test(line))    { inTrackerBlock = true; inDefBlock = false; continue; }
      if (/^[a-zA-Z]/.test(line) && !/^\s/.test(line)) { inDefBlock = false; inTrackerBlock = false; }
      if (inDefBlock) defLines.push(line);
      if (inTrackerBlock) trackerLines.push(line);
    }

    // Parse habit definitions from defLines
    if (defLines.length) {
      let key = null, def = null;
      const pushDef = () => { if (key && def) habitDefinitions[key] = def; };
      let inMessages = false, inChoices = false, curChoice = null;

      for (const line of defLines) {
        const keyM = line.match(/^  (\w+):\s*$/);
        if (keyM) {
          if (curChoice && def) def.choices.push(curChoice);
          pushDef();
          key = keyM[1]; def = { type: 'incremental', icon: 'â­', messages: {}, choices: [] };
          inMessages = false; inChoices = false; curChoice = null;
          continue;
        }
        if (!def) continue;

        const typeM  = line.match(/^\s+type:\s+(\w+)/);
        const iconM  = line.match(/^\s+icon:\s+(.+)/);
        const maxM   = line.match(/^\s+maxValue:\s+(\d+)/);
        const incrM  = line.match(/^\s+increment:\s+(\d+)/);
        const msgHdr = line.match(/^\s+messages:\s*$/);
        const chHdr  = line.match(/^\s+choices:\s*$/);

        if (typeM)  { def.type = typeM[1].trim(); continue; }
        if (iconM)  { def.icon = iconM[1].trim().replace(/\s*#.*$/, '').trim(); continue; }
        if (maxM)   { def.maxValue = parseInt(maxM[1]); continue; }
        if (incrM)  { def.increment = parseInt(incrM[1]); continue; }
        if (msgHdr) { inMessages = true; inChoices = false; continue; }
        if (chHdr)  { inChoices = true; inMessages = false; continue; }

        if (inMessages) {
          const mm = line.match(/^\s+(\w+):\s*['"]?(.+?)['"]?\s*$/);
          if (mm) def.messages[isNaN(mm[1]) ? mm[1] : parseInt(mm[1])] = mm[2].trim();
        }
        if (inChoices) {
          if (line.match(/^\s+-\s/)) { if (curChoice) def.choices.push(curChoice); curChoice = {}; }
          if (curChoice) {
            const vM = line.match(/value:\s*(\d+)/);
            const lM = line.match(/label:\s*['"]?(.+?)['"]?\s*$/);
            const mM = line.match(/message:\s*['"]?(.+?)['"]?\s*$/);
            if (vM) curChoice.value = parseInt(vM[1]);
            if (lM) curChoice.label = lM[1].trim();
            if (mM) curChoice.message = mM[1].trim();
          }
        }
      }
      if (curChoice && def) def.choices.push(curChoice);
      pushDef();
    }

    // Parse habit-tracker config from trackerLines
    if (trackerLines.length) {
      const tb = trackerLines.join('\n');
      const enabledM = tb.match(/enabled:\s*(true|false)/);
      const snoozeM  = tb.match(/snoozeOptions:\s*\[([^\]]+)\]/);
      const startM   = tb.match(/startTime:\s*["']?(\S+?)["']?\s*(?:\n|$)/);
      const endM     = tb.match(/endTime:\s*["']?(\S+?)["']?\s*(?:\n|$)/);
      habitTracker = {
        enabled: enabledM ? enabledM[1] === 'true' : true,
        snoozeOptions: snoozeM ? snoozeM[1].split(',').map(s => parseInt(s.trim())).filter(Boolean) : [5, 10],
        startTime: startM ? startM[1] : '06:30',
        endTime:   endM   ? endM[1]   : '21:30',
      };
    }
  } catch(e) { console.warn('parseHabitTrackerMd:', e); }

  return { habitDefinitions, habitTracker };
}

// â”€â”€ PARSE .MD FRONTMATTER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function parseMd(text) {
  const fm = text.match(/^---\n([\s\S]+?)\n---/);
  if (!fm) return null;
  try {
    const yaml = fm[1];
    const schedule = [];
    const sm = yaml.match(/^schedule:\s*\n([\s\S]*?)(?=^[a-zA-Z]\w*:)/m);
    if (sm) {
      let cur = null;
      for (const line of sm[1].split('\n')) {
        const tM = line.match(/^\s*-?\s*time:\s*["']?(.+?)["']?\s*$/);
        const aM = line.match(/^\s+activity:\s*["']?(.+?)["']?\s*$/);
        const rM = line.match(/^\s+repeat:\s*(\w+)/);
        const cM = line.match(/^\s+createdOn:\s*["']?(.+?)["']?\s*$/);
        const dM = line.match(/^\s+customDates:\s*["']?(.+?)["']?\s*$/);
        const lmM = line.match(/^\s+limitFrom:\s*["']?(.+?)["']?\s*$/);
        const ltM = line.match(/^\s+limitTo:\s*["']?(.+?)["']?\s*$/);
        const ptM = line.match(/^\s+perDateTimes:\s*["']?(.+?)["']?\s*$/);
        if (tM) {
          if (cur && cur.activity) schedule.push(cur);
          cur = { time: tM[1].trim() };
        } else if (aM && cur) { cur.activity = aM[1].trim(); }
        else if (rM && cur) { cur.repeat = rM[1].trim(); }
        else if (cM && cur) { cur.createdOn = cM[1].trim(); }
        else if (dM && cur) { try { cur.customDates = JSON.parse(dM[1].trim()); } catch { cur.customDates = dM[1].split(',').map(d=>d.trim()); } }
        else if (lmM && cur) { cur.limitFrom = lmM[1].trim(); }
        else if (ltM && cur) { cur.limitTo = ltM[1].trim(); }
        else if (ptM && cur) { try { cur.perDateTimes = JSON.parse(ptM[1].trim()); } catch {} }
      }
      if (cur && cur.activity) schedule.push(cur);
    }
    const habitDefinitions = {};
    const hm = yaml.match(/^habitDefinitions:\s*\n([\s\S]*?)(?=^[a-zA-Z]\w*:)/m);
    if (hm) {
      for (const block of hm[1].split(/\n(?=  \w)/)) {
        const km = block.match(/^\s{2}(\w+):/);
        if (!km) continue;
        const def = {
          type: (block.match(/type:\s*(\w+)/)||[])[1]||'incremental',
          icon: ((block.match(/icon:\s*(.+?)(\s*#.*)?$/m)||[])[1]||'â­').trim(),
          messages:{}, choices:[],
        };
        const maxM=block.match(/maxValue:\s*(\d+)/), incrM=block.match(/increment:\s*(\d+)/);
        if (maxM) def.maxValue=parseInt(maxM[1]);
        if (incrM) def.increment=parseInt(incrM[1]);
        const msgM=block.match(/messages:\s*\n([\s\S]*?)(?=\n    \w|\n  \w|$)/);
        if (msgM) msgM[1].split('\n').forEach(ml=>{
          const mm=ml.match(/\s+(\w+):\s*["']?(.+?)["']?\s*$/);
          if (mm) def.messages[isNaN(mm[1])?mm[1]:parseInt(mm[1])]=mm[2].trim();
        });
        const chM=block.match(/choices:\s*\n([\s\S]*?)(?=\n  \w|$)/);
        if (chM) {
          let ch=null;
          for (const cl of chM[1].split('\n')) {
            if (cl.match(/^\s*-\s/)) { if(ch) def.choices.push(ch); ch={}; }
            const vM=cl.match(/value:\s*(\d+)/), lM=cl.match(/label:\s*["']?(.+?)["']?\s*$/), mM=cl.match(/message:\s*["']?(.+?)["']?\s*$/);
            if (vM&&ch) ch.value=parseInt(vM[1]);
            if (lM&&ch) ch.label=lM[1].trim();
            if (mM&&ch) ch.message=mM[1].trim();
          }
          if (ch&&Object.keys(ch).length) def.choices.push(ch);
        }
        habitDefinitions[km[1]]=def;
      }
    }
    const snM=yaml.match(/snoozeOptions:\s*\[([^\]]+)\]/);
    const snoozeOptions=snM?snM[1].split(',').map(s=>parseInt(s.trim())).filter(Boolean):[5,10];
    return { schedule, habitDefinitions, habitTracker:{ enabled:true, snoozeOptions } };
  } catch(e) { console.error('Parse error',e); return null; }
}

// â”€â”€ HABIT UPDATES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateHabit(key, value) {
  const cfg=S.config?.habitDefinitions?.[key]; if (!cfg) return;
  if (cfg.type==='incremental') {
    const cur=S.habitData[key]||0;
    S.habitData[key]=Math.min(cfg.maxValue, cur+value);
    showToast(cfg.messages?.[S.habitData[key]]||'Logged!');
  } else {
    S.habitData[key]=value;
    showToast(cfg.choices?.find(c=>c.value===value)?.message||'Logged!');
  }
  writeHabitData();
  renderHabitBars();
}
function decrementHabit(key) {
  const cfg=S.config?.habitDefinitions?.[key];
  if (!cfg||cfg.type!=='incremental') return;
  S.habitData[key]=Math.max(0,(S.habitData[key]||0)-cfg.increment);
  showToast(`${key} â†’ ${S.habitData[key]}`);
  writeHabitData();
  renderHabitBars();
}

// â”€â”€ SCHEDULE HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Returns only schedule items that apply to today based on their repeat field.
// Memoized per JS tick â€” multiple callers in the same tick share one computation.
let _todaySchedCache = null;
function getTodaySchedule() {
  if (_todaySchedCache) return _todaySchedCache;
  _todaySchedCache = _getTodaySchedule();
  queueMicrotask(() => { _todaySchedCache = null; });
  return _todaySchedCache;
}
function _getTodaySchedule() {
  const all = S.config?.schedule || [];
  const now = new Date();
  const todayISO = now.toISOString().slice(0,10); // YYYY-MM-DD
  const dow = now.getDay(); // 0=Sun
  const dom = now.getDate();

  return all.filter(item => {
    // Check limit range first
    if (item.limitFrom && todayISO < item.limitFrom) return false;
    if (item.limitTo && todayISO > item.limitTo) return false;

    const r = item.repeat || 'daily'; // default: daily (backward compat)
    if (r === 'daily') return true;
    if (r === 'off') return false;
    if (r === 'weekly') {
      // item must have a createdOn date â€” match same weekday
      if (!item.createdOn) return true; // legacy: always show
      const created = new Date(item.createdOn + 'T00:00:00');
      return created.getDay() === dow;
    }
    if (r === 'monthly') {
      if (!item.createdOn) return true;
      const created = new Date(item.createdOn + 'T00:00:00');
      return created.getDate() === dom;
    }
    if (r === 'yearly') {
      if (!item.createdOn) return true;
      const created = new Date(item.createdOn + 'T00:00:00');
      return created.getMonth() === now.getMonth() && created.getDate() === dom;
    }
    if (r === 'once') {
      // One-time entry: only show on its createdOn date
      return item.createdOn === todayISO;
    }
    if (r === 'custom') {
      // Custom dates: show only if today is in the list
      const dates = item.customDates || [];
      return dates.includes(todayISO);
    }
    return true;
  }).sort((a, b) => {
    const ta = schedDate(a.time), tb = schedDate(b.time);
    return ta - tb;
  });
}

function getCurNext() {
  // cur = index of the task whose window (start â†’ start+duration) contains now,
  //        OR the most-recently-passed task if we're between tasks.
  // next = index of the next upcoming task (start > now).
  const now=new Date(), sc=getTodaySchedule();
  let cur=-1, next=-1;
  for (let i=0;i<sc.length;i++) {
    const t = schedDate(sc[i].time);
    if (t <= now) cur = i;      // task has started
    else if (next === -1) { next = i; break; }
  }
  return {cur, next};
}

// Returns true if we are currently INSIDE task i (start <= now < start+duration)
function isInsideTask(sc, i) {
  if (i < 0 || i >= sc.length) return false;
  const start = schedDate(sc[i].time);
  const dur   = (sc[i].duration || 30) * 60000;
  const end   = new Date(start.getTime() + dur);
  const now   = new Date();
  return now >= start && now < end;
}

// Returns true if we are past the end of the last task for today
function isPastLastTask() {
  const sc = getTodaySchedule();
  if (!sc.length) return false;
  const last = sc[sc.length - 1];
  const start = schedDate(last.time);
  const dur   = (last.duration || 30) * 60000;
  return Date.now() >= start.getTime() + dur;
}

// Returns true if we are before the first task of today
function isBeforeFirstTask() {
  const sc = getTodaySchedule();
  if (!sc.length) return false;
  return new Date() < schedDate(sc[0].time);
}
function detectHabit(activity) {
  for (const [key,cfg] of Object.entries(S.config?.habitDefinitions||{}))
    if (activity.includes(cfg.icon)) return {key,config:cfg};
  return null;
}

// â”€â”€ ALARM CHECK + MODAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function checkAlarms() {
  if (!S.config) return;
  if (LS.get('notifsEnabled') === false) return;
  const now=Date.now(), sc=getTodaySchedule();
  for (const idx in S.snooze) {
    if (S.snooze[idx]<=now) {
      delete S.snooze[idx]; const i=parseInt(idx);
      if (!S.shownAlarms[i]||(now-S.shownAlarms[i])>30000) { showAlarmModal(i); return; }
    }
  }
  for (let i=0;i<sc.length;i++) {
    const diff=now-schedDate(sc[i].time).getTime();
    if (diff>=0&&diff<5000) {
      if (S.shownAlarms[i]&&(now-S.shownAlarms[i])<120000) continue;
      if (S.snooze[i]&&S.snooze[i]>now) continue;
      showAlarmModal(i); return;
    }
  }
}

// â”€â”€ SYNC ALL TODAY'S ALARMS TO SERVICE WORKER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Called whenever the schedule changes or the app loads.
// Sends every future alarm for today so the SW can fire them independently.
function syncAlarmsToSW() {
  if (!navigator.serviceWorker?.controller) return;
  if (S.notifPermission !== 'granted') return;
  if (LS.get('notifsEnabled') === false) return;
  if (!S.config?.schedule?.length) return;

  const snOpts = S.config.habitTracker?.snoozeOptions || [5, 10];
  const alarms = [];
  const now = Date.now();

  getTodaySchedule().forEach((item, idx) => {
    const fireAt = schedDate(item.time).getTime();
    if (fireAt <= now) return; // already past

    const hi = detectHabit(item.activity);
    const actions = [];
    if (hi) {
      const { key, config: cfg } = hi;
      if (cfg.type === 'incremental') actions.push({ action: `habit:${key}:${cfg.increment}`, title: `âœ“ Done (+${cfg.increment})` });
      else cfg.choices.slice(0, 2).forEach(c => actions.push({ action: `habit:${key}:${c.value}`, title: c.label }));
    }
    actions.push({ action: 'dismiss', title: 'Dismiss' });
    snOpts.slice(0, 1).forEach(m => actions.push({ action: `snooze:${idx}:${m}`, title: `â° +${m}m` }));

    alarms.push({
      tag:     `alarm-${idx}`,
      title:   `â° ${item.time} â€” ${item.activity}`,
      body:    hi ? `Time to log ${hi.key}` : 'Time for your next activity',
      fireAt,
      actions,
      data:    { idx, habitKey: hi?.key, habitVal: hi?.config?.type === 'incremental' ? hi?.config?.increment : null }
    });
  });

  navigator.serviceWorker.controller.postMessage({ type: 'SYNC_ALARMS', alarms });
}

function showAlarmModal(idx) {
  S.shownAlarms[idx]=Date.now();
  const item=getTodaySchedule()[idx]; if(!item) return;
  // Only show habit action buttons for daily routine items
  const isRoutine = item.blockType === 'routine' || (!item.blockType && (item.repeat||'daily') === 'daily');
  const hi = isRoutine ? detectHabit(item.activity) : null;
  const snOpts=S.config.habitTracker?.snoozeOptions||[5,10];
  playBeep();

  // Push notification
  if (S.notifPermission==='granted') {
    const actions = [];
    if (hi) {
      const {key, config:cfg} = hi;
      if (cfg.type==='incremental') actions.push({ action:`habit:${key}:${cfg.increment}`, title:`âœ“ Done (+${cfg.increment})` });
      else cfg.choices.slice(0,2).forEach(c=>actions.push({ action:`habit:${key}:${c.value}`, title:c.label }));
    }
    actions.push({ action:'dismiss', title:'Dismiss' });
    snOpts.slice(0,1).forEach(m=>actions.push({ action:`snooze:${idx}:${m}`, title:`â° +${m}m` }));
    if (navigator.serviceWorker.controller) {
      navigator.serviceWorker.controller.postMessage({
        type:'SHOW_ALARM', title:`â° ${item.time} â€” ${item.activity}`,
        body: hi ? `Tap to log ${hi.key}` : 'Time for your next activity',
        tag:`alarm-${idx}`, data:{idx, habitKey:hi?.key, habitVal:hi?.config?.type==='incremental'?hi?.config?.increment:null}, actions
      });
    } else {
      new Notification(`â° ${item.activity}`, { body:`${item.time}${hi?` Â· Log ${hi.key}`:''}`, tag:`alarm-${idx}`, requireInteraction:true });
    }
  }

  // Prevent duplicate in-app modals
  document.querySelector('.alarm-modal-ov')?.remove();

  let habitBtns = '';
  if (hi) {
    const {key,config:cfg}=hi;
    if (cfg.type==='incremental') habitBtns=`<button class="btn btn-green aa" data-key="${key}" data-val="${cfg.increment}" style="flex:1">âœ“ Done</button>`;
    else habitBtns=cfg.choices.map(c=>`<button class="btn btn-green aa" data-key="${key}" data-val="${c.value}" style="flex:1">${c.label}</button>`).join('');
  }
  const failOpt=hi?.config?.type==='choice'&&hi?.config?.messages?.failed;
  const dismissBtn=failOpt
    ?`<button class="btn btn-red ad" data-key="${hi.key}" data-fail="1" style="flex:1">âœ• Failed</button>`
    :`<button class="btn btn-ghost ad" style="flex:1">Dismiss</button>`;

  // Badge indicating type
  const typeBadge = item.blockType === 'scheduled'
    ? `<div style="display:inline-flex;align-items:center;gap:4px;padding:3px 9px;background:rgba(74,158,255,.1);border:1px solid rgba(74,158,255,.3);border-radius:20px;font-size:10px;font-family:var(--font-mono);color:#4a9eff;margin-bottom:10px">ðŸ“… Scheduled</div>`
    : `<div style="display:inline-flex;align-items:center;gap:4px;padding:3px 9px;background:rgba(0,255,136,.08);border:1px solid rgba(0,255,136,.25);border-radius:20px;font-size:10px;font-family:var(--font-mono);color:var(--accent);margin-bottom:10px">ðŸ” Daily Routine</div>`;

  const ov=document.createElement('div'); ov.className='modal-overlay center alarm-modal-ov';
  ov.innerHTML=`<div class="modal cm-modal" style="max-width:340px;width:calc(100% - 32px)">
    <div style="text-align:center;font-size:11px;font-family:var(--font-mono);color:var(--accent);margin-bottom:10px;letter-spacing:1.5px;text-transform:uppercase">â° Time for Activity</div>
    <div style="text-align:center">${typeBadge}</div>
    <div class="alarm-activity">${item.activity}</div>
    <div class="alarm-time">${item.time}</div>
    <div style="display:flex;gap:8px;margin-bottom:10px;flex-wrap:wrap">${habitBtns}${dismissBtn}</div>
    <div style="display:flex;gap:8px">
      ${snOpts.map(m=>`<button class="btn btn-ghost as" data-idx="${idx}" data-min="${m}" style="flex:1;font-size:12px;min-height:40px;padding:8px">â° +${m}m</button>`).join('')}
    </div>
  </div>`;
  document.body.appendChild(ov);
  const close=()=>{ ov.remove(); renderCountdown(); };
  ov.addEventListener('click',e=>{ if(e.target===ov) close(); });
  ov.querySelectorAll('.aa').forEach(b=>b.addEventListener('click',()=>{ updateHabit(b.dataset.key,parseInt(b.dataset.val)); S.evaluatedAlarms[idx]=true; close(); }));
  ov.querySelectorAll('.ad').forEach(b=>b.addEventListener('click',()=>{ if(b.dataset.fail&&b.dataset.key){ updateHabit(b.dataset.key,0); S.evaluatedAlarms[idx]=true; } close(); }));
  ov.querySelectorAll('.as').forEach(b=>b.addEventListener('click',()=>{ S.snooze[parseInt(b.dataset.idx)]=Date.now()+parseInt(b.dataset.min)*60000; showToast(`Snoozed ${b.dataset.min}m`); close(); }));
}

function playBeep() {
  try {
    const ctx=new (window.AudioContext||window.webkitAudioContext)();
    const osc=ctx.createOscillator(), g=ctx.createGain();
    osc.connect(g); g.connect(ctx.destination);
    osc.frequency.setValueAtTime(880,ctx.currentTime);
    osc.frequency.setValueAtTime(660,ctx.currentTime+0.1);
    g.gain.setValueAtTime(0.3,ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001,ctx.currentTime+0.4);
    osc.start(); osc.stop(ctx.currentTime+0.4);
  } catch{}
}

// â”€â”€ RENDER â€” COUNTDOWN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderCountdown() {
  const left = document.getElementById('countdown-left'); if (!left) return;
  const todaySched = getTodaySchedule();
  if (!todaySched.length) {
    left.innerHTML = `<div class="cw"><div class="empty-state" style="padding:8px 0;font-size:13px">No schedule today</div></div>`;
    return;
  }

  // â”€â”€ Snooze check â”€â”€
  for (const idx in S.snooze) {
    const until = S.snooze[idx];
    if (until > Date.now()) {
      const item = todaySched[parseInt(idx)];
      left.innerHTML = `<div class="cw"><span class="snoozed-badge">ðŸ”• Snoozed</span>
        <div class="ca" style="margin-top:8px">${item?.activity||''}</div>
        <div class="cm"><span class="cl">Resumes ${new Date(until).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}</span>
        <span class="ct" id="snooze-timer">${fmtMs(until-Date.now())}</span></div></div>`;
      return;
    }
  }

  // â”€â”€ Before first task: silent wait (no countdown shown yet) â”€â”€
  if (isBeforeFirstTask()) {
    const first = todaySched[0];
    const rem = schedDate(first.time) - Date.now();
    left.innerHTML = `<div class="cw">
      <div class="ca" style="font-size:13px;color:var(--muted)">Day starts soon</div>
      <div class="cm"><span class="cl">First: ${first.time}</span><span class="ct${rem<300000?' urgent':''}" id="main-timer">${fmtMs(rem)}</span></div>
    </div>`;
    return;
  }

  // â”€â”€ After last task ends: all done â”€â”€
  if (isPastLastTask()) {
    const last = todaySched[todaySched.length - 1];
    left.innerHTML = `<div class="cw">
      <div style="font-size:13px;color:var(--accent);font-family:var(--font-mono)">âœ… All tasks done for today!</div>
      <div style="font-size:11px;font-family:var(--font-mono);color:var(--muted);margin-top:4px">Last: ${last.activity}</div>
    </div>`;
    return;
  }

  const {cur, next} = getCurNext();

  // â”€â”€ Inside a running task â”€â”€
  if (isInsideTask(todaySched, cur)) {
    const ci = todaySched[cur];
    const taskStart = schedDate(ci.time);

    if (next === -1) {
      // Last task â€” use explicit duration to determine end
      const taskEnd = new Date(taskStart.getTime() + (ci.duration || 30) * 60000);
      const rem     = taskEnd - Date.now();
      const dur     = (ci.duration || 30) * 60000;
      left.innerHTML = `<div class="cw"><div class="ca" style="font-size:14px">${ci.activity}</div>
        <div class="cm"><span class="cl">Remaining Time:</span><span class="ct active${rem<60000?' urgent':''}" id="main-timer">${fmtMs(rem)}</span></div>
        <div class="pb-wrap"><div class="pb-fill" id="prog-bar" style="width:${Math.max(0,Math.min(100,100-(rem/dur)*100))}%"></div></div></div>`;
    } else {
      const ni      = todaySched[next];
      const dur     = (ci.duration || 30) * 60000;
      const taskEnd = new Date(taskStart.getTime() + dur);
      const rem     = taskEnd - Date.now();
      const pct     = Math.max(0, Math.min(100, 100 - (rem / dur * 100)));
      left.innerHTML = `<div class="cw"><div class="ca" style="font-size:14px">${ci.activity}</div>
        <div class="cm"><span class="cl">Remaining Time:</span><span class="ct active${rem<60000?' urgent':''}" id="main-timer">${fmtMs(rem)}</span></div>
        <div class="pb-wrap"><div class="pb-fill" id="prog-bar" style="width:${pct}%"></div></div>
        <div style="font-size:11px;font-family:var(--font-mono);color:var(--muted);margin-top:6px">Next: ${ni.activity} at ${ni.time}</div>
        </div>`;
    }
    return;
  }

  // â”€â”€ In a gap between tasks (cur task ended, next hasn't started) â”€â”€
  if (next !== -1) {
    const ni  = todaySched[next];
    const rem = schedDate(ni.time) - Date.now();
    const ci  = cur >= 0 ? todaySched[cur] : null;
    left.innerHTML = `<div class="cw">
      ${ci ? `<div style="font-size:11px;font-family:var(--font-mono);color:var(--muted)">âœ“ ${ci.activity}</div>` : ''}
      <div class="ca" style="font-size:14px;margin-top:${ci?'6px':'0'}">Up next: ${ni.activity}</div>
      <div class="cm"><span class="cl">Starts In</span><span class="ct${rem<60000?' urgent':''}" id="main-timer">${fmtMs(rem)}</span></div>
      <div class="pb-wrap"><div class="pb-fill" id="prog-bar" style="width:0%"></div></div>
    </div>`;
    return;
  }

  // Fallback
  left.innerHTML = `<div class="cw"><div style="font-size:13px;color:var(--accent);font-family:var(--font-mono)">âœ… All tasks done for today!</div></div>`;
}

// â”€â”€ RENDER â€” EVENT PANEL (right side of Now card) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _cachedTodayEvents = null;
let _eventPanelTick = null;

async function renderEventPanel() {
  const panel = document.getElementById('countdown-event'); if (!panel) return;
  const today = new Date().toISOString().slice(0,10);

  if (!S.eventsDirHandle) {
    panel.innerHTML = `<div style="font-size:9px;font-family:var(--font-mono);color:var(--muted);letter-spacing:.5px;text-align:center;line-height:1.6;opacity:.6">No events<br>folder set</div>`;
    return;
  }

  // Load (or use cache) - reload once per render cycle
  if (!_cachedTodayEvents) {
    const all = await loadEvents();
    _cachedTodayEvents = all.filter(e => e.date === today).sort((a,b) => (a.time||'99:99').localeCompare(b.time||'99:99'));
    // expire cache after 60s
    setTimeout(() => { _cachedTodayEvents = null; }, 60000);
  }

  const evs = _cachedTodayEvents;
  if (!evs.length) {
    panel.innerHTML = `<div style="font-size:9px;font-family:var(--font-mono);color:var(--muted);text-align:center;opacity:.5">No events<br>today</div>
      <button onclick="showAddEventSheet(null,()=>{_cachedTodayEvents=null;renderEventPanel();})" style="margin-top:6px;padding:3px 8px;background:rgba(0,255,136,.08);border:1px solid rgba(0,255,136,.2);border-radius:8px;color:var(--accent);font-size:10px;font-family:var(--font-mono);cursor:pointer">ï¼‹ add</button>`;
    return;
  }

  // Show nearest upcoming event (or latest if all past)
  const now = new Date();
  let ev = evs.find(e => {
    if (!e.time) return false;
    const [h,m] = e.time.split(':').map(Number);
    const d = new Date(); d.setHours(h,m,0,0);
    return d > now;
  }) || evs[0];

  let countdown = '';
  let countdownMs = 0;
  if (ev.time) {
    const [h,m] = ev.time.split(':').map(Number);
    const d = new Date(); d.setHours(h,m,0,0);
    countdownMs = d - now;
    if (countdownMs > 0) countdown = fmtMs(countdownMs);
    else countdown = 'Now';
  }

  const upnext = evs.length > 1 ? evs.find(e => e !== ev) : null;
  panel.innerHTML = `
    <div style="font-size:9px;font-family:var(--font-mono);color:var(--muted);text-transform:uppercase;letter-spacing:1px;margin-bottom:2px">ðŸ“… Event</div>
    <div style="font-size:11px;font-weight:700;color:var(--text);line-height:1.3;overflow:hidden;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical">${ev.title}</div>
    ${ev.time ? `<div style="font-size:10px;font-family:var(--font-mono);color:var(--accent);margin-top:2px">${ev.time}</div>` : ''}
    ${countdown ? `<div id="ev-panel-timer" style="font-size:13px;font-family:var(--font-mono);font-weight:800;color:${countdownMs > 0 ? 'var(--warn)' : 'var(--accent)'};margin-top:4px;letter-spacing:-.5px">${countdown}</div>` : ''}
    ${upnext ? `<div style="margin-top:6px;padding-top:6px;border-top:1px solid var(--border);font-size:9px;font-family:var(--font-mono);color:var(--muted);line-height:1.4;width:100%"><span style="opacity:.6">Up next:</span><br><span style="color:var(--text)">${upnext.title}</span></div>` : ''}
    <button onclick="showAddEventSheet(null,()=>{_cachedTodayEvents=null;renderEventPanel();})" style="margin-top:8px;padding:2px 8px;background:rgba(0,255,136,.06);border:1px solid rgba(0,255,136,.15);border-radius:6px;color:var(--accent);font-size:9px;font-family:var(--font-mono);cursor:pointer">ï¼‹</button>`;

  // Tick the event countdown
  if (_eventPanelTick) clearInterval(_eventPanelTick);
  if (countdownMs > 0) {
    _eventPanelTick = setInterval(() => {
      const t = document.getElementById('ev-panel-timer'); if (!t) { clearInterval(_eventPanelTick); return; }
      const [h2,m2] = ev.time.split(':').map(Number);
      const d2 = new Date(); d2.setHours(h2,m2,0,0);
      const rem2 = d2 - new Date();
      if (rem2 <= 0) { t.textContent = 'Now'; clearInterval(_eventPanelTick); return; }
      t.textContent = fmtMs(rem2);
    }, 1000);
  }
}

function tickCountdown() {
  const snEl = document.getElementById('snooze-timer');
  const todaySched = getTodaySchedule();

  // Snooze tick
  if (snEl) {
    for (const idx in S.snooze) { if (S.snooze[idx] > Date.now()) { snEl.textContent = fmtMs(S.snooze[idx]-Date.now()); return; } }
    renderCountdown(); return;
  }

  const tEl = document.getElementById('main-timer'); if (!tEl) return;

  // Re-render when we cross a boundary (before-first, after-last, task-start/end)
  if (isBeforeFirstTask() || isPastLastTask()) { renderCountdown(); return; }

  const {cur, next} = getCurNext();

  // Inside a running task: count down to task end
  if (isInsideTask(todaySched, cur)) {
    const ci       = todaySched[cur];
    const taskEnd  = new Date(schedDate(ci.time).getTime() + (ci.duration||30)*60000);
    const rem      = taskEnd - Date.now();
    if (rem <= 0) { renderCountdown(); return; }
    tEl.textContent = fmtMs(rem);
    rem < 60000 ? tEl.classList.add('urgent') : tEl.classList.remove('urgent');
    const prog = document.getElementById('prog-bar');
    if (prog) {
      const total = (ci.duration||30)*60000;
      prog.style.width = Math.max(0, Math.min(100, 100-((taskEnd-Date.now())/total*100))) + '%';
    }
    return;
  }

  // In a gap: count down to next task start
  if (next !== -1) {
    const rem = schedDate(todaySched[next].time) - Date.now();
    if (rem <= 0) { renderCountdown(); return; }
    tEl.textContent = fmtMs(rem);
    rem < 60000 ? tEl.classList.add('urgent') : tEl.classList.remove('urgent');
    return;
  }

  renderCountdown();
}

// â”€â”€ POMODORO ENGINE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const POMO = {
  active: false,
  loop: false,
  autoCalc: true,  // Auto-calculate available focus time
  phase: 'work',      // 'work' | 'break'
  workMins: 25,
  breakMins: 5,
  endTime: null,
  _interval: null,
};

function pomoGetSettings() {
  const s = LS.get('pomoSettings');
  return s || { workMins: 25, breakMins: 5, focusMaxMins: 60, breakMaxMins: 15 };
}

function pomoStart(phase) {
  const cfg = pomoGetSettings();
  POMO.workMins = cfg.workMins;
  POMO.breakMins = cfg.breakMins;
  POMO.phase = phase || 'work';
  POMO.active = true;
  const dur = (POMO.phase === 'work' ? POMO.workMins : POMO.breakMins) * 60000;
  POMO.endTime = Date.now() + dur;
  clearInterval(POMO._interval);
  POMO._interval = setInterval(pomoTick, 500);
  pomoUpdateBtn();

  // Schedule SW notification
  if (S.notifPermission === 'granted' && navigator.serviceWorker?.controller) {
    navigator.serviceWorker.controller.postMessage({
      type: 'SCHEDULE_ALARM',
      title: POMO.phase === 'work' ? 'ðŸ… Pomodoro done! Time for a break.' : 'â° Break over! Back to work.',
      body: POMO.loop ? 'Tap Stop to end, or Dismiss to continue' : 'Tap Loop to continue or Dismiss',
      tag: 'pomo-alarm',
      delay: dur,
      actions: POMO.loop
        ? [{ action: 'pomo-stop', title: 'Stop' }, { action: 'dismiss', title: 'Dismiss' }]
        : [{ action: 'pomo-loop', title: 'ðŸ” Loop' }, { action: 'dismiss', title: 'Dismiss' }]
    });
  }
}

function pomoStop() {
  POMO.active = false;
  POMO.endTime = null;
  clearInterval(POMO._interval);
  POMO._interval = null;
  pomoUpdateBtn();
}

function pomoTick() {
  if (!POMO.active || !POMO.endTime) return;
  const rem = POMO.endTime - Date.now();
  if (rem <= 0) {
    // Phase ended
    if (POMO.loop) {
      // Auto-advance to next phase
      pomoStart(POMO.phase === 'work' ? 'break' : 'work');
    } else {
      pomoStop();
    }
    return;
  }
  // Update ring in dashboard if visible
  const ring = document.getElementById('pomo-ring-label');
  const arc  = document.getElementById('pomo-arc');
  if (ring) {
    ring.textContent = fmtMs(rem);
    const total = (POMO.phase === 'work' ? POMO.workMins : POMO.breakMins) * 60000;
    const pct = 1 - rem / total;
    if (arc) {
      const r = 26, circ = 2 * Math.PI * r;
      arc.setAttribute('stroke-dashoffset', circ * (1 - pct));
    }
  }
  pomoUpdateBtn();
}

function pomoUpdateBtn() {
  const buttons = [document.getElementById('pomo-btn'), document.getElementById('pomo-btn-header')].filter(Boolean);
  if (!buttons.length) return;
  const btn = buttons[0];
  buttons.forEach(b => b.classList.toggle('active', POMO.active));
  // If timer is running, show ring; else show dot
  const svgInner = POMO.active && POMO.endTime ? (() => {
    const rem = POMO.endTime - Date.now();
    const total = (POMO.phase === 'work' ? POMO.workMins : POMO.breakMins) * 60000;
    const pct = 1 - rem / total;
    const r = 8, circ = 2 * Math.PI * r;
    return `<svg width="22" height="22" viewBox="0 0 22 22">
      <circle cx="11" cy="11" r="${r}" fill="none" stroke="var(--border)" stroke-width="2.5"/>
      <circle cx="11" cy="11" r="${r}" fill="none" stroke="var(--accent)" stroke-width="2.5"
        stroke-dasharray="${circ}" stroke-dashoffset="${circ*(1-pct)}" transform="rotate(-90 11 11)"
        style="transition:stroke-dashoffset .5s linear"/>
    </svg>`;
  })() : '<div class="pomo-dot"></div>';
  buttons.forEach(b => { b.innerHTML = svgInner; });
}

function showPomoPopup() {
  const existing = document.getElementById('pomo-popup');
  if (existing) { existing.remove(); return; }

  const cfg = pomoGetSettings();
  const ov = document.createElement('div'); ov.className = 'modal-overlay'; ov.id = 'pomo-popup';

  const R = 44, circ = 2 * Math.PI * R;
  const focusMax = Math.max(1, cfg.focusMaxMins || 60);
  const breakMax = Math.max(1, cfg.breakMaxMins || 15);
  const focusMinsArr = Array.from({length: focusMax}, (_,i) => String(i+1).padStart(2,'0'));
  const breakMinsArr = Array.from({length: breakMax}, (_,i) => String(i+1).padStart(2,'0'));

  function fmtMmSs(ms) {
    const s = Math.max(0, Math.floor(ms / 1000));
    return String(Math.floor(s/60)).padStart(2,'0') + ':' + String(s%60).padStart(2,'0');
  }

  // Decide initial ring values
  const initFocusMins = Math.min(cfg.workMins, focusMax);
  const initBreakMins = Math.min(cfg.breakMins, breakMax);

  ov.innerHTML = `<div class="modal" style="max-width:300px">
    <div class="modal-handle"></div>
    <div style="text-align:center;font-size:16px;font-weight:800;margin-bottom:16px">â–¶ Focus</div>

    <!-- Dual rings: Focus + Break side by side -->
    <div style="display:flex;justify-content:center;gap:16px;margin-bottom:20px;align-items:center">

      <!-- Focus ring -->
      <div style="display:flex;flex-direction:column;align-items:center;gap:6px">
        <div id="pomo-focus-ring" style="position:relative;width:110px;height:110px;flex-shrink:0;cursor:pointer" title="Tap to set focus time">
          <svg width="110" height="110" viewBox="0 0 110 110" style="position:absolute;inset:0;transform:rotate(-90deg)">
            <circle cx="55" cy="55" r="${R}" fill="none" stroke="var(--border)" stroke-width="5"/>
            <circle id="pomo-focus-arc" cx="55" cy="55" r="${R}" fill="none"
              stroke="var(--accent)" stroke-width="5"
              stroke-dasharray="${circ}" stroke-dashoffset="${circ}"
              stroke-linecap="round" style="transition:stroke-dashoffset .5s linear"/>
          </svg>
          <div style="position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:2px">
            <span id="pomo-focus-time" style="font-size:22px;font-family:var(--font-mono);font-weight:800;color:var(--accent);line-height:1;letter-spacing:-1px">${String(initFocusMins).padStart(2,'0')}:00</span>
            <span id="pomo-focus-phase" style="font-size:8px;font-family:var(--font-mono);color:var(--muted);text-transform:uppercase;letter-spacing:1px">Focus</span>
          </div>
        </div>
        <div style="font-size:9px;font-family:var(--font-mono);color:var(--muted);text-transform:uppercase;letter-spacing:1px;display:flex;align-items:center;gap:4px">
          <span style="width:6px;height:6px;border-radius:50%;background:var(--accent);display:inline-block"></span>Focus
        </div>
      </div>

      <!-- Break ring -->
      <div style="display:flex;flex-direction:column;align-items:center;gap:6px">
        <div id="pomo-break-ring" style="position:relative;width:110px;height:110px;flex-shrink:0;cursor:pointer" title="Tap to set break time">
          <svg width="110" height="110" viewBox="0 0 110 110" style="position:absolute;inset:0;transform:rotate(-90deg)">
            <circle cx="55" cy="55" r="${R}" fill="none" stroke="var(--border)" stroke-width="5"/>
            <circle id="pomo-break-arc" cx="55" cy="55" r="${R}" fill="none"
              stroke="var(--warn)" stroke-width="5"
              stroke-dasharray="${circ}" stroke-dashoffset="${circ}"
              stroke-linecap="round" style="transition:stroke-dashoffset .5s linear"/>
          </svg>
          <div style="position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:2px">
            <span id="pomo-break-time" style="font-size:22px;font-family:var(--font-mono);font-weight:800;color:var(--warn);line-height:1;letter-spacing:-1px">${String(initBreakMins).padStart(2,'0')}:00</span>
            <span id="pomo-break-phase" style="font-size:8px;font-family:var(--font-mono);color:var(--muted);text-transform:uppercase;letter-spacing:1px">Break</span>
          </div>
        </div>
        <div style="font-size:9px;font-family:var(--font-mono);color:var(--muted);text-transform:uppercase;letter-spacing:1px;display:flex;align-items:center;gap:4px">
          <span style="width:6px;height:6px;border-radius:50%;background:var(--warn);display:inline-block"></span>Break
        </div>
      </div>
    </div>

    <!-- Loop toggle -->
    <div style="display:flex;align-items:center;gap:10px;margin-bottom:10px;padding:10px 14px;background:var(--bg3);border-radius:10px;border:1px solid var(--border)">
      <span style="font-size:13px">ðŸ”</span>
      <span style="font-size:12px;font-family:var(--font-mono);color:var(--muted);flex:1">Loop</span>
      <div id="pomo-loop-track" style="width:44px;height:24px;border-radius:12px;cursor:pointer;transition:background .2s;position:relative;background:${POMO.loop?'var(--accent)':'rgba(255,255,255,.1)'}">
        <div id="pomo-loop-knob" style="width:20px;height:20px;border-radius:50%;background:white;position:absolute;top:2px;transition:left .2s;left:${POMO.loop?'22px':'2px'}"></div>
      </div>
    </div>

    <!-- Auto Calculate toggle -->
    <div style="display:flex;align-items:center;gap:10px;margin-bottom:16px;padding:10px 14px;background:var(--bg3);border-radius:10px;border:1px solid var(--border)">
      <span style="font-size:13px">âš¡</span>
      <div style="flex:1">
        <div style="font-size:12px;font-family:var(--font-mono);color:var(--muted)">Auto Calculate</div>
        <div id="pomo-auto-range-label" style="font-size:9px;font-family:var(--font-mono);color:var(--accent);margin-top:1px"></div>
      </div>
      <div id="pomo-auto-track" style="width:44px;height:24px;border-radius:12px;cursor:pointer;transition:background .2s;position:relative;background:${POMO.autoCalc!==false?'var(--accent)':'rgba(255,255,255,.1)'}">
        <div id="pomo-auto-knob" style="width:20px;height:20px;border-radius:50%;background:white;position:absolute;top:2px;transition:left .2s;left:${POMO.autoCalc!==false?'22px':'2px'}"></div>
      </div>
    </div>

    <!-- Start/Stop button -->
    <button id="pomo-main-btn" class="btn btn-green" style="width:100%">â–¶ Start</button>
  </div>`;
  document.body.appendChild(ov);

  const focusArcEl  = ov.querySelector('#pomo-focus-arc');
  const breakArcEl  = ov.querySelector('#pomo-break-arc');
  const focusTimeEl = ov.querySelector('#pomo-focus-time');
  const breakTimeEl = ov.querySelector('#pomo-break-time');
  const focusPhaseEl = ov.querySelector('#pomo-focus-phase');
  const breakPhaseEl = ov.querySelector('#pomo-break-phase');
  const mainBtn     = ov.querySelector('#pomo-main-btn');
  const focusRingEl = ov.querySelector('#pomo-focus-ring');
  const breakRingEl = ov.querySelector('#pomo-break-ring');

  // â”€â”€ Drum state (in-memory, not DOM drums) â”€â”€
  let focusSel = initFocusMins;  // current selected minutes
  let breakSel = initBreakMins;

  // â”€â”€ Show drum picker sheet â”€â”€
  function showDrumPicker(type) {
    // type: 'focus' | 'break'
    const isFocus = type === 'focus';
    const items   = isFocus ? focusMinsArr : breakMinsArr;
    const initVal = isFocus ? focusSel : breakSel;
    const color   = isFocus ? 'var(--accent)' : 'var(--warn)';
    const label   = isFocus ? 'Focus Time' : 'Break Time';

    const sheet = document.createElement('div');
    sheet.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,.72);z-index:600;display:flex;align-items:flex-end;justify-content:center;backdrop-filter:blur(4px)';
    sheet.innerHTML = `<div style="background:var(--bg2);border-radius:20px 20px 0 0;width:100%;max-width:360px;padding:20px 20px calc(24px + env(safe-area-inset-bottom,0px))">
      <div style="width:40px;height:4px;background:var(--border);border-radius:2px;margin:0 auto 16px"></div>
      <div style="text-align:center;font-size:14px;font-weight:800;margin-bottom:16px;color:${color}">${label}</div>
      <div id="drum-picker-wrap" style="width:120px;margin:0 auto 20px"></div>
      <div style="display:flex;gap:10px">
        <button id="drum-cancel" class="btn btn-ghost" style="flex:1">Cancel</button>
        <button id="drum-set" class="btn btn-green" style="flex:2;background:${color};color:var(--bg)">Set</button>
      </div>
    </div>`;
    document.body.appendChild(sheet);

    const drum = buildTimeDrum_simple(sheet.querySelector('#drum-picker-wrap'), items, items.indexOf(String(initVal).padStart(2,'0')));

    sheet.querySelector('#drum-cancel').addEventListener('click', () => sheet.remove());
    sheet.addEventListener('click', e => { if (e.target === sheet) sheet.remove(); });
    sheet.querySelector('#drum-set').addEventListener('click', () => {
      const val = parseInt(drum.getSelected());
      if (isFocus) {
        focusSel = val;
        const s = pomoGetSettings();
        LS.set('pomoSettings', { ...s, workMins: val });
        // Snap auto-calc if needed
        if (POMO.autoCalc !== false) {
          const free = getAutoFocusMins();
          if (free > 0) focusSel = Math.min(val, free);
        }
      } else {
        breakSel = val;
        const s = pomoGetSettings();
        LS.set('pomoSettings', { ...s, breakMins: val });
      }
      updateDisplay();
      sheet.remove();
    });
  }

  // â”€â”€ Ring click â†’ open drum picker â”€â”€
  focusRingEl.addEventListener('click', e => {
    e.stopPropagation();
    if (!POMO.active) showDrumPicker('focus');
  });
  breakRingEl.addEventListener('click', e => {
    e.stopPropagation();
    if (!POMO.active) showDrumPicker('break');
    else if (POMO.active && POMO.phase === 'break') showDrumPicker('break'); // allow changing break during break
  });

  // â”€â”€ Loop toggle â”€â”€
  const track = ov.querySelector('#pomo-loop-track');
  const knob  = ov.querySelector('#pomo-loop-knob');
  track.addEventListener('click', () => {
    POMO.loop = !POMO.loop;
    track.style.background = POMO.loop ? 'var(--accent)' : 'rgba(255,255,255,.1)';
    knob.style.left = POMO.loop ? '22px' : '2px';
  });

  // â”€â”€ Auto Calculate toggle â”€â”€
  const autoTrack = ov.querySelector('#pomo-auto-track');
  const autoKnob  = ov.querySelector('#pomo-auto-knob');
  const autoLabel = ov.querySelector('#pomo-auto-range-label');

  function getAutoFocusMins() {
    // Returns:
    //  -1 = outside schedule window (before first task OR after last task ends)
    //   0 = currently inside a running task (no free time)
    //   N = free minutes until the next task starts (gap between tasks)
    const now = new Date();
    const allToday = getTodaySchedule()
      .filter(it => it.time && it.blockType !== 'open')
      .sort((a,b) => { try{return schedDate(a.time)-schedDate(b.time);}catch{return 0;} });

    if (!allToday.length) return -1;

    const firstTask = allToday[0];
    const lastTask  = allToday[allToday.length - 1];
    const firstTime = schedDate(firstTask.time);

    // Last task ends at its start time + duration (default 30 min if not set)
    const lastTaskDur = (lastTask.duration || 30) * 60000;
    const lastEndTime = new Date(schedDate(lastTask.time).getTime() + lastTaskDur);

    // Outside window: before first task starts or after last task ends
    if (now < firstTime) return -1;
    if (now >= lastEndTime) return -1;

    // Find which task slot "now" falls inside (start to start+duration)
    for (let i = 0; i < allToday.length; i++) {
      const taskStart = schedDate(allToday[i].time);
      const taskDur   = (allToday[i].duration || 30) * 60000;
      const taskEnd   = new Date(taskStart.getTime() + taskDur);

      if (now >= taskStart && now < taskEnd) {
        // We are inside task i â€” no free time right now
        return 0;
      }

      // We are in the gap after task i ends â€” check if next task exists
      if (now >= taskEnd) {
        const nextTask = allToday[i + 1];
        if (nextTask) {
          const nextStart = schedDate(nextTask.time);
          if (now < nextStart) {
            // In the gap between task i end and task i+1 start
            return Math.max(0, Math.floor((nextStart - now) / 60000));
          }
          // now >= nextStart means we've moved into the next task iteration
        }
      }
    }

    return -1;
  }

  function updateAutoLabel() {
    if (!autoLabel) return;
    if (POMO.autoCalc !== false) {
      const freeMins = getAutoFocusMins();
      if (freeMins === -1) {
        autoLabel.textContent = 'âœ¨ All activities done for today';
        autoLabel.style.color = 'var(--accent)';
      } else if (freeMins === 0) {
        autoLabel.textContent = 'On task â€” no free time now';
        autoLabel.style.color = 'var(--danger)';
      } else {
        autoLabel.textContent = `Free: ${freeMins} min`;
        autoLabel.style.color = 'var(--accent)';
      }
    } else {
      autoLabel.textContent = '';
    }
  }

  autoTrack.addEventListener('click', () => {
    POMO.autoCalc = POMO.autoCalc === false ? true : false;
    autoTrack.style.background = POMO.autoCalc !== false ? 'var(--accent)' : 'rgba(255,255,255,.1)';
    autoKnob.style.left = POMO.autoCalc !== false ? '22px' : '2px';
    updateAutoLabel();
    if (POMO.autoCalc !== false && !POMO.active) {
      const freeMins = getAutoFocusMins();
      if (freeMins > 0) { focusSel = Math.min(focusSel, freeMins); updateDisplay(); }
    }
  });

  updateAutoLabel();

  // â”€â”€ Update both rings / time display â”€â”€
  function updateDisplay() {
    if (!POMO.active || !POMO.endTime) {
      // Idle: show selected drum values as preview
      let w = focusSel;
      if (POMO.autoCalc !== false) {
        const freeMins = getAutoFocusMins();
        if (freeMins > 0) w = Math.min(focusSel, freeMins);
      }
      const b = breakSel;

      // Focus ring â€” static (full empty ring)
      focusTimeEl.textContent = String(w).padStart(2,'0') + ':00';
      focusTimeEl.style.color = 'var(--accent)';
      focusPhaseEl.textContent = 'Focus';
      focusArcEl.setAttribute('stroke-dashoffset', String(circ));
      focusArcEl.setAttribute('stroke', 'var(--accent)');
      focusRingEl.style.opacity = '1';
      focusRingEl.title = 'Tap to set focus time';

      // Break ring â€” static
      breakTimeEl.textContent = String(b).padStart(2,'0') + ':00';
      breakTimeEl.style.color = 'var(--warn)';
      breakPhaseEl.textContent = 'Break';
      breakArcEl.setAttribute('stroke-dashoffset', String(circ));
      breakArcEl.setAttribute('stroke', 'var(--warn)');
      breakRingEl.style.opacity = POMO.loop ? '1' : '0.35';
      breakRingEl.title = POMO.loop ? 'Tap to set break time' : 'Enable Loop to use break';

      mainBtn.textContent = 'â–¶ Start';
      mainBtn.className = 'btn btn-green';
      mainBtn.style.width = '100%';
      mainBtn.style.color = '';
      updateAutoLabel();
      return;
    }

    // Active timer
    const rem = Math.max(0, POMO.endTime - Date.now());
    const isWork = POMO.phase === 'work';
    const total = (isWork ? POMO.workMins : POMO.breakMins) * 60000;
    const pct = 1 - rem / total;
    const col = isWork ? 'var(--accent)' : 'var(--warn)';

    if (isWork) {
      // Update focus ring as active
      focusArcEl.setAttribute('stroke-dashoffset', String(circ * (1 - pct)));
      focusArcEl.setAttribute('stroke', 'var(--accent)');
      focusTimeEl.textContent = fmtMmSs(rem);
      focusTimeEl.style.color = 'var(--accent)';
      focusPhaseEl.textContent = 'Focus';
      focusRingEl.style.opacity = '1';
      // Break ring dims
      breakArcEl.setAttribute('stroke-dashoffset', String(circ));
      breakTimeEl.textContent = String(breakSel).padStart(2,'0') + ':00';
      breakTimeEl.style.color = 'var(--warn)';
      breakRingEl.style.opacity = '0.35';
    } else {
      // Break phase â€” update break ring
      breakArcEl.setAttribute('stroke-dashoffset', String(circ * (1 - pct)));
      breakArcEl.setAttribute('stroke', 'var(--warn)');
      breakTimeEl.textContent = fmtMmSs(rem);
      breakTimeEl.style.color = 'var(--warn)';
      breakPhaseEl.textContent = 'Break';
      breakRingEl.style.opacity = '1';
      // Focus ring dims
      focusArcEl.setAttribute('stroke-dashoffset', String(circ));
      focusTimeEl.textContent = String(focusSel).padStart(2,'0') + ':00';
      focusTimeEl.style.color = 'var(--accent)';
      focusRingEl.style.opacity = '0.35';
    }

    mainBtn.textContent = 'â–  Stop';
    mainBtn.className = 'btn btn-ghost';
    mainBtn.style.width = '100%';
    mainBtn.style.color = 'var(--danger)';
  }

  // â”€â”€ Start/Stop button â”€â”€
  mainBtn.addEventListener('click', () => {
    if (POMO.active) {
      pomoStop();
      updateDisplay();
    } else {
      let w = focusSel;
      const b = breakSel;
      if (POMO.autoCalc !== false) {
        const freeMins = getAutoFocusMins();
        if (freeMins === 0) { showToast('â³ Currently on a task â€” no free time'); return; }
        if (freeMins > 0) { w = Math.min(w, freeMins); focusSel = w; }
      }
      const s = pomoGetSettings();
      LS.set('pomoSettings', { ...s, workMins: w, breakMins: b });
      POMO.workMins = w;
      POMO.breakMins = b;
      pomoStart('work');
      updateDisplay();
    }
  });

  ov.addEventListener('click', e => { if (e.target === ov) ov.remove(); });

  // Initial render
  updateDisplay();

  // â”€â”€ Live tick while popup is open â”€â”€
  const liveInterval = setInterval(() => {
    if (!document.body.contains(ov)) { clearInterval(liveInterval); return; }
    updateDisplay();
  }, 500);
}

// Minimal drum builder for pomodoro (no AM/PM, just a list of string values)
function buildTimeDrum_simple(container, items, initIdx) {
  if (!container) return null;
  const ITEM_H = 40, DRUM_H = 120, PAD = 1;
  const renderItems = [...items, ...items, ...items];
  const offset = items.length;

  // Build a drum div INSIDE the container rather than styling the container itself
  // This preserves any flex/width CSS already on the container element
  const drum = document.createElement('div');
  drum.style.cssText = 'position:relative;height:' + DRUM_H + 'px;overflow:hidden;border-radius:10px;background:var(--bg3);border:1px solid var(--border);cursor:grab;width:100%;touch-action:none';
  container.appendChild(drum);

  const highlight = document.createElement('div');
  highlight.style.cssText = `position:absolute;left:0;right:0;top:${(DRUM_H-ITEM_H)/2}px;height:${ITEM_H}px;background:rgba(0,255,136,.08);border-top:1px solid rgba(0,255,136,.2);border-bottom:1px solid rgba(0,255,136,.2);pointer-events:none;z-index:1`;
  drum.appendChild(highlight);

  const inner = document.createElement('div');
  inner.style.cssText = 'position:absolute;left:0;right:0;will-change:transform';

  for (let p = 0; p < PAD; p++) {
    const pad = document.createElement('div');
    pad.style.cssText = `height:${ITEM_H}px`;
    inner.appendChild(pad);
  }
  renderItems.forEach(val => {
    const el = document.createElement('div');
    el.style.cssText = `height:${ITEM_H}px;display:flex;align-items:center;justify-content:center;font-size:18px;font-family:var(--font-mono);font-weight:700;color:var(--muted);transition:color .1s,font-size .1s`;
    el.textContent = val;
    inner.appendChild(el);
  });
  for (let p = 0; p < PAD; p++) {
    const pad = document.createElement('div');
    pad.style.cssText = `height:${ITEM_H}px`;
    inner.appendChild(pad);
  }
  drum.appendChild(inner);

  let selected = Math.max(0, Math.min(items.length - 1, initIdx));
  let startY = 0, isDragging = false;

  function getRenderIdx() { return offset + selected; }
  function getY() { return (DRUM_H - ITEM_H) / 2 - (PAD + offset + selected) * ITEM_H; }

  function render(animate) {
    inner.style.transition = animate ? 'transform .18s cubic-bezier(.25,.8,.25,1)' : 'none';
    inner.style.transform = `translateY(${getY()}px)`;
    // Children: PAD pads + renderItems.length items + PAD pads
    // The selected item in the rendered list is at renderItems index (offset + selected)
    // which maps to child index PAD + (offset + selected)
    const selChildIdx = PAD + offset + selected;
    inner.querySelectorAll('div').forEach((el, i) => {
      const isSel = i === selChildIdx;
      el.style.color = isSel ? 'var(--accent)' : 'var(--muted)';
      el.style.fontSize = isSel ? '20px' : '16px';
    });
  }

  function moveTo(n) {
    selected = ((n % items.length) + items.length) % items.length;
    render(true);
  }

  drum.addEventListener('pointerdown', e => {
    isDragging = true; startY = e.clientY;
    inner.style.transition = 'none';
    drum.setPointerCapture(e.pointerId);
    e.stopPropagation(); // prevent overlay dismiss
  });
  drum.addEventListener('pointermove', e => {
    if (!isDragging) return;
    inner.style.transform = `translateY(${getY() + (e.clientY - startY)}px)`;
    e.stopPropagation();
  });
  drum.addEventListener('pointerup', e => {
    if (!isDragging) return;
    isDragging = false;
    moveTo(selected - Math.round((e.clientY - startY) / ITEM_H));
    e.stopPropagation();
  });
  drum.addEventListener('wheel', e => {
    e.preventDefault(); moveTo(selected + (e.deltaY > 0 ? 1 : -1));
  }, { passive: false });

  render(false);
  return { getSelected: () => items[selected], snapTo: (idx) => { selected = Math.max(0, Math.min(items.length-1, idx)); render(true); } };
}

// â”€â”€ RENDER HABIT BARS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderHabitBars() {
  const el = document.getElementById('card-habits'); if (!el) return;
  const body = el.querySelector('.card-body');
  const defs = S.config?.habitDefinitions;
  const editMode = !!S._habitEditMode;

  // Toggle done ledge
  const ledge = document.getElementById('habit-done-ledge');
  if (ledge) ledge.style.display = editMode ? 'block' : 'none';
  const pill = document.getElementById('habit-done-pill');
  if (pill) pill.style.display = editMode ? 'flex' : 'none';
  const editBtn = document.getElementById('habit-edit-btn');
  if (editBtn) { editBtn.textContent = 'âœŽ edit'; editBtn.style.color = editMode ? 'var(--accent)' : 'var(--muted)'; }

  if (!defs || !Object.keys(defs).length) {
    if (editMode) {
      const g = document.createElement('div'); g.className = 'habits-grid';
      const ac = document.createElement('div'); ac.className = 'habit-add-col';
      ac.innerHTML = `<div class="habit-add-btn">ï¼‹</div><div class="habit-add-label">add</div>`;
      ac.addEventListener('click', () => showAddHabitSheet());
      g.appendChild(ac); body.innerHTML = ''; body.appendChild(g);
    } else {
      body.innerHTML = `<div class="empty-state" style="padding:24px 16px;line-height:2">
        No habits configured<br>
        <span style="font-size:11px;font-family:var(--font-mono);color:var(--muted)">
          Tap <b style="color:var(--text)">âœŽ edit</b> to add habits, or connect your<br>
          habit tracker folder via <b style="color:var(--text)">âš™ Settings â†’ Habit Tracker Folder</b>
        </span>
      </div>`;
    }
    return;
  }

  const grid = document.createElement('div'); grid.className = 'habits-grid';

  for (const [key, cfg] of Object.entries(defs)) {
    const raw = S.habitData[key] || 0;
    const dv = cfg.type === 'choice' ? (raw > 0 ? 1 : 0) : raw;
    const mv = cfg.type === 'choice' ? 1 : (cfg.maxValue || 1);
    const complete = dv >= mv, pct = Math.max(2, (dv / mv) * 100);
    const col = document.createElement('div');
    col.className = 'habit-col'; col.dataset.key = key;

    if (editMode) {
      col.style.cssText = 'position:relative;width:56px;display:flex;flex-direction:column;align-items:center;gap:0;padding-top:6px';
      col.innerHTML = `
        <div style="position:relative;display:inline-block">
          <div style="font-size:30px;line-height:1;user-select:none;padding-bottom:4px">${cfg.icon}</div>
          <button class="habit-remove-btn-inline" data-key="${key}" style="position:absolute;top:-6px;right:-8px;width:18px;height:18px;border-radius:50%;background:var(--danger);border:none;color:#fff;font-size:11px;font-weight:900;cursor:pointer;display:flex;align-items:center;justify-content:center;line-height:1;z-index:2;padding:0">âœ•</button>
        </div>
        <button class="habit-edit-icon" data-key="${key}" style="width:56px;padding:3px 0;background:rgba(0,255,136,.13);border:1.5px solid rgba(0,255,136,.35);border-radius:8px;color:var(--accent);font-size:10px;font-family:var(--font-mono);font-weight:700;cursor:pointer;display:flex;align-items:center;justify-content:center;gap:3px">âœŽ edit</button>
        <div style="font-size:9px;font-family:var(--font-mono);color:var(--muted);text-align:center;max-width:56px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin-top:4px">${key}</div>`;
    } else {
      const isBoolHabit = cfg.type === 'incremental' && mv === 1 && (cfg.increment||1) === 1;
      const barPct = dv === 0 ? 0 : Math.max(4, (dv / mv) * 100);
      col.innerHTML = `
        <div class="habit-bar-track"><div class="habit-bar-fill${complete ? ' complete' : ''}" style="width:${barPct}%"></div></div>
        <div class="habit-icon${complete ? ' complete' : ''}" data-key="${key}">${cfg.icon}${complete ? `<span style="position:absolute;bottom:-1px;right:-1px;width:14px;height:14px;background:var(--accent);border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:8px;color:var(--bg);font-weight:900;border:1.5px solid var(--bg2)">âœ“</span>` : ''}</div>`;

      const iconEl = col.querySelector('.habit-icon');
      iconEl.addEventListener('click', () => {
        showManualModal(key);
      });

      // Double-tap â†’ jump to schedule
      let lastTap = 0;
      col.addEventListener('click', () => {
        const now = Date.now();
        if (now - lastTap < 350) {
          if (S._switchTab) S._switchTab(1);
          setTimeout(() => {
            document.getElementById('schedule-tab')?.querySelector('.sched-tab-item.current, .current')
              ?.scrollIntoView({ block: 'center', behavior: 'smooth' });
          }, 380);
        }
        lastTap = now;
      });
    }
    grid.appendChild(col);
  }

  // Add "+" in edit mode
  if (editMode) {
    const ac = document.createElement('div'); ac.className = 'habit-add-col';
    ac.innerHTML = `<div class="habit-add-btn" style="margin-top:6px;width:44px;height:44px">ï¼‹</div><div class="habit-add-label">add</div>`;
    ac.addEventListener('click', () => showAddHabitSheet());
    grid.appendChild(ac);
  }

  body.innerHTML = ''; body.appendChild(grid);

  // Wire remove buttons
  grid.querySelectorAll('.habit-remove-btn-inline').forEach(btn => {
    btn.addEventListener('click', e => {
      e.stopPropagation();
      const k = btn.dataset.key;
      if (!S.config?.habitDefinitions || !confirm(`Remove habit "${k}"?`)) return;
      delete S.config.habitDefinitions[k];
      LS.set('lastConfig', S.config);
      saveHabitDefinitionsToVault();
      renderHabitBars();
      showToast(`Removed ${k}`);
    });
  });

  // Wire edit icon click in edit mode
  grid.querySelectorAll('.habit-edit-icon').forEach(iconEl => {
    iconEl.addEventListener('click', e => {
      e.stopPropagation();
      showEditHabitSheet(iconEl.dataset.key);
    });
  });
}

// â”€â”€ EMOJI POP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showEmojiPop(emoji, anchorEl) {
  const r = anchorEl.getBoundingClientRect();
  const p = document.createElement('div');
  p.textContent = emoji;
  p.style.cssText = `position:fixed;left:${r.left+r.width/2}px;top:${r.top}px;font-size:32px;pointer-events:none;z-index:9999;transform:translate(-50%,0);animation:emojiPop .65s cubic-bezier(.34,1.56,.64,1) forwards`;
  document.body.appendChild(p);
  setTimeout(() => p.remove(), 700);
}

// â”€â”€ SAVE HABIT DEFINITIONS TO VAULT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Writes the habitDefinitions block back into the .md frontmatter
async function saveHabitDefinitionsToVault() {
  LS.set('lastConfig', S.config);
  LS.set('lastScheduleEdit', Date.now());
  if (!S.vaultDirHandle || !S.config) return;
  try {
    const searchDir = (await getDataDir()) || S.vaultDirHandle;
    for await (const entry of searchDir.values()) {
      if (entry.kind === 'file' && entry.name.endsWith('.md') && !entry.name.match(/^\d{16}HT\.md$/)) {
        const file = await entry.getFile();
        const originalText = await file.text();
        const newText = rebuildHabitDefsInMd(originalText, S.config.habitDefinitions || {});
        if (newText === null) continue;
        const fh = await searchDir.getFileHandle(entry.name, { create: false });
        const w = await fh.createWritable();
        await w.write(newText);
        await w.close();
        return;
      }
    }
  } catch(e) { console.warn('Habit def vault write failed:', e.message); }
}

// Rebuild habitDefinitions block inside .md frontmatter
function rebuildHabitDefsInMd(text, defs) {
  const fmMatch = text.match(/^(---\n)([\s\S]+?)(\n---)([\s\S]*)$/);
  if (!fmMatch) return null;
  const [, open, yaml, close, body] = fmMatch;

  // Build YAML for each habit def
  const defLines = ['habitDefinitions:'];
  for (const [key, cfg] of Object.entries(defs)) {
    defLines.push(`  ${key}:`);
    defLines.push(`    type: ${cfg.type || 'incremental'}`);
    defLines.push(`    icon: ${cfg.icon || 'â­'}`);
    if (cfg.type === 'incremental') {
      defLines.push(`    maxValue: ${cfg.maxValue || 1}`);
      defLines.push(`    increment: ${cfg.increment || 1}`);
      if (cfg.messages && Object.keys(cfg.messages).length) {
        defLines.push('    messages:');
        for (const [mk, mv] of Object.entries(cfg.messages)) defLines.push(`      ${mk}: '${mv}'`);
      }
    } else {
      if (cfg.messages?.failed) {
        defLines.push('    messages:');
        defLines.push(`      failed: '${cfg.messages.failed}'`);
      }
      if (cfg.choices?.length) {
        defLines.push('    choices:');
        cfg.choices.forEach(c => {
          defLines.push(`      - value: ${c.value}`);
          defLines.push(`        label: '${c.label}'`);
          if (c.message) defLines.push(`        message: '${c.message}'`);
        });
      }
    }
  }

  // Line-by-line replacement
  const lines = yaml.split('\n'); const out = []; let inBlock = false;
  for (const line of lines) {
    if (/^habitDefinitions:\s*$/.test(line)) { inBlock = true; out.push(...defLines); continue; }
    if (inBlock) { if (/^\s+/.test(line) || line.trim() === '') continue; inBlock = false; }
    out.push(line);
  }
  if (!out.some(l => l.startsWith('habitDefinitions:'))) out.push(...defLines);
  return open + out.join('\n') + close + body;
}

// â”€â”€ ADD HABIT SHEET â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showAddHabitSheet() {
  const existingKeys = Object.keys(S.config?.habitDefinitions || {}).map(k => k.toLowerCase());

  const ov = document.createElement('div'); ov.className = 'add-sched-modal';
  ov.innerHTML = `<div class="add-sched-sheet" style="max-height:88dvh;overflow-y:auto">
    <div class="modal-handle"></div>
    <div style="font-size:16px;font-weight:800;margin-bottom:16px">Add Habit</div>

    <div style="display:flex;gap:8px;margin-bottom:14px" id="ah-type-row">
      <button class="btn btn-green" id="ah-type-incr" style="flex:1;font-size:13px">â¬† Incremental</button>
      <button class="btn btn-ghost" id="ah-type-choice" style="flex:1;font-size:13px">â˜‘ Choice</button>
    </div>

    <input type="text" id="ah-key" placeholder="Habit key â€” e.g. water" autocomplete="off" spellcheck="false"/>
    <input type="text" id="ah-icon" placeholder="Emoji icon â€” e.g. ðŸ’§" autocomplete="off"/>

    <div id="ah-incr-fields">
      <input type="number" id="ah-max" placeholder="Daily goal â€” e.g. 8" min="1" max="200"/>
    </div>

    <div id="ah-choice-fields" style="display:none">
      <div style="font-size:11px;font-family:var(--font-mono);color:var(--muted);margin-bottom:8px">Add choices (at least 1):</div>
      <div id="ah-choices-list"></div>
      <button class="btn btn-ghost" id="ah-add-choice" style="width:100%;margin-bottom:10px;font-size:13px">ï¼‹ Add Choice</button>
    </div>

    <div style="display:flex;gap:10px;margin-top:6px">
      <button class="btn btn-ghost" id="ah-cancel" style="flex:1">Cancel</button>
      <button class="btn btn-green" id="ah-add" style="flex:2">ï¼‹ Add Habit</button>
    </div>
  </div>`;
  document.body.appendChild(ov);

  let habitType = 'incremental';
  const choicesList = ov.querySelector('#ah-choices-list');
  let choiceCount = 0;

  function addChoiceRow(label = '', value = '') {
    choiceCount++;
    const row = document.createElement('div');
    row.style.cssText = 'display:flex;gap:6px;align-items:center;margin-bottom:6px';
    row.dataset.choiceIdx = choiceCount;
    row.innerHTML = `
      <input type="text" placeholder="Label â€” e.g. Good" value="${label}" style="flex:2;margin-bottom:0" class="ah-ch-label"/>
      <input type="number" placeholder="Val" value="${value}" min="0" max="100" style="flex:1;margin-bottom:0;width:60px" class="ah-ch-val"/>
      <button style="width:28px;height:28px;border-radius:7px;border:1px solid rgba(255,68,102,.3);background:rgba(255,68,102,.08);color:var(--danger);font-size:13px;cursor:pointer;flex-shrink:0;display:flex;align-items:center;justify-content:center" class="ah-ch-del">âœ•</button>`;
    row.querySelector('.ah-ch-del').addEventListener('click', () => row.remove());
    // style inputs to match sheet
    row.querySelectorAll('input').forEach(i => {
      i.style.cssText += ';width:auto;background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:9px 10px;color:var(--text);font-family:var(--font-mono);font-size:13px;outline:none';
      i.addEventListener('focus', () => i.style.borderColor='var(--accent)');
      i.addEventListener('blur', () => i.style.borderColor='var(--border)');
    });
    choicesList.appendChild(row);
  }
  // Start with 2 default choices
  addChoiceRow('', 1);
  addChoiceRow('', 2);

  // Type switcher
  ov.querySelector('#ah-type-incr').addEventListener('click', () => {
    habitType = 'incremental';
    ov.querySelector('#ah-type-incr').className = 'btn btn-green'; ov.querySelector('#ah-type-incr').style.flex='1'; ov.querySelector('#ah-type-incr').style.fontSize='13px';
    ov.querySelector('#ah-type-choice').className = 'btn btn-ghost'; ov.querySelector('#ah-type-choice').style.flex='1'; ov.querySelector('#ah-type-choice').style.fontSize='13px';
    ov.querySelector('#ah-incr-fields').style.display = '';
    ov.querySelector('#ah-choice-fields').style.display = 'none';
  });
  ov.querySelector('#ah-type-choice').addEventListener('click', () => {
    habitType = 'choice';
    ov.querySelector('#ah-type-choice').className = 'btn btn-green'; ov.querySelector('#ah-type-choice').style.flex='1'; ov.querySelector('#ah-type-choice').style.fontSize='13px';
    ov.querySelector('#ah-type-incr').className = 'btn btn-ghost'; ov.querySelector('#ah-type-incr').style.flex='1'; ov.querySelector('#ah-type-incr').style.fontSize='13px';
    ov.querySelector('#ah-incr-fields').style.display = 'none';
    ov.querySelector('#ah-choice-fields').style.display = '';
  });

  ov.querySelector('#ah-add-choice').addEventListener('click', () => addChoiceRow());

  const close = () => document.body.removeChild(ov);
  ov.addEventListener('click', e => { if (e.target === ov) close(); });
  ov.querySelector('#ah-cancel').addEventListener('click', close);
  setTimeout(() => ov.querySelector('#ah-key').focus(), 100);

  ov.querySelector('#ah-add').addEventListener('click', () => {
    const rawKey = ov.querySelector('#ah-key').value.trim().replace(/\s+/g, '_');
    const icon = ov.querySelector('#ah-icon').value.trim() || 'â­';
    if (!rawKey) { showToast('Enter a habit name'); return; }

    // Duplicate check
    if (existingKeys.includes(rawKey.toLowerCase())) {
      showToast(`"${rawKey}" already exists`); return;
    }

    if (!S.config) S.config = { schedule: [], habitDefinitions: {}, habitTracker: { enabled: true, snoozeOptions: [5, 10] } };
    if (!S.config.habitDefinitions) S.config.habitDefinitions = {};

    if (habitType === 'incremental') {
      const maxVal = parseInt(ov.querySelector('#ah-max').value) || 1;
      S.config.habitDefinitions[rawKey] = { type: 'incremental', icon, maxValue: maxVal, increment: 1, messages: {} };
    } else {
      const rows = choicesList.querySelectorAll('[data-choice-idx]');
      const choices = [];
      let v = 0;
      rows.forEach(row => {
        const label = row.querySelector('.ah-ch-label').value.trim();
        const val = parseInt(row.querySelector('.ah-ch-val').value);
        if (label) { v++; choices.push({ value: isNaN(val) ? v : val, label }); }
      });
      if (!choices.length) { showToast('Add at least one choice'); return; }
      S.config.habitDefinitions[rawKey] = { type: 'choice', icon, choices, messages: {} };
    }

    LS.set('lastConfig', S.config);
    saveHabitDefinitionsToVault();
    close();
    renderHabitBars();
    showToast(`âœ“ ${rawKey} added`);
  });
}

// â”€â”€ EDIT HABIT SHEET â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showEditHabitSheet(key) {
  const existingCfg = S.config?.habitDefinitions?.[key]; if (!existingCfg) return;

  const ov = document.createElement('div'); ov.className = 'add-sched-modal';
  ov.innerHTML = `<div class="add-sched-sheet" style="max-height:88dvh;overflow-y:auto">
    <div class="modal-handle"></div>
    <div style="font-size:16px;font-weight:800;margin-bottom:16px">Edit Habit</div>

    <div style="display:flex;gap:8px;margin-bottom:14px" id="ah-type-row">
      <button class="btn ${existingCfg.type==='incremental'?'btn-green':'btn-ghost'}" id="ah-type-incr" style="flex:1;font-size:13px">â¬† Incremental</button>
      <button class="btn ${existingCfg.type==='choice'?'btn-green':'btn-ghost'}" id="ah-type-choice" style="flex:1;font-size:13px">â˜‘ Choice</button>
    </div>

    <input type="text" id="ah-key" placeholder="Habit key â€” e.g. water" value="${key}" autocomplete="off" spellcheck="false"/>
    <input type="text" id="ah-icon" placeholder="Emoji icon â€” e.g. ðŸ’§" value="${existingCfg.icon||'â­'}" autocomplete="off"/>

    <div id="ah-incr-fields" style="${existingCfg.type==='choice'?'display:none':''}">
      <input type="number" id="ah-max" placeholder="Daily goal â€” e.g. 8" min="1" max="200" value="${existingCfg.maxValue||''}"/>
    </div>

    <div id="ah-choice-fields" style="${existingCfg.type==='incremental'?'display:none':''}">
      <div style="font-size:11px;font-family:var(--font-mono);color:var(--muted);margin-bottom:8px">Choices:</div>
      <div id="ah-choices-list"></div>
      <button class="btn btn-ghost" id="ah-add-choice" style="width:100%;margin-bottom:10px;font-size:13px">ï¼‹ Add Choice</button>
    </div>

    <div style="display:flex;gap:10px;margin-top:6px">
      <button class="btn btn-ghost" id="ah-cancel" style="flex:1">Cancel</button>
      <button class="btn btn-green" id="ah-save" style="flex:2">âœ“ Save Changes</button>
    </div>
  </div>`;
  document.body.appendChild(ov);

  let habitType = existingCfg.type || 'incremental';
  const choicesList = ov.querySelector('#ah-choices-list');
  let choiceCount = 0;

  function addChoiceRow(label = '', value = '') {
    choiceCount++;
    const row = document.createElement('div');
    row.style.cssText = 'display:flex;gap:6px;align-items:center;margin-bottom:6px';
    row.dataset.choiceIdx = choiceCount;
    row.innerHTML = `
      <input type="text" placeholder="Label â€” e.g. Good" value="${label}" style="flex:2;margin-bottom:0" class="ah-ch-label"/>
      <input type="number" placeholder="Val" value="${value}" min="0" max="100" style="flex:1;margin-bottom:0;width:60px" class="ah-ch-val"/>
      <button style="width:28px;height:28px;border-radius:7px;border:1px solid rgba(255,68,102,.3);background:rgba(255,68,102,.08);color:var(--danger);font-size:13px;cursor:pointer;flex-shrink:0;display:flex;align-items:center;justify-content:center" class="ah-ch-del">âœ•</button>`;
    row.querySelector('.ah-ch-del').addEventListener('click', () => row.remove());
    row.querySelectorAll('input').forEach(i => {
      i.style.cssText += ';width:auto;background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:9px 10px;color:var(--text);font-family:var(--font-mono);font-size:13px;outline:none';
      i.addEventListener('focus', () => i.style.borderColor='var(--accent)');
      i.addEventListener('blur', () => i.style.borderColor='var(--border)');
    });
    choicesList.appendChild(row);
  }

  // Pre-populate choices if editing a choice habit
  if (existingCfg.type === 'choice' && existingCfg.choices?.length) {
    existingCfg.choices.forEach(c => addChoiceRow(c.label || '', c.value || ''));
  } else if (existingCfg.type !== 'choice') {
    addChoiceRow('', 1); addChoiceRow('', 2);
  }

  ov.querySelector('#ah-type-incr').addEventListener('click', () => {
    habitType = 'incremental';
    ov.querySelector('#ah-type-incr').className = 'btn btn-green'; ov.querySelector('#ah-type-incr').style.flex='1'; ov.querySelector('#ah-type-incr').style.fontSize='13px';
    ov.querySelector('#ah-type-choice').className = 'btn btn-ghost'; ov.querySelector('#ah-type-choice').style.flex='1'; ov.querySelector('#ah-type-choice').style.fontSize='13px';
    ov.querySelector('#ah-incr-fields').style.display = '';
    ov.querySelector('#ah-choice-fields').style.display = 'none';
  });
  ov.querySelector('#ah-type-choice').addEventListener('click', () => {
    habitType = 'choice';
    ov.querySelector('#ah-type-choice').className = 'btn btn-green'; ov.querySelector('#ah-type-choice').style.flex='1'; ov.querySelector('#ah-type-choice').style.fontSize='13px';
    ov.querySelector('#ah-type-incr').className = 'btn btn-ghost'; ov.querySelector('#ah-type-incr').style.flex='1'; ov.querySelector('#ah-type-incr').style.fontSize='13px';
    ov.querySelector('#ah-incr-fields').style.display = 'none';
    ov.querySelector('#ah-choice-fields').style.display = '';
  });

  ov.querySelector('#ah-add-choice').addEventListener('click', () => addChoiceRow());

  const close = () => document.body.removeChild(ov);
  ov.addEventListener('click', e => { if (e.target === ov) close(); });
  ov.querySelector('#ah-cancel').addEventListener('click', close);

  ov.querySelector('#ah-save').addEventListener('click', () => {
    const newKey = ov.querySelector('#ah-key').value.trim().replace(/\s+/g, '_');
    const icon = ov.querySelector('#ah-icon').value.trim() || 'â­';
    if (!newKey) { showToast('Enter a habit name'); return; }

    if (!S.config) S.config = { schedule: [], habitDefinitions: {}, habitTracker: { enabled: true, snoozeOptions: [5, 10] } };
    if (!S.config.habitDefinitions) S.config.habitDefinitions = {};

    // If key changed, remove old entry
    if (newKey !== key) {
      delete S.config.habitDefinitions[key];
      if (S.habitData[key] !== undefined) { S.habitData[newKey] = S.habitData[key]; delete S.habitData[key]; }
    }

    if (habitType === 'incremental') {
      const maxVal = parseInt(ov.querySelector('#ah-max').value) || 1;
      S.config.habitDefinitions[newKey] = { type: 'incremental', icon, maxValue: maxVal, increment: 1, messages: existingCfg.messages||{} };
    } else {
      const rows = choicesList.querySelectorAll('[data-choice-idx]');
      const choices = [];
      let v = 0;
      rows.forEach(row => {
        const label = row.querySelector('.ah-ch-label').value.trim();
        const val = parseInt(row.querySelector('.ah-ch-val').value);
        if (label) { v++; choices.push({ value: isNaN(val) ? v : val, label }); }
      });
      if (!choices.length) { showToast('Add at least one choice'); return; }
      S.config.habitDefinitions[newKey] = { type: 'choice', icon, choices, messages: existingCfg.messages||{} };
    }

    LS.set('lastConfig', S.config);
    saveHabitDefinitionsToVault();
    close();
    renderHabitBars();
    showToast(`âœ“ ${newKey} updated`);
  });
}

function showManualModal(key) {
  const cfg=S.config?.habitDefinitions?.[key]; if (!cfg) return;
  const raw=S.habitData[key]||0;
  const mv=cfg.type==='choice'?1:(cfg.maxValue||1);
  const dv=cfg.type==='choice'?(raw>0?1:0):raw;
  const isComplete = dv >= mv;
  const isBoolHabit = cfg.type==='incremental' && mv===1 && (cfg.increment||1)===1;
  const ov=document.createElement('div'); ov.className='modal-overlay';
  let actions='';
  if (isBoolHabit) {
    // Binary habit â€” show âœ“ / âœ• buttons only
    const done = raw >= 1;
    actions=`
      <div class="btn-row" style="justify-content:center;gap:16px">
        <button class="btn btn-green btn-icon" id="mh-check" style="font-size:22px;width:64px;height:64px;${done?'outline:2px solid var(--accent)':''}">âœ“</button>
        <button class="btn btn-red btn-icon" id="mh-cross" style="font-size:22px;width:64px;height:64px;${!done&&raw===0?'':''}">âœ•</button>
      </div>
      ${done?`<div style="font-size:11px;font-family:var(--font-mono);color:var(--accent);text-align:center;margin-top:12px">âœ“ Done today!</div>`:''}`;
  } else if (cfg.type==='incremental') {
    actions=`
      <div style="font-size:12px;font-family:var(--font-mono);color:var(--muted);text-align:center;margin-bottom:${isComplete?'8px':'16px'}">
        <strong style="color:var(--text)">${dv}</strong> / ${mv}</div>
      ${isComplete?`<div style="font-size:11px;font-family:var(--font-mono);color:var(--accent);text-align:center;margin-bottom:14px;padding:6px 12px;background:rgba(0,255,136,.08);border-radius:8px">âœ“ Goal reached!</div>`:''}
      <div class="btn-row">
        <button class="btn btn-green btn-icon" id="mh-inc" ${isComplete?'disabled style="opacity:.45;cursor:not-allowed"':''}>ï¼‹</button>
        <button class="btn btn-red btn-icon" id="mh-dec">âˆ’</button>
      </div>`;
  } else {
    actions=`${isComplete?`<div style="font-size:11px;font-family:var(--font-mono);color:var(--accent);text-align:center;margin-bottom:14px;padding:6px 12px;background:rgba(0,255,136,.08);border-radius:8px">âœ“ Already completed â€” tap to change</div>`:''}
      <div class="btn-row">
        ${cfg.choices.map(c=>`<button class="btn btn-green mh-ch" data-val="${c.value}" style="${raw===c.value?'outline:2px solid var(--accent)':''}">${c.label}</button>`).join('')}
        ${cfg.messages?.failed?`<button class="btn btn-red mh-fail">âœ• Fail</button>`:''}
      </div>`;
  }
  ov.innerHTML=`<div class="modal">
    <div class="modal-handle"></div>
    <div style="font-size:48px;text-align:center;margin-bottom:16px">${cfg.icon}</div>
    ${actions}
  </div>`;
  document.body.appendChild(ov);
  ov.addEventListener('click',e=>{ if(e.target===ov) document.body.removeChild(ov); });
  if (isBoolHabit) {
    ov.querySelector('#mh-check').addEventListener('click',()=>{
      S.habitData[key]=1; writeHabitData(); renderHabitBars(); showToast('âœ“ Done!'); document.body.removeChild(ov);
    });
    ov.querySelector('#mh-cross').addEventListener('click',()=>{
      S.habitData[key]=0; writeHabitData(); renderHabitBars(); showToast('Cleared'); document.body.removeChild(ov);
    });
  } else if (cfg.type==='incremental') {
    ov.querySelector('#mh-inc').addEventListener('click',()=>{ 
      const cur2 = S.habitData[key]||0;
      if (cur2 >= cfg.maxValue) { showToast(cfg.messages?.maxReached||'Already at max!'); return; }
      S.habitData[key]=Math.min(cfg.maxValue, cur2+(cfg.increment||1));
      showToast(cfg.messages?.[S.habitData[key]]||'Logged!');
      writeHabitData(); renderHabitBars();
      document.body.removeChild(ov); 
    });
    ov.querySelector('#mh-dec').addEventListener('click',()=>{ decrementHabit(key); document.body.removeChild(ov); });
  } else {
    ov.querySelectorAll('.mh-ch').forEach(b=>b.addEventListener('click',()=>{ updateHabit(key,parseInt(b.dataset.val)); document.body.removeChild(ov); }));
    ov.querySelector('.mh-fail')?.addEventListener('click',()=>{ updateHabit(key,0); document.body.removeChild(ov); });
  }
}

// â”€â”€ RENDER â€” SCHEDULE TAB â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _scheduleSnapshot = null;
let _schedView = 'calendar';
let _calViewYear = new Date().getFullYear();
let _calViewMonth = new Date().getMonth();
let _calSelectedISO = new Date().toISOString().slice(0,10);
let _tbTab = 'routine'; // 'routine' | 'scheduled' | 'focused'

function renderScheduleTab() {
  const el = document.getElementById('schedule-tab');
  if (!el) return;
  el.innerHTML = '';
  // Make the schedule tab not vertically scroll so the half-half layout fills screen
  el.style.overflowY = 'hidden';
  el.style.paddingBottom = '80px';

  // â”€â”€ Top-level TB tab bar â”€â”€
  if (!['routine','scheduled'].includes(_tbTab)) _tbTab = 'routine';
  const tabBar = document.createElement('div');
  tabBar.className = 'tb-tabs';
  const tbDefs = [
    { id:'routine',   label:'ðŸ”„ Daily Routine' },
    { id:'scheduled', label:'ðŸ“Œ Scheduled' },
  ];
  tbDefs.forEach(t => {
    const btn = document.createElement('button');
    btn.className = `tb-tab${_tbTab === t.id ? ' active' : ''}`;
    btn.textContent = t.label;
    btn.addEventListener('click', () => {
      _tbTab = t.id;
      // Reset any custom style overrides
      el.style.overflowY = '';
      el.style.paddingBottom = '';
      renderScheduleTab();
    });
    tabBar.appendChild(btn);
  });
  el.appendChild(tabBar);

  // â”€â”€ Reset tab styles for scheduled view (needs fixed height, no scroll) â”€â”€
  el.style.overflowY = 'hidden';
  el.style.paddingBottom = '80px';
  el.style.height = '100%';
  el.style.display = 'flex';
  el.style.flexDirection = 'column';

  // â”€â”€ Render the active tab content â”€â”€
  if (_tbTab === 'routine')   renderRoutineTab(el);
  else if (_tbTab === 'scheduled') renderScheduledTab(el);
}
function renderTBList(container, items, emptyMsg, emptyIcon) {
  container.innerHTML = '';
  const todayISO = new Date().toISOString().slice(0,10);
  const nowTime  = new Date();

  if (!items.length) {
    const empty = document.createElement('div');
    empty.style.cssText = 'display:flex;flex-direction:column;align-items:center;gap:10px;padding:32px 16px;text-align:center';
    empty.innerHTML = `<div style="font-size:32px;opacity:.35">${emptyIcon}</div>
      <div style="color:var(--muted);font-size:12px;font-family:var(--font-mono);line-height:1.8;white-space:pre-line">${emptyMsg}</div>`;
    const ctaBtn = document.createElement('button');
    ctaBtn.textContent = 'ï¼‹ Add Time Block';
    ctaBtn.style.cssText = 'margin-top:4px;padding:10px 20px;border-radius:10px;border:1.5px solid rgba(0,255,136,.4);background:rgba(0,255,136,.08);color:var(--accent);font-size:12px;font-family:var(--font-mono);font-weight:700;cursor:pointer';
    ctaBtn.addEventListener('click', () => showAddScheduleSheet(() => renderScheduleTab()));
    empty.appendChild(ctaBtn);
    container.appendChild(empty);
    return;
  }

  const list = document.createElement('div');
  list.className = 'tb-list';

  items.forEach(item => {
    const r = item.repeat || 'daily';
    const repeatLabel = { daily:'Daily', weekly:'Weekly', monthly:'Monthly', yearly:'Yearly', once:'One-time', off:'Off', custom:'Custom' }[r] || r;

    let nowClass = '';
    if (item.time) {
      const itemTime = schedDate(item.time);
      const itemEnd  = new Date(itemTime.getTime() + (item.duration || 30) * 60000);
      if (nowTime >= itemTime && nowTime < itemEnd) nowClass = 'now-item';
      else if (nowTime >= itemEnd) nowClass = 'past-item';
    }

    const timeDisplay = item.blockType === 'open'
      ? `~${item.duration || 30}m`
      : (item.time || 'â€”');

    const row = document.createElement('div');
    row.className = `tb-list-item ${nowClass}`;

    const timeSpan = document.createElement('span');
    timeSpan.className = 'tb-item-time';
    timeSpan.textContent = timeDisplay;

    const actSpan = document.createElement('span');
    actSpan.className = 'tb-item-act';
    actSpan.textContent = item.activity;

    const badge = document.createElement('span');
    badge.className = 'tb-item-badge';
    badge.textContent = repeatLabel;

    const editBtn = document.createElement('button');
    editBtn.className = 'tb-action-btn';
    editBtn.innerHTML = 'âœŽ';
    editBtn.title = 'Edit';
    editBtn.addEventListener('click', e => {
      e.stopPropagation();
      const globalIdx = (S.config?.schedule || []).findIndex(x => x._id ? x._id === item._id : x === item);
      if (globalIdx < 0) return;
      showEditSchedulePopup(item.time, item.activity, item.repeat, (newTime, newAct, newRepeat) => {
        S.config.schedule[globalIdx] = { ...S.config.schedule[globalIdx], time: newTime, activity: newAct, repeat: newRepeat || 'daily' };
        try { S.config.schedule.sort((a,b) => schedDate(a.time)-schedDate(b.time)); } catch {}
        LS.set('lastConfig', S.config); saveScheduleToVault(); syncAlarmsToSW();
        renderScheduleTab();
      });
    });

    const delBtn = document.createElement('button');
    delBtn.className = 'tb-action-btn del';
    delBtn.innerHTML = 'âœ•';
    delBtn.title = 'Delete';
    delBtn.addEventListener('click', e => {
      e.stopPropagation();
      const globalIdx = (S.config?.schedule || []).findIndex(x => x._id ? x._id === item._id : x === item);
      if (globalIdx < 0) return;
      if (!confirm(`Delete "${item.activity}"?`)) return;
      S.config.schedule.splice(globalIdx, 1);
      LS.set('lastConfig', S.config); saveScheduleToVault(); syncAlarmsToSW();
      renderScheduleTab();
      showToast('ðŸ—‘ Block deleted');
    });

    // Tap item â†’ habit modal
    row.addEventListener('click', () => {
      const hi = detectHabit(item.activity);
      if (hi) showManualModal(hi.key);
    });

    row.appendChild(timeSpan);
    row.appendChild(actSpan);
    row.appendChild(badge);
    row.appendChild(editBtn);
    row.appendChild(delBtn);
    list.appendChild(row);
  });

  container.appendChild(list);
}

// â”€â”€ DAILY ROUTINE tab â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderRoutineTab(el) {
  const allSc = S.config?.schedule || [];
  const items = allSc.filter(item => {
    const r = item.repeat || 'daily';
    if (item.blockType === 'routine') return true;
    // Legacy: no blockType + daily unlimited
    if (!item.blockType && r === 'daily' && !item.limitFrom && !item.limitTo) return true;
    return false;
  });
  items.sort((a,b) => { try { return schedDate(a.time)-schedDate(b.time); } catch { return 0; } });

  const wrap = document.createElement('div');
  wrap.style.cssText = 'flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch';
  renderTBList(wrap, items,
    'No daily routine items yet.\nRoutines are habits & chores that repeat\non a regular schedule.',
    'ðŸ”„');
  el.appendChild(wrap);
}

// â”€â”€ FOCUSED WORK tab â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderFocusedTab(el) {
  const allSc = S.config?.schedule || [];
  const items = allSc.filter(item => item.blockType === 'open');
  items.sort((a,b) => a.activity.localeCompare(b.activity));

  const wrap = document.createElement('div');
  wrap.style.cssText = 'flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch';
  renderTBList(wrap, items,
    'No focused work blocks yet.\nAdd hobbies or projects with a duration\ninstead of a fixed time.',
    'ðŸŒ€');
  el.appendChild(wrap);
}

// â”€â”€ SCHEDULED EVENT tab â€” calendar top half | events bottom half â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderScheduledTab(el) {
  const todayISO = new Date().toISOString().slice(0,10);

  // â”€â”€ Outer container: vertical stack filling available height â”€â”€
  const wrap = document.createElement('div');
  wrap.style.cssText = 'display:flex;flex-direction:column;gap:8px;flex:1;min-height:0;overflow:hidden';
  el.appendChild(wrap);

  // Multi-select state
  let multiSelectMode = false;
  let multiSelectedDates = new Set();

  // â”€â”€ TOP: Calendar (shrink-to-fit content) â”€â”€
  const calBox = document.createElement('div');
  calBox.style.cssText = 'flex-shrink:0;display:flex;flex-direction:column;background:var(--bg2);border:1px solid var(--border);border-radius:14px;padding:8px 10px 6px;overflow:hidden';
  wrap.appendChild(calBox);

  // â”€â”€ BOTTOM: Event details panel (bottom ~50% of screen) â”€â”€
  const detailBox = document.createElement('div');
  detailBox.style.cssText = 'flex:1;display:flex;flex-direction:column;background:var(--bg2);border:1px solid var(--border);border-radius:14px;overflow:hidden;min-height:0';
  wrap.appendChild(detailBox);

  const detailHeader = document.createElement('div');
  detailHeader.style.cssText = 'padding:9px 13px 8px;border-bottom:1px solid var(--border);flex-shrink:0;display:flex;align-items:center;justify-content:space-between;gap:6px;background:rgba(0,255,136,.03)';
  detailBox.appendChild(detailHeader);

  const detailItems = document.createElement('div');
  detailItems.style.cssText = 'flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch;padding:8px 12px 10px';
  detailBox.appendChild(detailItems);

  function buildCalGrid() {
    calBox.innerHTML = '';

    // Month nav row
    const navRow = document.createElement('div');
    navRow.style.cssText = 'display:flex;align-items:center;justify-content:space-between;margin-bottom:4px;gap:4px';
    const mLabel = document.createElement('div');
    mLabel.style.cssText = 'font-size:12px;font-weight:800;font-family:var(--font-mono)';
    const mNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    mLabel.textContent = `${mNames[_calViewMonth]} ${_calViewYear}`;
    const prevBtn = document.createElement('button');
    prevBtn.innerHTML = 'â€¹';
    prevBtn.style.cssText = 'width:24px;height:24px;border-radius:6px;border:1px solid var(--border);background:var(--bg3);color:var(--text);font-size:14px;cursor:pointer;display:flex;align-items:center;justify-content:center;padding:0;flex-shrink:0';
    const nextBtn = document.createElement('button');
    nextBtn.innerHTML = 'â€º';
    nextBtn.style.cssText = prevBtn.style.cssText;
    prevBtn.addEventListener('click', () => { _calViewMonth--; if(_calViewMonth<0){_calViewMonth=11;_calViewYear--;} buildCalGrid(); });
    nextBtn.addEventListener('click', () => { _calViewMonth++; if(_calViewMonth>11){_calViewMonth=0;_calViewYear++;} buildCalGrid(); });
    navRow.appendChild(mLabel);
    const navBtns = document.createElement('div');
    navBtns.style.cssText = 'display:flex;gap:4px;align-items:center';

    // Multi-select toggle button (inline with nav)
    const msBtn = document.createElement('button');
    msBtn.innerHTML = multiSelectMode ? 'âœ• Cancel' : 'âŠž Multi';
    msBtn.style.cssText = `padding:3px 7px;border-radius:6px;border:1px solid ${multiSelectMode?'rgba(255,68,102,.4)':'rgba(0,255,136,.3)'};background:${multiSelectMode?'rgba(255,68,102,.06)':'rgba(0,255,136,.05)'};color:${multiSelectMode?'var(--danger)':'var(--accent)'};font-size:9px;font-family:var(--font-mono);font-weight:700;cursor:pointer;white-space:nowrap`;
    msBtn.addEventListener('click', () => {
      multiSelectMode = !multiSelectMode;
      if (!multiSelectMode) multiSelectedDates.clear();
      buildCalGrid();
      if (!multiSelectMode) buildEventList();
      else showMultiSelectPanel();
    });

    navBtns.appendChild(msBtn);
    navBtns.appendChild(prevBtn);
    navBtns.appendChild(nextBtn);
    navRow.appendChild(navBtns);
    calBox.appendChild(navRow);

    // Day headers
    const dayHdrRow = document.createElement('div');
    dayHdrRow.style.cssText = 'display:grid;grid-template-columns:repeat(7,1fr);gap:2px;margin-bottom:2px';
    ['Su','Mo','Tu','We','Th','Fr','Sa'].forEach(d => {
      const h = document.createElement('div');
      h.textContent = d;
      h.style.cssText = 'text-align:center;font-size:8px;font-family:var(--font-mono);color:var(--muted);font-weight:700;padding:1px 0';
      dayHdrRow.appendChild(h);
    });
    calBox.appendChild(dayHdrRow);

    // Days grid â€” fixed compact cells so full calendar always fits without overflow
    const daysGrid = document.createElement('div');
    daysGrid.style.cssText = 'display:grid;grid-template-columns:repeat(7,1fr);gap:2px';
    const daysInMonth = new Date(_calViewYear, _calViewMonth+1, 0).getDate();
    const firstDay = new Date(_calViewYear, _calViewMonth, 1).getDay();
    for (let i=0;i<firstDay;i++) {
      const b = document.createElement('div'); b.style.cssText='aspect-ratio:1'; daysGrid.appendChild(b);
    }
    for (let d=1; d<=daysInMonth; d++) {
      const mm = String(_calViewMonth+1).padStart(2,'0');
      const dd = String(d).padStart(2,'0');
      const iso = `${_calViewYear}-${mm}-${dd}`;
      const isPast = iso < todayISO;
      const tasks = getScheduledItemsForDate(iso).filter(it=>it.repeat==='once'||it.repeat==='custom'||it.blockType==='scheduled');
      const heat = getHeatLevel(tasks.length);
      const isToday = iso === todayISO;
      const isCalSel = !multiSelectMode && iso === _calSelectedISO;
      const isMultiSel = multiSelectMode && multiSelectedDates.has(iso);
      const cell = document.createElement('div');
      cell.className = `cal-day cal-heat-${heat}${isToday?' today-ring':''}${isCalSel||isMultiSel?' selected-day':''}`;
      cell.style.cssText = `aspect-ratio:1;min-height:0;max-height:none;border-radius:7px;${isPast?'opacity:0.28;cursor:default;pointer-events:none;':''}`;
      const numEl = document.createElement('div'); numEl.className = 'cal-day-num'; numEl.style.fontSize='10px'; numEl.textContent = d;
      cell.appendChild(numEl);
      if (tasks.length > 0) { const dot=document.createElement('div'); dot.className='cal-day-dot'; cell.appendChild(dot); }
      if (!isPast) {
        cell.addEventListener('click', () => {
          if (multiSelectMode) {
            if (multiSelectedDates.has(iso)) multiSelectedDates.delete(iso);
            else multiSelectedDates.add(iso);
            buildCalGrid();
            showMultiSelectPanel();
          } else {
            _calSelectedISO = iso; buildCalGrid(); buildEventList();
          }
        });
      }
      daysGrid.appendChild(cell);
    }
    calBox.appendChild(daysGrid);

    // Multi-select action at bottom of cal
    if (multiSelectMode && multiSelectedDates.size > 0) {
      const msAddBtn = document.createElement('button');
      msAddBtn.textContent = `ï¼‹ Add (${multiSelectedDates.size})`;
      msAddBtn.style.cssText = 'width:100%;margin-top:4px;padding:4px;border-radius:7px;border:1px solid rgba(0,255,136,.4);background:rgba(0,255,136,.1);color:var(--accent);font-size:10px;font-family:var(--font-mono);font-weight:700;cursor:pointer;flex-shrink:0';
      msAddBtn.addEventListener('click', () => {
        showMultiDateAddSheet(Array.from(multiSelectedDates).sort(), () => {
          multiSelectMode = false; multiSelectedDates.clear();
          buildCalGrid(); buildEventList();
        });
      });
      calBox.appendChild(msAddBtn);
    }
  }

  function showMultiSelectPanel() {
    detailHeader.innerHTML = '';
    detailItems.innerHTML = '';
    const cnt = multiSelectedDates.size;
    const hd = document.createElement('div');
    hd.style.cssText = 'font-size:10px;font-weight:800;font-family:var(--font-mono);color:var(--accent)';
    hd.textContent = cnt > 0 ? `${cnt} date${cnt>1?'s':''} selected` : 'Select dates';
    detailHeader.appendChild(hd);
    if (cnt === 0) {
      detailItems.innerHTML = '<div style="text-align:center;padding:16px 8px;color:var(--muted);font-size:10px;font-family:var(--font-mono)">Tap days to select</div>';
      return;
    }
    const sorted = Array.from(multiSelectedDates).sort();
    sorted.forEach(iso => {
      const d = new Date(iso+'T00:00:00');
      const dN=['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
      const mN=['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      const chip = document.createElement('div');
      chip.style.cssText = 'padding:5px 7px;background:rgba(0,255,136,.08);border:1px solid rgba(0,255,136,.2);border-radius:7px;font-size:9px;font-family:var(--font-mono);color:var(--accent);margin-bottom:4px';
      chip.textContent = `${dN[d.getDay()]} ${mN[d.getMonth()]} ${d.getDate()}`;
      detailItems.appendChild(chip);
    });
  }

  function buildEventList() {
    if (!_calSelectedISO) {
      detailHeader.innerHTML = '<div style="font-size:10px;color:var(--muted);font-family:var(--font-mono)">Select a date</div>';
      detailItems.innerHTML = '<div style="text-align:center;padding:20px 8px;color:var(--muted);font-size:10px;font-family:var(--font-mono);line-height:1.6">Tap a day\non the calendar</div>';
      return;
    }
    const d = new Date(_calSelectedISO+'T00:00:00');
    const dayNames=['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
    const mNames=['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    const isSelToday = _calSelectedISO === todayISO;

    detailHeader.innerHTML = '';
    const hdrLeft = document.createElement('div');
    hdrLeft.style.cssText = 'display:flex;flex-direction:column;gap:1px;flex:1;min-width:0';
    hdrLeft.innerHTML = `<div style="font-size:12px;font-weight:800;font-family:var(--font-mono)">${dayNames[d.getDay()]}, ${mNames[d.getMonth()]} ${d.getDate()}</div>${isSelToday?'<div style="font-size:9px;color:var(--accent);font-family:var(--font-mono)">Today</div>':''}`;
    const addBtn = document.createElement('button');
    addBtn.innerHTML = 'ï¼‹ Add';
    addBtn.title = 'Add event';
    addBtn.style.cssText = 'padding:5px 10px;border-radius:7px;border:1px solid rgba(0,255,136,.35);background:rgba(0,255,136,.08);color:var(--accent);font-size:11px;font-family:var(--font-mono);font-weight:700;cursor:pointer;flex-shrink:0;display:flex;align-items:center;justify-content:center;gap:2px';
    addBtn.addEventListener('click', () => showAddScheduleSheet(() => { buildCalGrid(); buildEventList(); }, 'scheduled'));
    detailHeader.appendChild(hdrLeft);
    detailHeader.appendChild(addBtn);

    detailItems.innerHTML = '';
    const nowTime = new Date();
    // Only show strictly scheduled (once/custom/limited) items â€” not routine
    const items = (S.config?.schedule || []).filter(item => {
      if (item.blockType === 'open') return false;
      if (item.blockType === 'routine') return false;
      const r = item.repeat || 'daily';
      if (r === 'daily' && !item.blockType && !item.limitFrom && !item.limitTo) return false;
      if (r === 'once') return item.createdOn === _calSelectedISO;
      if (r === 'custom') return (item.customDates || []).includes(_calSelectedISO);
      if (r === 'weekly') {
        const cd = new Date((item.createdOn || _calSelectedISO) + 'T00:00:00');
        return cd.getDay() === d.getDay();
      }
      if (r === 'monthly') {
        const cd = new Date((item.createdOn || _calSelectedISO) + 'T00:00:00');
        return cd.getDate() === d.getDate();
      }
      if (r === 'daily' && (item.blockType === 'scheduled' || item.limitFrom || item.limitTo)) {
        if (item.limitFrom && _calSelectedISO < item.limitFrom) return false;
        if (item.limitTo && _calSelectedISO > item.limitTo) return false;
        return true;
      }
      return false;
    });
    items.sort((a,b) => { try { return schedDate(a.time)-schedDate(b.time); } catch { return 0; } });

    if (!items.length) {
      detailItems.innerHTML = '<div style="text-align:center;padding:16px 6px;color:var(--muted);font-size:10px;font-family:var(--font-mono);line-height:1.7">No events.\nTap ï¼‹ to add.</div>';
      return;
    }

    items.forEach(item => {
      const r = item.repeat || 'daily';
      let nowClass = '';
      if (item.time && isSelToday && schedDate(item.time) < nowTime) nowClass = 'past-item';
      const row = document.createElement('div');
      row.className = `tb-list-item ${nowClass}`;
      row.style.cssText = 'padding:9px 10px;gap:8px;';

      const timeSpan = document.createElement('span'); timeSpan.className='tb-item-time'; timeSpan.style.cssText='min-width:60px;font-size:11px'; timeSpan.textContent=item.time||'â€”';
      const actSpan = document.createElement('span'); actSpan.className='tb-item-act'; actSpan.style.fontSize='12px'; actSpan.textContent=item.activity;

      const editBtn = document.createElement('button'); editBtn.className='tb-action-btn'; editBtn.innerHTML='âœŽ'; editBtn.style.cssText='width:26px;height:26px;font-size:11px';
      editBtn.addEventListener('click', e => {
        e.stopPropagation();
        const globalIdx=(S.config?.schedule||[]).findIndex(x=>x._id?x._id===item._id:x===item);
        if(globalIdx<0) return;
        showEditSchedulePopup(item.time,item.activity,item.repeat,(newTime,newAct,newRepeat)=>{
          S.config.schedule[globalIdx]={...S.config.schedule[globalIdx],time:newTime,activity:newAct,repeat:newRepeat||'once'};
          try{S.config.schedule.sort((a,b)=>schedDate(a.time)-schedDate(b.time));}catch{}
          LS.set('lastConfig',S.config);saveScheduleToVault();syncAlarmsToSW();
          buildCalGrid();buildEventList();
        }, 'scheduled');
      });

      const delBtn = document.createElement('button'); delBtn.className='tb-action-btn del'; delBtn.innerHTML='âœ•'; delBtn.style.cssText='width:26px;height:26px;font-size:11px';
      delBtn.addEventListener('click', e => {
        e.stopPropagation();
        const globalIdx=(S.config?.schedule||[]).findIndex(x=>x._id?x._id===item._id:x===item);
        if(globalIdx<0) return;
        if(!confirm(`Delete "${item.activity}"?`)) return;
        S.config.schedule.splice(globalIdx,1);
        LS.set('lastConfig',S.config);saveScheduleToVault();syncAlarmsToSW();
        buildCalGrid();buildEventList();
        showToast('ðŸ—‘ Deleted');
      });

      row.appendChild(timeSpan); row.appendChild(actSpan); row.appendChild(editBtn); row.appendChild(delBtn);
      detailItems.appendChild(row);
    });
  }

  buildCalGrid();
  buildEventList();
}

// â”€â”€ MULTI-DATE ADD SHEET â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showMultiDateAddSheet(initialDates, onDone) {
  const ov = document.createElement('div');
  ov.style.cssText='position:fixed;inset:0;background:rgba(0,0,0,.78);z-index:1000;display:flex;align-items:flex-end;justify-content:center;backdrop-filter:blur(6px)';
  const sheet = document.createElement('div');
  sheet.style.cssText='background:var(--bg2);border-radius:20px 20px 0 0;padding:20px 16px calc(24px + env(safe-area-inset-bottom,0px));width:100%;max-width:480px;max-height:90dvh;overflow-y:auto;display:flex;flex-direction:column;gap:0';
  ov.appendChild(sheet);
  document.body.appendChild(ov);

  const close=()=>document.body.removeChild(ov);
  ov.addEventListener('click',e=>{if(e.target===ov)close();});

  let rows = initialDates.map(iso=>({id:genItemId(),iso,time:'9:00 AM'}));
  let activityVal='';

  function formatISOShort(iso){
    const d=new Date(iso+'T00:00:00');
    const dN=['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
    const mN=['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    return `${dN[d.getDay()]} ${mN[d.getMonth()]} ${d.getDate()}`;
  }

  function renderSheet(){
    sheet.innerHTML='';
    const handle=document.createElement('div');
    handle.style.cssText='width:40px;height:4px;background:var(--border);border-radius:2px;margin:0 auto 18px';
    sheet.appendChild(handle);

    const title=document.createElement('div');
    title.style.cssText='font-size:17px;font-weight:800;margin-bottom:16px';
    title.textContent='Add Scheduled Events';
    sheet.appendChild(title);

    // Activity
    const actLbl=document.createElement('div');
    actLbl.style.cssText='font-size:10px;font-family:var(--font-mono);color:var(--muted);text-transform:uppercase;letter-spacing:1px;margin-bottom:6px';
    actLbl.textContent='Activity';
    sheet.appendChild(actLbl);
    const actIn=document.createElement('input');
    actIn.type='text'; actIn.placeholder='e.g. Doctor appointmentâ€¦'; actIn.value=activityVal; actIn.autocomplete='off';
    actIn.style.cssText='width:100%;background:var(--bg3);border:1px solid var(--border);border-radius:10px;padding:12px 14px;color:var(--text);font-family:var(--font-display);font-size:14px;outline:none;margin-bottom:16px;transition:border-color .15s;box-sizing:border-box';
    actIn.addEventListener('input',()=>{activityVal=actIn.value;});
    actIn.addEventListener('focus',()=>actIn.style.borderColor='var(--accent)');
    actIn.addEventListener('blur',()=>actIn.style.borderColor='var(--border)');
    sheet.appendChild(actIn);
    setTimeout(()=>actIn.focus(),150);

    // Rows label
    const rowsLbl=document.createElement('div');
    rowsLbl.style.cssText='font-size:10px;font-family:var(--font-mono);color:var(--muted);text-transform:uppercase;letter-spacing:1px;margin-bottom:8px';
    rowsLbl.textContent='Date & Time';
    sheet.appendChild(rowsLbl);

    const rowsWrap=document.createElement('div');
    rowsWrap.style.cssText='display:flex;flex-direction:column;gap:6px;margin-bottom:10px';
    sheet.appendChild(rowsWrap);

    rows.forEach((row,idx)=>{
      const rowEl=document.createElement('div');
      rowEl.style.cssText='display:flex;align-items:center;gap:6px';

      const dateBtn=document.createElement('button');
      dateBtn.style.cssText='flex:1;padding:10px 10px;background:var(--bg3);border:1px solid var(--border);border-radius:9px;color:var(--accent);font-size:12px;font-family:var(--font-mono);font-weight:700;cursor:pointer;text-align:left;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;transition:border-color .15s';
      dateBtn.textContent=formatISOShort(row.iso);
      dateBtn.addEventListener('click',()=>{
        activityVal=actIn.value;
        showMiniCalendarPopup(row.iso,(newIso)=>{ rows[idx].iso=newIso; renderSheet(); });
      });

      const timeBtn=document.createElement('button');
      timeBtn.style.cssText='padding:10px 10px;background:var(--bg3);border:1px solid var(--border);border-radius:9px;color:var(--text);font-size:12px;font-family:var(--font-mono);font-weight:700;cursor:pointer;white-space:nowrap;transition:border-color .15s;flex-shrink:0';
      timeBtn.textContent=row.time;
      timeBtn.addEventListener('click',()=>{
        activityVal=actIn.value;
        showMiniTimeDrumPopup(row.time,(newTime)=>{ rows[idx].time=newTime; renderSheet(); });
      });

      const removeBtn=document.createElement('button');
      removeBtn.innerHTML='âœ•';
      removeBtn.style.cssText='width:30px;height:30px;border-radius:8px;border:1px solid rgba(255,68,102,.3);background:rgba(255,68,102,.08);color:var(--danger);font-size:12px;cursor:pointer;display:flex;align-items:center;justify-content:center;flex-shrink:0;padding:0';
      removeBtn.addEventListener('click',()=>{ activityVal=actIn.value; rows.splice(idx,1); renderSheet(); });

      rowEl.appendChild(dateBtn); rowEl.appendChild(timeBtn); rowEl.appendChild(removeBtn);
      rowsWrap.appendChild(rowEl);
    });

    const addMoreBtn=document.createElement('button');
    addMoreBtn.innerHTML='ï¼‹ Add Row';
    addMoreBtn.style.cssText='width:100%;padding:8px;border-radius:9px;border:1.5px dashed rgba(0,255,136,.3);background:rgba(0,255,136,.04);color:var(--accent);font-size:11px;font-family:var(--font-mono);font-weight:700;cursor:pointer;margin-bottom:16px';
    addMoreBtn.addEventListener('click',()=>{
      activityVal=actIn.value;
      rows.push({id:genItemId(),iso:new Date().toISOString().slice(0,10),time:'9:00 AM'});
      renderSheet();
    });
    sheet.appendChild(addMoreBtn);

    const footer=document.createElement('div');
    footer.style.cssText='display:flex;gap:10px;padding-top:4px';
    const cancelBtn=document.createElement('button');
    cancelBtn.className='btn btn-ghost'; cancelBtn.style.flex='1'; cancelBtn.textContent='Cancel';
    cancelBtn.addEventListener('click',close);
    const addBtn=document.createElement('button');
    addBtn.className='btn btn-green'; addBtn.style.flex='2'; addBtn.textContent=`ï¼‹ Add ${rows.length} Block${rows.length!==1?'s':''}`;
    addBtn.addEventListener('click',()=>{
      const activity=actIn.value.trim();
      if(!activity){showToast('Enter an activity');actIn.focus();return;}
      if(rows.length===0){showToast('Add at least one date');return;}
      if(!S.config) S.config={schedule:[],habitDefinitions:{},habitTracker:{enabled:true,snoozeOptions:[5,10]}};
      rows.forEach(row=>{
        S.config.schedule.push({_id:genItemId(),activity,time:row.time,repeat:'once',createdOn:row.iso,blockType:'scheduled'});
      });
      try{S.config.schedule.sort((a,b)=>schedDate(a.time)-schedDate(b.time));}catch{}
      LS.set('lastConfig',S.config); saveScheduleToVault(); syncAlarmsToSW();
      close();
      showToast(`âœ“ ${rows.length} block${rows.length!==1?'s':''} added`);
      if(onDone) onDone();
    });
    footer.appendChild(cancelBtn); footer.appendChild(addBtn);
    sheet.appendChild(footer);
  }

  renderSheet();
}

// â”€â”€ MINI CALENDAR POPUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showMiniCalendarPopup(initialISO, onSelect) {
  const ov=document.createElement('div');
  ov.style.cssText='position:fixed;inset:0;background:rgba(0,0,0,.6);z-index:1100;display:flex;align-items:center;justify-content:center;padding:20px';
  document.body.appendChild(ov);
  const box=document.createElement('div');
  box.style.cssText='background:var(--bg2);border:1px solid var(--border);border-radius:16px;padding:16px;width:100%;max-width:280px';
  ov.appendChild(box);
  ov.addEventListener('click',e=>{if(e.target===ov) document.body.removeChild(ov);});
  const picker=buildSingleDatePicker(initialISO);
  box.appendChild(picker.el);
  const btnRow=document.createElement('div');
  btnRow.style.cssText='display:flex;gap:8px;margin-top:12px';
  const cancel=document.createElement('button');
  cancel.className='btn btn-ghost'; cancel.style.flex='1'; cancel.textContent='Cancel';
  cancel.addEventListener('click',()=>document.body.removeChild(ov));
  const ok=document.createElement('button');
  ok.className='btn btn-green'; ok.style.flex='1'; ok.textContent='Select';
  ok.addEventListener('click',()=>{ document.body.removeChild(ov); onSelect(picker.getSelected()); });
  btnRow.appendChild(cancel); btnRow.appendChild(ok);
  box.appendChild(btnRow);
}

// â”€â”€ MINI TIME DRUM POPUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showMiniTimeDrumPopup(initialTime, onSelect) {
  const ov=document.createElement('div');
  ov.style.cssText='position:fixed;inset:0;background:rgba(0,0,0,.6);z-index:1100;display:flex;align-items:center;justify-content:center;padding:20px';
  document.body.appendChild(ov);
  const box=document.createElement('div');
  box.style.cssText='background:var(--bg2);border:1px solid var(--border);border-radius:16px;padding:16px;width:100%;max-width:280px';
  ov.appendChild(box);
  ov.addEventListener('click',e=>{if(e.target===ov) document.body.removeChild(ov);});
  const title=document.createElement('div');
  title.style.cssText='font-size:14px;font-weight:800;margin-bottom:12px;text-align:center';
  title.textContent='Set Time';
  box.appendChild(title);
  const drumRoot=document.createElement('div');
  box.appendChild(drumRoot);
  let drumInst=null;
  requestAnimationFrame(()=>{ drumInst=buildTimeDrumEl(drumRoot,initialTime||'9:00 AM'); });
  const btnRow=document.createElement('div');
  btnRow.style.cssText='display:flex;gap:8px;margin-top:12px';
  const cancel=document.createElement('button');
  cancel.className='btn btn-ghost'; cancel.style.flex='1'; cancel.textContent='Cancel';
  cancel.addEventListener('click',()=>document.body.removeChild(ov));
  const ok=document.createElement('button');
  ok.className='btn btn-green'; ok.style.flex='1'; ok.textContent='Set';
  ok.addEventListener('click',()=>{ const t=drumInst?drumInst.getTime():(initialTime||'9:00 AM'); document.body.removeChild(ov); onSelect(t); });
  btnRow.appendChild(cancel); btnRow.appendChild(ok);
  box.appendChild(btnRow);
}

// â”€â”€ SCHEDULED ITEMS FOR DATE (used by calendar heatmap + event list) â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getScheduledItemsForDate(isoDate) {
  // Returns only "Scheduled Event" items active on a given date.
  // Routine (daily unlimited) and Focused Work (open) are excluded from the calendar.
  const all = S.config?.schedule || [];
  const d = new Date(isoDate + 'T00:00:00');
  const dow = d.getDay();
  const dom = d.getDate();
  return all.filter(item => {
    if (item.blockType === 'open') return false;   // Focused Work â€” not on calendar
    if (item.limitFrom && isoDate < item.limitFrom) return false;
    if (item.limitTo   && isoDate > item.limitTo)   return false;
    const r = item.repeat || 'daily';
    // Unlimited daily routines (no blockType and no date range) â†’ not on calendar
    if (!item.blockType && r === 'daily' && !item.limitFrom && !item.limitTo) return false;
    if (r === 'off') return false;
    if (r === 'daily') return true;
    if (r === 'weekly')  { if (!item.createdOn) return true; return new Date(item.createdOn+'T00:00:00').getDay()===dow; }
    if (r === 'monthly') { if (!item.createdOn) return true; return new Date(item.createdOn+'T00:00:00').getDate()===dom; }
    if (r === 'yearly')  {
      if (!item.createdOn) return true;
      const cd = new Date(item.createdOn+'T00:00:00');
      return cd.getMonth()===d.getMonth() && cd.getDate()===dom;
    }
    if (r === 'once')   return item.createdOn === isoDate;
    if (r === 'custom') return (item.customDates||[]).includes(isoDate);
    return true;
  });
}

// Keep old name as alias so any remaining callers don't break
function getScheduleForDate(isoDate) { return getScheduledItemsForDate(isoDate); }

// Map task count to heat level 0-6 (matches .cal-heat-N CSS classes)
// 0 tasks â†’ 0, 1-2 â†’ 1, 3-4 â†’ 2, 5-6 â†’ 3, 7-8 â†’ 4, 9-10 â†’ 5, 11+ â†’ 6
function getHeatLevel(count) {
  if (count === 0) return 0;
  if (count <= 2)  return 1;
  if (count <= 4)  return 2;
  if (count <= 6)  return 3;
  if (count <= 8)  return 4;
  if (count <= 10) return 5;
  return 6;
}

// â”€â”€ TIME DRUM PICKER HELPER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildTimeDrum(containerId, initialTime) {
  const hours   = ['12','1','2','3','4','5','6','7','8','9','10','11'];
  const minutes = Array.from({length:60}, (_,i) => String(i).padStart(2,'0'));
  const ampm    = ['AM','PM'];

  // Parse initial time
  let initH = 6, initM = 0, initAP = 0;
  if (initialTime) {
    const m = initialTime.match(/(\d+):(\d+)\s*(AM|PM)/i);
    if (m) {
      initH  = parseInt(m[1]) % 12;
      initM  = Math.round(parseInt(m[2]) / 5);
      initAP = m[3].toUpperCase() === 'PM' ? 1 : 0;
    }
  }

  const container = document.getElementById(containerId);
  if (!container) return null;

  function makeDrum(items, initIdx, extraClass, loop) {
    const col = document.createElement('div');
    col.className = 'time-drum-col';
    const drum = document.createElement('div');
    drum.className = 'time-drum' + (extraClass ? ' ' + extraClass : '');
    const inner = document.createElement('div');
    inner.className = 'time-drum-inner';
    const highlight = document.createElement('div');
    highlight.className = 'time-drum-highlight';
    drum.appendChild(highlight);
    drum.appendChild(inner);
    col.appendChild(drum);

    const ITEM_H = 44;
    const DRUM_H = 140;
    const VISIBLE = Math.floor(DRUM_H / ITEM_H);
    const PAD = Math.floor(VISIBLE / 2);

    // For looping drums, render 3x the items so drag feels infinite
    const renderItems = loop ? [...items, ...items, ...items] : items;
    const offset = loop ? items.length : 0; // center copy starts here

    for (let p = 0; p < PAD; p++) {
      const pad = document.createElement('div'); pad.className = 'time-drum-item'; inner.appendChild(pad);
    }
    renderItems.forEach(val => {
      const item = document.createElement('div');
      item.className = 'time-drum-item';
      item.textContent = val;
      inner.appendChild(item);
    });
    for (let p = 0; p < PAD; p++) {
      const pad = document.createElement('div'); pad.className = 'time-drum-item'; inner.appendChild(pad);
    }

    let selected = Math.max(0, Math.min(items.length - 1, initIdx));
    let startY = 0, isDragging = false;

    function getRenderIdx() { return loop ? offset + selected : selected; }
    function getTranslateY() { return -getRenderIdx() * ITEM_H; }

    function render(animate) {
      inner.style.transition = animate ? 'transform .2s cubic-bezier(.25,.8,.25,1)' : 'none';
      inner.style.transform = `translateY(${getTranslateY()}px)`;
      inner.querySelectorAll('.time-drum-item').forEach((el, i) => {
        el.classList.toggle('selected', i === PAD + getRenderIdx());
      });
    }

    function moveTo(n) {
      if (loop) {
        selected = ((n % items.length) + items.length) % items.length;
      } else {
        selected = Math.max(0, Math.min(items.length - 1, n));
      }
      render(true);
    }

    drum.addEventListener('pointerdown', e => {
      isDragging = true; startY = e.clientY;
      inner.style.transition = 'none';
      drum.setPointerCapture(e.pointerId);
    });
    drum.addEventListener('pointermove', e => {
      if (!isDragging) return;
      inner.style.transform = `translateY(${getTranslateY() + (e.clientY - startY)}px)`;
    });
    drum.addEventListener('pointerup', e => {
      if (!isDragging) return;
      isDragging = false;
      moveTo(selected - Math.round((e.clientY - startY) / ITEM_H));
    });
    drum.addEventListener('wheel', e => {
      e.preventDefault();
      moveTo(selected + (e.deltaY > 0 ? 1 : -1));
    }, { passive: false });

    render(false);
    return { drum: col, getSelected: () => items[selected] };
  }

  const hDrum  = makeDrum(hours,   initH,  '', true);
  const mDrum  = makeDrum(minutes, initM,  '', true);
  const apDrum = makeDrum(ampm,    initAP, 'ampm-drum', false);

  const colon = document.createElement('div');
  colon.className = 'time-colon';
  colon.textContent = ':';

  container.innerHTML = '';
  container.className = 'time-picker-wrap';
  container.appendChild(hDrum.drum);
  container.appendChild(colon);
  container.appendChild(mDrum.drum);
  container.appendChild(apDrum.drum);

  return {
    getTime: () => `${hDrum.getSelected()}:${mDrum.getSelected()} ${apDrum.getSelected()}`
  };
}

// â”€â”€ SHARED SCHEDULE POPUP (Edit only â€” Add has its own flow) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showSchedulePopup(title, initialTime, initialActivity, saveLabel, onSave, initialRepeat, hideRepeat) {
  const repeatOpts = [
    { val: 'daily',   label: 'ðŸ” Daily' },
    { val: 'weekly',  label: 'ðŸ“… Weekly' },
    { val: 'monthly', label: 'ðŸ—“ Monthly' },
    { val: 'yearly',  label: 'ðŸ“† Yearly' },
    { val: 'off',     label: 'â¸ One-time' },
  ];
  const curRepeat = (initialRepeat === 'once') ? 'off' : (initialRepeat || 'daily');
  const ov = document.createElement('div');
  ov.className = 'sched-edit-popup';
  ov.innerHTML = `<div class="sched-edit-sheet">
    <div class="modal-handle"></div>
    <div style="font-size:16px;font-weight:800;margin-bottom:12px">${title}</div>
    <div style="font-size:11px;font-family:var(--font-mono);color:var(--muted);text-transform:uppercase;letter-spacing:1px;margin-bottom:6px">Time</div>
    <div id="time-drum-root"></div>
    <div style="font-size:11px;font-family:var(--font-mono);color:var(--muted);text-transform:uppercase;letter-spacing:1px;margin-bottom:6px;margin-top:16px">Activity</div>
    <input type="text" id="sp-act" placeholder="Activity description" autocomplete="off" style="margin-bottom:12px"/>
    ${!hideRepeat ? `<div style="font-size:11px;font-family:var(--font-mono);color:var(--muted);text-transform:uppercase;letter-spacing:1px;margin-bottom:6px">Repeat</div>
    <select id="sp-repeat-sel" style="width:100%;background:var(--bg3);border:1px solid var(--border);border-radius:10px;padding:12px 14px;color:var(--text);font-family:var(--font-mono);font-size:14px;outline:none;margin-bottom:16px;cursor:pointer;appearance:none;-webkit-appearance:none;background-image:url('data:image/svg+xml,%3Csvg xmlns=\\'http://www.w3.org/2000/svg\\' width=\\'12\\' height=\\'12\\' viewBox=\\'0 0 24 24\\' fill=\\'none\\' stroke=\\'%23555570\\' stroke-width=\\'2\\'%3E%3Cpolyline points=\\'6 9 12 15 18 9\\'%3E%3C/polyline%3E%3C/svg%3E');background-repeat:no-repeat;background-position:right 14px center;box-sizing:border-box">
      ${repeatOpts.map(o => `<option value="${o.val}"${curRepeat===o.val?' selected':''}>${o.label}</option>`).join('')}
    </select>` : ''}
    <div style="display:flex;gap:10px">
      <button class="btn btn-ghost" id="sp-cancel" style="flex:1">Cancel</button>
      <button class="btn btn-green" id="sp-save" style="flex:2">${saveLabel}</button>
    </div>
  </div>`;
  document.body.appendChild(ov);

  const drum = buildTimeDrum('time-drum-root', initialTime);
  const actIn = ov.querySelector('#sp-act');
  // Set value after DOM is ready (not via html attribute to avoid encoding issues)
  actIn.value = initialActivity || '';
  setTimeout(() => actIn.focus(), 150);

  let selectedRepeat = curRepeat;
  const repSel = ov.querySelector('#sp-repeat-sel');
  if (repSel) repSel.addEventListener('change', () => { selectedRepeat = repSel.value; });

  const close = () => document.body.removeChild(ov);
  ov.addEventListener('click', e => { if (e.target === ov) close(); });
  ov.querySelector('#sp-cancel').addEventListener('click', close);
  ov.querySelector('#sp-save').addEventListener('click', () => {
    const t = drum ? drum.getTime() : actIn.value.trim();
    const a = actIn.value.trim();
    if (!a) { showToast('Enter an activity'); return; }
    close();
    onSave(t, a, selectedRepeat);
  });
  actIn.addEventListener('keydown', e => { if (e.key === 'Enter') ov.querySelector('#sp-save').click(); });
}

// â”€â”€ MINI CALENDAR UI HELPER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Returns an object { el, getSelected, setRange }
function buildMiniCalendar(opts = {}) {
  const { rangeFrom = null, rangeTo = null, selected = [] } = opts;
  const wrap = document.createElement('div');
  wrap.style.cssText = 'background:var(--bg3);border:1px solid var(--border);border-radius:14px;padding:14px;user-select:none';

  let viewYear, viewMonth;
  const selSet = new Set(selected);

  const todayISO = new Date().toISOString().slice(0,10);
  const now = new Date();
  viewYear = now.getFullYear();
  viewMonth = now.getMonth();

  function isoDate(y, m, d) {
    return `${y}-${String(m+1).padStart(2,'0')}-${String(d).padStart(2,'0')}`;
  }

  function isInRange(iso) {
    if (rangeFrom && iso < rangeFrom) return false;
    if (rangeTo && iso > rangeTo) return false;
    return true;
  }

  function render() {
    wrap.innerHTML = '';

    // Header: prev / month+year / next
    const hdr = document.createElement('div');
    hdr.style.cssText = 'display:flex;align-items:center;justify-content:space-between;margin-bottom:12px';
    const prevBtn = document.createElement('button');
    prevBtn.textContent = 'â€¹';
    prevBtn.style.cssText = 'background:var(--bg2);border:1px solid var(--border);border-radius:8px;color:var(--text);width:32px;height:32px;font-size:18px;cursor:pointer;display:flex;align-items:center;justify-content:center;padding:0';
    const nextBtn = document.createElement('button');
    nextBtn.textContent = 'â€º';
    nextBtn.style.cssText = prevBtn.style.cssText;
    const monthLabel = document.createElement('div');
    monthLabel.style.cssText = 'font-size:14px;font-weight:700;font-family:var(--font-mono)';
    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    monthLabel.textContent = `${monthNames[viewMonth]} ${viewYear}`;
    hdr.appendChild(prevBtn);
    hdr.appendChild(monthLabel);
    hdr.appendChild(nextBtn);
    wrap.appendChild(hdr);

    prevBtn.addEventListener('click', () => {
      viewMonth--; if (viewMonth < 0) { viewMonth = 11; viewYear--; }
      render();
    });
    nextBtn.addEventListener('click', () => {
      viewMonth++; if (viewMonth > 11) { viewMonth = 0; viewYear++; }
      render();
    });

    // Day headers
    const dayHdr = document.createElement('div');
    dayHdr.style.cssText = 'display:grid;grid-template-columns:repeat(7,1fr);gap:2px;margin-bottom:4px';
    ['S','M','T','W','T','F','S'].forEach(d => {
      const cell = document.createElement('div');
      cell.textContent = d;
      cell.style.cssText = 'text-align:center;font-size:10px;font-family:var(--font-mono);color:var(--muted);padding:2px 0';
      dayHdr.appendChild(cell);
    });
    wrap.appendChild(dayHdr);

    // Days grid
    const grid = document.createElement('div');
    grid.style.cssText = 'display:grid;grid-template-columns:repeat(7,1fr);gap:3px';

    const firstDay = new Date(viewYear, viewMonth, 1).getDay();
    const daysInMonth = new Date(viewYear, viewMonth + 1, 0).getDate();

    // Empty slots
    for (let i = 0; i < firstDay; i++) {
      const empty = document.createElement('div');
      grid.appendChild(empty);
    }

    for (let d = 1; d <= daysInMonth; d++) {
      const iso = isoDate(viewYear, viewMonth, d);
      const inRange = isInRange(iso);
      const isSel = selSet.has(iso);
      const isToday = iso === todayISO;

      const cell = document.createElement('div');
      cell.style.cssText = `
        text-align:center;padding:6px 2px;border-radius:8px;font-size:13px;font-family:var(--font-mono);font-weight:600;
        cursor:${inRange ? 'pointer' : 'default'};
        opacity:${inRange ? 1 : 0.25};
        background:${isSel ? 'rgba(0,120,255,0.35)' : (isToday ? 'rgba(0,255,136,0.08)' : 'transparent')};
        color:${isSel ? '#60aaff' : (isToday ? 'var(--accent)' : 'var(--text)')};
        border:${isSel ? '1.5px solid rgba(0,120,255,0.6)' : (isToday ? '1px solid rgba(0,255,136,0.3)' : '1px solid transparent')};
        transition:all .12s;
      `;
      cell.textContent = d;

      if (inRange) {
        cell.addEventListener('click', () => {
          if (selSet.has(iso)) selSet.delete(iso);
          else selSet.add(iso);
          render();
        });
      }
      grid.appendChild(cell);
    }
    wrap.appendChild(grid);

    // Selected count
    const cnt = document.createElement('div');
    cnt.style.cssText = 'margin-top:10px;font-size:11px;font-family:var(--font-mono);color:var(--muted);text-align:center';
    cnt.textContent = selSet.size > 0 ? `${selSet.size} date${selSet.size>1?'s':''} selected` : 'Tap dates to select';
    wrap.appendChild(cnt);
  }

  render();

  return {
    el: wrap,
    getSelected: () => Array.from(selSet).sort(),
  };
}

// â”€â”€ MINI DATE PICKER (single date, inline) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildSingleDatePicker(initialISO) {
  const wrap = document.createElement('div');
  wrap.style.cssText = 'background:var(--bg3);border:1px solid var(--border);border-radius:12px;padding:12px;user-select:none;';

  let viewYear, viewMonth, selected;
  const todayISO = new Date().toISOString().slice(0,10);
  const init = initialISO || todayISO;
  selected = init;
  viewYear = parseInt(init.slice(0,4));
  viewMonth = parseInt(init.slice(5,7)) - 1;

  function isoDate(y, m, d) {
    return `${y}-${String(m+1).padStart(2,'0')}-${String(d).padStart(2,'0')}`;
  }

  function render() {
    wrap.innerHTML = '';
    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

    const hdr = document.createElement('div');
    hdr.style.cssText = 'display:flex;align-items:center;justify-content:space-between;margin-bottom:10px';
    const prevBtn = document.createElement('button');
    prevBtn.innerHTML = 'â€¹';
    prevBtn.style.cssText = 'background:var(--bg2);border:1px solid var(--border);border-radius:6px;color:var(--text);width:28px;height:28px;font-size:16px;cursor:pointer;display:flex;align-items:center;justify-content:center;padding:0;flex-shrink:0';
    const nextBtn = document.createElement('button');
    nextBtn.innerHTML = 'â€º';
    nextBtn.style.cssText = prevBtn.style.cssText;
    const lbl = document.createElement('div');
    lbl.style.cssText = 'font-size:13px;font-weight:700;font-family:var(--font-mono)';
    lbl.textContent = `${monthNames[viewMonth]} ${viewYear}`;
    hdr.appendChild(prevBtn);
    hdr.appendChild(lbl);
    hdr.appendChild(nextBtn);
    wrap.appendChild(hdr);

    prevBtn.addEventListener('click', () => { viewMonth--; if (viewMonth<0){viewMonth=11;viewYear--;} render(); });
    nextBtn.addEventListener('click', () => { viewMonth++; if (viewMonth>11){viewMonth=0;viewYear++;} render(); });

    const dayHdr = document.createElement('div');
    dayHdr.style.cssText = 'display:grid;grid-template-columns:repeat(7,1fr);gap:2px;margin-bottom:2px';
    ['S','M','T','W','T','F','S'].forEach(d => {
      const c = document.createElement('div');
      c.textContent = d;
      c.style.cssText = 'text-align:center;font-size:9px;font-family:var(--font-mono);color:var(--muted)';
      dayHdr.appendChild(c);
    });
    wrap.appendChild(dayHdr);

    const grid = document.createElement('div');
    grid.style.cssText = 'display:grid;grid-template-columns:repeat(7,1fr);gap:2px';
    const firstDay = new Date(viewYear, viewMonth, 1).getDay();
    const daysInMonth = new Date(viewYear, viewMonth+1, 0).getDate();
    for (let i=0;i<firstDay;i++) grid.appendChild(document.createElement('div'));
    for (let d=1;d<=daysInMonth;d++) {
      const iso = isoDate(viewYear, viewMonth, d);
      const isSel = iso === selected;
      const cell = document.createElement('div');
      cell.textContent = d;
      cell.style.cssText = `text-align:center;padding:5px 1px;border-radius:6px;font-size:12px;font-family:var(--font-mono);font-weight:600;cursor:pointer;background:${isSel?'var(--accent)':'transparent'};color:${isSel?'var(--bg)':'var(--text)'};transition:all .1s`;
      cell.addEventListener('click', () => { selected = iso; render(); });
      grid.appendChild(cell);
    }
    wrap.appendChild(grid);
  }

  render();
  return { el: wrap, getSelected: () => selected };
}

// â”€â”€ ADD BLOCK FOR A SPECIFIC CALENDAR DATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Simplified sheet: pre-seeds the given date as a one-time block.
// User picks time + activity only. Repeat can be changed if desired.
function showAddScheduleSheetForDate(isoDate, onDone) {
  const ov = document.createElement('div');
  ov.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,.75);z-index:1000;display:flex;align-items:flex-end;justify-content:center;backdrop-filter:blur(6px);animation:fadeIn .2s ease';

  const sheet = document.createElement('div');
  sheet.style.cssText = 'background:var(--bg2);border-radius:20px 20px 0 0;padding:20px 20px calc(24px + env(safe-area-inset-bottom,0px));width:100%;max-width:480px;max-height:88dvh;overflow-y:auto;animation:slideUp .3s cubic-bezier(.34,1.56,.64,1)';
  ov.appendChild(sheet);

  // Format display date
  const d = new Date(isoDate + 'T00:00:00');
  const dayNames = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
  const mNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  const todayISO = new Date().toISOString().slice(0,10);
  const isToday = isoDate === todayISO;
  const dateLabel = isToday ? 'Today' : `${dayNames[d.getDay()]}, ${mNames[d.getMonth()]} ${d.getDate()}, ${d.getFullYear()}`;

  // Repeat options (once pre-selected)
  let selectedRepeat = 'once';

  sheet.innerHTML = `
    <div style="width:40px;height:4px;background:var(--border);border-radius:2px;margin:0 auto 18px"></div>
    <div style="display:flex;align-items:center;gap:10px;margin-bottom:18px">
      <div style="flex:1">
        <div style="font-size:18px;font-weight:800;letter-spacing:-.3px">Add Time Block</div>
        <div style="font-size:11px;font-family:var(--font-mono);color:var(--accent);margin-top:2px">ðŸ“… ${dateLabel}</div>
      </div>
    </div>
    <div style="font-size:10px;font-family:var(--font-mono);color:var(--muted);letter-spacing:1px;text-transform:uppercase;margin-bottom:6px">Activity</div>
    <input id="asfd-act" type="text" placeholder="What's this block?" autocomplete="off"
      style="width:100%;background:var(--bg3);border:1px solid var(--border);border-radius:10px;padding:13px 14px;color:var(--text);font-size:14px;font-family:var(--font-display);outline:none;margin-bottom:16px;transition:border-color .15s;box-sizing:border-box"/>
    <div style="font-size:10px;font-family:var(--font-mono);color:var(--muted);letter-spacing:1px;text-transform:uppercase;margin-bottom:8px">Time</div>
    <div id="asfd-drum-root" style="margin-bottom:16px"></div>
    <div style="font-size:10px;font-family:var(--font-mono);color:var(--muted);letter-spacing:1px;text-transform:uppercase;margin-bottom:8px">Repeat</div>
    <select id="asfd-repeat-sel" style="width:100%;background:var(--bg3);border:1px solid var(--border);border-radius:10px;padding:12px 14px;color:var(--text);font-family:var(--font-mono);font-size:14px;outline:none;margin-bottom:20px;cursor:pointer;appearance:none;-webkit-appearance:none;background-image:url('data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'12\' height=\'12\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'%23555570\' stroke-width=\'2\'%3E%3Cpolyline points=\'6 9 12 15 18 9\'%3E%3C/polyline%3E%3C/svg%3E');background-repeat:no-repeat;background-position:right 14px center;box-sizing:border-box">
      <option value="once" selected>1ï¸âƒ£ One-time</option>
      <option value="weekly">ðŸ“… Weekly</option>
      <option value="monthly">ðŸ—“ Monthly</option>
      <option value="daily">ðŸ” Daily</option>
      <option value="custom">ðŸ“† Custom Dates</option>
    </select>
    <div style="display:flex;gap:10px">
      <button id="asfd-cancel" class="btn btn-ghost" style="flex:1">Cancel</button>
      <button id="asfd-add" class="btn btn-green" style="flex:2">ï¼‹ Add Time Block</button>
    </div>`;

  document.body.appendChild(ov);

  // Wire activity input styling
  const actIn = sheet.querySelector('#asfd-act');
  actIn.addEventListener('focus', () => actIn.style.borderColor = 'var(--accent)');
  actIn.addEventListener('blur',  () => actIn.style.borderColor = 'var(--border)');
  setTimeout(() => actIn.focus(), 200);

  // Build time drum
  const drumInst = buildTimeDrumEl(sheet.querySelector('#asfd-drum-root'), '9:00 AM');

  // Wire repeat dropdown
  sheet.querySelector('#asfd-repeat-sel').addEventListener('change', e => { selectedRepeat = e.target.value; });

  const close = () => document.body.removeChild(ov);
  ov.addEventListener('click', e => { if (e.target === ov) close(); });
  sheet.querySelector('#asfd-cancel').addEventListener('click', close);

  sheet.querySelector('#asfd-add').addEventListener('click', () => {
    const activity = actIn.value.trim();
    if (!activity) { showToast('Enter an activity'); actIn.focus(); return; }

    if (!S.config) S.config = { schedule: [], habitDefinitions: {}, habitTracker: { enabled: true, snoozeOptions: [5, 10] } };
    if (!S.config.schedule) S.config.schedule = [];

    const time = drumInst ? drumInst.getTime() : '9:00 AM';
    const newItem = {
      _id: genItemId(),
      activity,
      time,
      repeat: selectedRepeat,
      createdOn: isoDate,
    };
    // For 'once', createdOn is the target date (already set above)
    // For custom, fall back to the add-schedule sheet for multi-date selection
    if (selectedRepeat === 'custom') {
      close();
      showAddScheduleSheet(() => { if (onDone) onDone(); });
      return;
    }
    S.config.schedule.push(newItem);
    try { S.config.schedule.sort((a, b) => schedDate(a.time) - schedDate(b.time)); } catch {}
    LS.set('lastConfig', S.config);
    saveScheduleToVault();
    syncAlarmsToSW();
    close();
    showToast('âœ“ Time Block added');
    if (onDone) onDone();
  });

  actIn.addEventListener('keydown', e => { if (e.key === 'Enter') sheet.querySelector('#asfd-add').click(); });
}

// â”€â”€ ADD SCHEDULE ENTRY â€” NEW COMPREHENSIVE FLOW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function genItemId() { return '_' + Math.random().toString(36).slice(2,10) + Date.now().toString(36); }

function showAddScheduleSheet(onDone, _forcedBlockType) {
  const today = new Date().toISOString().slice(0,10);
  const ov = document.createElement('div');
  ov.className = 'sched-edit-popup';
  ov.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,.75);z-index:1000;display:flex;align-items:flex-end;justify-content:center;backdrop-filter:blur(6px);animation:fadeIn .2s ease';

  // Auto-detect block type from active sub-tab
  const tabMap = { routine: 'routine', scheduled: 'scheduled', focused: 'open' };
  let blockType = _forcedBlockType || tabMap[_tbTab] || 'routine';

  // State
  let schedType = 'unlimited'; // 'unlimited' | 'limited'
  let repeatMode = 'daily'; // 'off','daily','weekly','monthly','custom'
  let limitFromISO = today;
  let limitToISO = '';
  let customDates = [];
  let perDateMode = 'same'; // 'same' | 'different'
  let savedActivity = ''; // preserve activity across rebuilds

  // For scheduled tab: auto-use selected calendar date if available
  const scheduledDate = (_tbTab === 'scheduled' && typeof _calSelectedISO !== 'undefined' && _calSelectedISO) ? _calSelectedISO : today;

  // Calendar pickers (built lazily)
  let fromPicker = null, toPicker = null, customCal = null;
  let sharedDrumInst = null;
  let perDateTimes = {}; // date -> time string

  function build() {
    const currentActVal = savedActivity;
    ov.innerHTML = '';
    const sheet = document.createElement('div');
    sheet.className = 'sched-edit-sheet';
    sheet.style.cssText = 'background:var(--bg2);border-radius:20px 20px 0 0;padding:20px 20px calc(20px + env(safe-area-inset-bottom,0px));width:100%;max-width:480px;max-height:92dvh;overflow-y:auto;';
    ov.appendChild(sheet);

    // â”€â”€ Header with block type badge â”€â”€
    const blockTypeMeta = { routine:{ emoji:'ðŸ”„', label:'Daily Routine' }, scheduled:{ emoji:'ðŸ“Œ', label:'Scheduled' }, open:{ emoji:'ðŸŒ€', label:'Focused Work' } };
    const btm = blockTypeMeta[blockType] || blockTypeMeta.routine;
    sheet.innerHTML = `<div class="modal-handle"></div>
      <div style="display:flex;align-items:center;gap:10px;margin-bottom:18px">
        <div style="font-size:18px;font-weight:800;flex:1">Add Time Block</div>
        <div style="font-size:11px;font-family:var(--font-mono);padding:4px 10px;border-radius:20px;background:rgba(0,255,136,.1);border:1px solid rgba(0,255,136,.25);color:var(--accent)">${btm.emoji} ${btm.label}</div>
      </div>`;

    // â”€â”€ Activity â”€â”€
    const actLabel = document.createElement('div');
    actLabel.style.cssText = 'font-size:11px;font-family:var(--font-mono);color:var(--muted);text-transform:uppercase;letter-spacing:1px;margin-bottom:6px';
    actLabel.textContent = 'Activity';
    sheet.appendChild(actLabel);

    const actInput = document.createElement('input');
    actInput.id = 'add-act-input';
    actInput.type = 'text';
    actInput.placeholder = blockType === 'open' ? 'What hobby or project?' : blockType === 'routine' ? 'e.g. Drink water, Morning stretchâ€¦' : 'e.g. Doctor appointmentâ€¦';
    actInput.autocomplete = 'off';
    actInput.value = currentActVal;
    actInput.style.cssText = 'width:100%;background:var(--bg3);border:1px solid var(--border);border-radius:10px;padding:13px 14px;color:var(--text);font-family:var(--font-display);font-size:14px;outline:none;margin-bottom:16px;transition:border-color .15s;box-sizing:border-box';
    actInput.addEventListener('focus', () => actInput.style.borderColor = 'var(--accent)');
    actInput.addEventListener('blur', () => actInput.style.borderColor = 'var(--border)');
    actInput.addEventListener('input', () => { savedActivity = actInput.value; });
    sheet.appendChild(actInput);
    if (!currentActVal) setTimeout(() => actInput.focus(), 150);

    // â”€â”€ Focused Work: Duration only â”€â”€
    if (blockType === 'open') {
      const durLabel = document.createElement('div');
      durLabel.style.cssText = 'font-size:11px;font-family:var(--font-mono);color:var(--muted);text-transform:uppercase;letter-spacing:1px;margin-bottom:6px';
      durLabel.textContent = 'Estimated Duration';
      sheet.appendChild(durLabel);
      const durRow = document.createElement('div');
      durRow.style.cssText = 'display:flex;gap:8px;margin-bottom:16px;align-items:center';
      const durInput = document.createElement('input');
      durInput.id = 'add-dur-input';
      durInput.type = 'number';
      durInput.min = '5'; durInput.max = '480'; durInput.step = '5';
      durInput.placeholder = '30';
      durInput.value = '30';
      durInput.style.cssText = 'flex:1;background:var(--bg3);border:1px solid var(--border);border-radius:10px;padding:12px 14px;color:var(--text);font-family:var(--font-mono);font-size:16px;outline:none;transition:border-color .15s;box-sizing:border-box';
      const durUnit = document.createElement('div');
      durUnit.style.cssText = 'font-size:13px;color:var(--muted);font-family:var(--font-mono);flex-shrink:0';
      durUnit.textContent = 'minutes';
      durRow.appendChild(durInput);
      durRow.appendChild(durUnit);
      sheet.appendChild(durRow);
    }

    // â”€â”€ Scheduled: show auto-selected date â”€â”€
    if (blockType === 'scheduled') {
      const dateLbl = document.createElement('div');
      dateLbl.style.cssText = 'font-size:11px;font-family:var(--font-mono);color:var(--muted);text-transform:uppercase;letter-spacing:1px;margin-bottom:6px';
      dateLbl.textContent = 'Date';
      sheet.appendChild(dateLbl);
      const dateDisplay = document.createElement('div');
      const d = new Date(scheduledDate + 'T00:00:00');
      const dayNames = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
      const mNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
      const isToday = scheduledDate === today;
      dateDisplay.style.cssText = 'background:var(--bg3);border:1px solid var(--border);border-radius:10px;padding:12px 14px;font-family:var(--font-mono);font-size:13px;color:var(--accent);margin-bottom:16px;font-weight:700';
      dateDisplay.textContent = isToday ? `ðŸ“… Today â€” ${dayNames[d.getDay()]}, ${mNames[d.getMonth()]} ${d.getDate()}` : `ðŸ“… ${dayNames[d.getDay()]}, ${mNames[d.getMonth()]} ${d.getDate()}, ${d.getFullYear()}`;
      sheet.appendChild(dateDisplay);
    }

    // â”€â”€ Routine: Repeat â”€â”€
    if (blockType === 'routine') {
      const repLabel = document.createElement('div');
      repLabel.style.cssText = 'font-size:11px;font-family:var(--font-mono);color:var(--muted);text-transform:uppercase;letter-spacing:1px;margin-bottom:8px';
      repLabel.textContent = 'Repeat';
      sheet.appendChild(repLabel);

      const repeatOpts = [
        { val:'daily',   label:'ðŸ” Daily' },
        { val:'weekly',  label:'ðŸ“… Weekly' },
        { val:'monthly', label:'ðŸ—“ Monthly' },
      ];
      if (!['daily','weekly','monthly'].includes(repeatMode)) repeatMode = 'daily';

      const repSelect = document.createElement('select');
      repSelect.style.cssText = 'width:100%;background:var(--bg3);border:1px solid var(--border);border-radius:10px;padding:12px 14px;color:var(--text);font-family:var(--font-mono);font-size:14px;outline:none;margin-bottom:16px;cursor:pointer;appearance:none;-webkit-appearance:none;background-image:url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'12\' height=\'12\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'%23555570\' stroke-width=\'2\'%3E%3Cpolyline points=\'6 9 12 15 18 9\'%3E%3C/polyline%3E%3C/svg%3E");background-repeat:no-repeat;background-position:right 14px center;box-sizing:border-box';
      repeatOpts.forEach(o => {
        const opt = document.createElement('option');
        opt.value = o.val; opt.textContent = o.label;
        if (repeatMode === o.val) opt.selected = true;
        repSelect.appendChild(opt);
      });
      repSelect.addEventListener('change', () => { savedActivity = actInput.value; repeatMode = repSelect.value; });
      sheet.appendChild(repSelect);
    }

    // â”€â”€ Time Section (for Routine and Scheduled only) â”€â”€
    const timeSectionWrap = document.createElement('div');
    sheet.appendChild(timeSectionWrap);

    function buildTimeSection() {
      timeSectionWrap.innerHTML = '';
      if (blockType === 'open') return; // no time for focused work

      const timeLabel = document.createElement('div');
      timeLabel.style.cssText = 'font-size:11px;font-family:var(--font-mono);color:var(--muted);text-transform:uppercase;letter-spacing:1px;margin-bottom:8px;margin-top:4px';
      timeLabel.textContent = 'Time';
      timeSectionWrap.appendChild(timeLabel);

      const drumWrap = document.createElement('div');
      drumWrap.id = 'time-drum-root-single';
      timeSectionWrap.appendChild(drumWrap);
      requestAnimationFrame(() => { sharedDrumInst = buildTimeDrumEl(drumWrap, '6:00 AM'); });
    }

    buildTimeSection();

    // â”€â”€ Footer Buttons â”€â”€
    const footer = document.createElement('div');
    footer.style.cssText = 'display:flex;gap:10px;margin-top:20px;padding-top:12px;border-top:1px solid var(--border)';
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'btn btn-ghost';
    cancelBtn.style.cssText = 'flex:1';
    cancelBtn.textContent = 'Cancel';
    const addBtn = document.createElement('button');
    addBtn.className = 'btn btn-green';
    addBtn.style.cssText = 'flex:2';
    addBtn.textContent = 'ï¼‹ Add Time Block';
    footer.appendChild(cancelBtn);
    footer.appendChild(addBtn);
    sheet.appendChild(footer);

    const close = () => document.body.removeChild(ov);
    cancelBtn.addEventListener('click', close);
    ov.addEventListener('click', e => { if (e.target === ov) close(); });

    addBtn.addEventListener('click', () => {
      const activity = actInput.value.trim();
      if (!activity) { showToast('Enter an activity'); actInput.focus(); return; }

      if (!S.config) S.config = { schedule: [], habitDefinitions: {}, habitTracker: { enabled: true, snoozeOptions: [5, 10] } };

      const baseItem = {
        _id: genItemId(),
        activity,
        blockType: blockType,
        createdOn: today,
      };

      if (blockType === 'open') {
        const durVal = parseInt(sheet.querySelector('#add-dur-input')?.value) || 30;
        baseItem.duration = durVal;
        baseItem.time = '8:00 AM';
        baseItem.repeat = 'daily';
        baseItem.canCarryOver = true;
      } else if (blockType === 'scheduled') {
        // Scheduled: one-time on selected calendar date
        baseItem.time = sharedDrumInst ? sharedDrumInst.getTime() : '9:00 AM';
        baseItem.repeat = 'once';
        baseItem.createdOn = scheduledDate;
      } else {
        // Routine
        baseItem.time = sharedDrumInst ? sharedDrumInst.getTime() : '6:00 AM';
        baseItem.repeat = repeatMode;
      }

      S.config.schedule.push(baseItem);
      try { S.config.schedule.sort((x, y) => schedDate(x.time) - schedDate(y.time)); } catch {}
      LS.set('lastConfig', S.config);
      saveScheduleToVault();
      syncAlarmsToSW();
      close();
      onDone();
      showToast('âœ“ Time Block added');
    });
  }

  document.body.appendChild(ov);
  build();
}

// â”€â”€ DRUM BUILDER (by element reference, not ID) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildTimeDrumEl(container, initialTime) {
  const hours   = ['12','1','2','3','4','5','6','7','8','9','10','11'];
  const minutes = Array.from({length:60}, (_,i) => String(i).padStart(2,'0'));
  const ampm    = ['AM','PM'];

  let initH = 6, initM = 0, initAP = 0;
  if (initialTime) {
    const m = initialTime.match(/(\d+):(\d+)\s*(AM|PM)/i);
    if (m) {
      initH  = parseInt(m[1]) % 12;
      initM  = Math.round(parseInt(m[2]) / 5);
      initAP = m[3].toUpperCase() === 'PM' ? 1 : 0;
    }
  }

  function makeDrum(items, initIdx, extraClass, loop) {
    const col = document.createElement('div');
    col.className = 'time-drum-col';
    const drum = document.createElement('div');
    drum.className = 'time-drum' + (extraClass ? ' ' + extraClass : '');
    const inner = document.createElement('div');
    inner.className = 'time-drum-inner';
    const highlight = document.createElement('div');
    highlight.className = 'time-drum-highlight';
    drum.appendChild(highlight);
    drum.appendChild(inner);
    col.appendChild(drum);

    const ITEM_H = 44, DRUM_H = 140;
    const VISIBLE = Math.floor(DRUM_H / ITEM_H);
    const PAD = Math.floor(VISIBLE / 2);
    const renderItems = loop ? [...items,...items,...items] : items;
    const offset = loop ? items.length : 0;

    for (let p=0;p<PAD;p++) { const pd=document.createElement('div'); pd.className='time-drum-item'; inner.appendChild(pd); }
    renderItems.forEach(val => {
      const it=document.createElement('div'); it.className='time-drum-item'; it.textContent=val; inner.appendChild(it);
    });
    for (let p=0;p<PAD;p++) { const pd=document.createElement('div'); pd.className='time-drum-item'; inner.appendChild(pd); }

    let selected=Math.max(0,Math.min(items.length-1,initIdx));
    let startY=0,isDragging=false;
    function getRenderIdx(){ return loop?offset+selected:selected; }
    function getTranslateY(){ return -getRenderIdx()*ITEM_H; }
    function render(animate){
      inner.style.transition=animate?'transform .2s cubic-bezier(.25,.8,.25,1)':'none';
      inner.style.transform=`translateY(${getTranslateY()}px)`;
      inner.querySelectorAll('.time-drum-item').forEach((el,i)=>el.classList.toggle('selected',i===PAD+getRenderIdx()));
    }
    function moveTo(n){
      selected=loop?(((n%items.length)+items.length)%items.length):Math.max(0,Math.min(items.length-1,n));
      render(true);
    }
    drum.addEventListener('pointerdown',e=>{ isDragging=true;startY=e.clientY;inner.style.transition='none';drum.setPointerCapture(e.pointerId); });
    drum.addEventListener('pointermove',e=>{ if(!isDragging)return; inner.style.transform=`translateY(${getTranslateY()+(e.clientY-startY)}px)`; });
    drum.addEventListener('pointerup',e=>{ if(!isDragging)return;isDragging=false;moveTo(selected-Math.round((e.clientY-startY)/ITEM_H)); });
    drum.addEventListener('wheel',e=>{ e.preventDefault();moveTo(selected+(e.deltaY>0?1:-1)); },{passive:false});
    render(false);
    return { col, getSelected: ()=>items[selected] };
  }

  const hDrum=makeDrum(hours,initH,'',true);
  const mDrum=makeDrum(minutes,initM,'',true);
  const apDrum=makeDrum(ampm,initAP,'ampm-drum',false);
  const colon=document.createElement('div');
  colon.className='time-colon'; colon.textContent=':';
  container.innerHTML='';
  container.className='time-picker-wrap';
  container.appendChild(hDrum.col);
  container.appendChild(colon);
  container.appendChild(mDrum.col);
  container.appendChild(apDrum.col);
  return { getTime: ()=>`${hDrum.getSelected()}:${mDrum.getSelected()} ${apDrum.getSelected()}` };
}

// â”€â”€ EDIT SINGLE SCHEDULE ENTRY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showEditSchedulePopup(currentTime, currentActivity, currentRepeat, onSave, blockType) {
  showSchedulePopup('Edit Entry', currentTime, currentActivity, 'âœ“ Save', onSave, currentRepeat || 'daily', blockType === 'scheduled');
}

async function saveScheduleToVault() {
  // Always persist to localStorage with a timestamp so loadTemplate knows not to overwrite
  LS.set('lastConfig', S.config);
  LS.set('lastScheduleEdit', Date.now());

  if (!S.vaultDirHandle || !S.config) return;
  try {
    // Find the config .md file
    const searchDir = (await getDataDir()) || S.vaultDirHandle;
    for await (const entry of searchDir.values()) {
      if (entry.kind === 'file' && entry.name.endsWith('.md') && !entry.name.match(/^\d{16}HT\.md$/)) {
        const file = await entry.getFile();
        const originalText = await file.text();

        // Rebuild the frontmatter schedule block while preserving everything else
        const newText = rebuildScheduleInMd(originalText, S.config.schedule);
        if (newText === null) continue;

        // Write backup BEFORE overwriting the main file
        await writeScheduleBackup(originalText, entry.name);

        // Write the updated config back to the main .md file
        const fh = await searchDir.getFileHandle(entry.name, { create: false });
        const w = await fh.createWritable();
        await w.write(newText);
        await w.close();
        return;
      }
    }
  } catch(e) {
    console.warn('Schedule vault write failed (localStorage used):', e.message);
  }
}

// Write a rotating backup (max 3) into vault/backup/ folder
async function writeScheduleBackup(originalText, sourceFilename) {
  try {
    // Get or create vault/backup/ directory
    const backupDir = await S.vaultDirHandle.getDirectoryHandle('_backup', { create: true });

    // Collect existing schedule backup files, sorted oldest-first
    const existing = [];
    for await (const entry of backupDir.values()) {
      if (entry.kind === 'file' && entry.name.startsWith('schedule-backup-') && entry.name.endsWith('.md')) {
        existing.push(entry.name);
      }
    }
    existing.sort(); // ISO timestamp prefix = chronological sort

    // Delete oldest backups if we already have 3 or more
    while (existing.length >= 3) {
      const oldest = existing.shift();
      try { await backupDir.removeEntry(oldest); } catch {}
    }

    // Write new backup file named with current timestamp
    const ts = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
    const backupName = `schedule-backup-${ts}.md`;
    const bfh = await backupDir.getFileHandle(backupName, { create: true });
    const bw = await bfh.createWritable();
    await bw.write(`# Schedule Backup â€” ${new Date().toLocaleString()}\n# Source: ${sourceFilename}\n\n${originalText}`);
    await bw.close();
  } catch(e) {
    console.warn('Backup write failed:', e.message);
  }
}

// Rebuild the schedule block inside .md frontmatter (line-by-line, no regex gotchas)
function rebuildScheduleInMd(text, schedule) {
  const fmMatch = text.match(/^(---\n)([\s\S]+?)(\n---)([\s\S]*)$/);
  if (!fmMatch) return null;
  const [, open, yaml, close, body] = fmMatch;
  const schedLines = ['schedule:'];
  schedule.forEach(item => {
    schedLines.push(`- time: '${item.time}'`);
    schedLines.push(`  activity: '${item.activity}'`);
    if (item.repeat && item.repeat !== 'daily') schedLines.push(`  repeat: ${item.repeat}`);
    if (item.createdOn) schedLines.push(`  createdOn: '${item.createdOn}'`);
    if (item.customDates && item.customDates.length) schedLines.push(`  customDates: '${JSON.stringify(item.customDates)}'`);
    if (item.limitFrom) schedLines.push(`  limitFrom: '${item.limitFrom}'`);
    if (item.limitTo) schedLines.push(`  limitTo: '${item.limitTo}'`);
    if (item.perDateTimes) schedLines.push(`  perDateTimes: '${JSON.stringify(item.perDateTimes)}'`);
  });
  const lines = yaml.split('\n'); const out = []; let inBlock = false;
  for (const line of lines) {
    if (/^schedule:\s*$/.test(line)) { inBlock = true; out.push(...schedLines); continue; }
    if (inBlock) {
      // Skip ALL schedule item lines: indented, list items starting with -, or blank
      if (/^[\s-]/.test(line) || line.trim() === '') continue;
      inBlock = false;
    }
    out.push(line);
  }
  if (!out.some(l => l.startsWith('schedule:'))) out.push(...schedLines);
  return open + out.join('\n') + close + body;
}

// â”€â”€ VAULT BACKUP VIEWER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function showVaultBackups() {
  const ov = document.createElement('div'); ov.className = 'modal-overlay';
  ov.innerHTML = `<div class="modal"><div class="modal-handle"></div>
    <div class="modal-title">Schedule Backups</div>
    <div id="backup-list-body"><div class="empty-state" style="padding:24px 0">Loadingâ€¦</div></div>
    <button class="btn btn-ghost" style="width:100%;margin-top:16px" id="bv-close">Close</button>
  </div>`;
  document.body.appendChild(ov);
  const close = () => document.body.removeChild(ov);
  ov.addEventListener('click', e => { if (e.target === ov) close(); });
  ov.querySelector('#bv-close').addEventListener('click', close);

  const body = ov.querySelector('#backup-list-body');

  try {
    const backupDir = await S.vaultDirHandle.getDirectoryHandle('_backup', { create: false });
    const files = [];
    for await (const entry of backupDir.values()) {
      if (entry.kind === 'file' && entry.name.startsWith('schedule-backup-') && entry.name.endsWith('.md')) {
        files.push(entry);
      }
    }
    files.sort((a, b) => b.name.localeCompare(a.name)); // newest first

    if (!files.length) {
      body.innerHTML = `<div class="empty-state" style="padding:24px 0">No backups yet.<br><small style="font-size:11px">Backups are created automatically when you save schedule changes.</small></div>`;
      return;
    }

    body.innerHTML = files.map((f, i) => {
      // Parse timestamp from filename: schedule-backup-2024-01-15T10-30-00.md
      const tsPart = f.name.replace('schedule-backup-', '').replace('.md', '').replace(/T/, ' ').replace(/-/g, (m, o) => o > 10 ? ':' : '-');
      return `<div class="s-row" style="flex-direction:column;align-items:stretch;gap:8px">
        <div style="display:flex;align-items:center;justify-content:space-between">
          <div><div class="s-label" style="font-size:13px">Backup ${files.length - i}</div>
          <div class="s-sub">${f.name}</div></div>
          <button class="btn btn-ghost" style="min-height:36px;padding:6px 14px;font-size:13px" data-backup-idx="${i}">Restore</button>
        </div>
      </div>`;
    }).join('');

    // Wire restore buttons
    body.querySelectorAll('[data-backup-idx]').forEach(btn => {
      btn.addEventListener('click', async () => {
        if (!confirm('Restore this backup? Your current schedule will be replaced.')) return;
        try {
          const f = files[parseInt(btn.dataset.backupIdx)];
          const text = (await (await f.getFile()).text()).replace(/\r\n/g, '\n').replace(/\r/g, '\n');
          // The backup file starts with comment lines then the original .md content
          // Strip the comment header lines we added
          const mdStart = text.indexOf('---\n');
          if (mdStart === -1) { showToast('Could not parse backup file'); return; }
          const mdText = text.slice(mdStart);
          const cfg = parseMd(mdText);
          if (!cfg?.schedule?.length) { showToast('No schedule found in backup'); return; }
          if (!S.config) S.config = { schedule: [], habitDefinitions: {}, habitTracker: { enabled: true, snoozeOptions: [5, 10] } };
          S.config.schedule = cfg.schedule;
          LS.set('lastConfig', S.config);
          LS.set('lastScheduleEdit', Date.now());
          renderAll();
          showToast('â†© Schedule restored from backup');
          close();
        } catch(e) {
          showToast('Restore failed: ' + e.message);
        }
      });
    });

  } catch(e) {
    body.innerHTML = `<div class="empty-state" style="padding:24px 0">No backup folder found yet.<br><small style="font-size:11px;font-family:var(--font-mono)">_backup/ is created automatically on first save.</small></div>`;
  }
}

// â”€â”€ OUTPUT FORMAT HELPER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Replaces Obsidian-style {{date:FORMAT}} tokens in a path template.
// Supports: YYYY MM DD HH mm ss (and any combo e.g. YYYYMMDDHHmmss)
function applyDateFormat(template, d) {
  return template.replace(/\{\{date:([^}]+)\}\}/g, (_, fmt) => {
    return fmt
      .replace('YYYY', String(d.getFullYear()))
      .replace('MM',   String(d.getMonth()+1).padStart(2,'0'))
      .replace('DD',   String(d.getDate()).padStart(2,'0'))
      .replace('HH',   String(d.getHours()).padStart(2,'0'))
      .replace('mm',   String(d.getMinutes()).padStart(2,'0'))
      .replace('ss',   String(d.getSeconds()).padStart(2,'0'));
  });
}

async function pickLogTemplateFile() {
  try {
    // showOpenFilePicker lets user select a single .md file
    const [fh] = await window.showOpenFilePicker({
      id: 'logTemplate',
      types: [{ description: 'Markdown', accept: { 'text/markdown': ['.md'] } }],
      excludeAcceptAllOption: true,
    });
    S.logTemplateHandle = fh;
    LS.set('logTemplateName', fh.name);
    showToast(`ðŸ“„ ${fh.name} set as log template`);
    return true;
  } catch(e) {
    if (e.name !== 'AbortError') showToast('Could not open file');
    return false;
  }
}

async function restoreLogTemplateHandle() {
  // Derived from vault via deriveSubHandles() â€” nothing to restore from IDB separately
  if (!S.logTemplateHandle && S.vaultDirHandle && S.logOutputDirHandle) {
    try {
      S.logTemplateHandle = await S.logOutputDirHandle.getFileHandle('_Daily_Log_Template.md', { create: false });
    } catch {}
  }
}

async function restoreLogOutputHandle() {
  // Derived from vault via deriveSubHandles() â€” nothing to restore from IDB separately
}

// Called to ensure log output handle is ready before writing
async function _activateLogOutputHandle() {
  if (S.logOutputDirHandle) return true;
  if (!S.vaultDirHandle) return false;
  // Derive on demand if not yet set
  S.logOutputDirHandle = await _navSubDir(S.vaultDirHandle, VAULT_PATHS.logOutput, true);
  return !!S.logOutputDirHandle;
}

async function pickLogOutputFolder() {
  if (!S.vaultDirHandle) { showToast('Connect a vault first in Settings'); return false; }
  S.logOutputDirHandle = await _navSubDir(S.vaultDirHandle, VAULT_PATHS.logOutput, true);
  if (S.logOutputDirHandle) {
    LS.set('logOutputFolderName', VAULT_PATHS.logOutput.join('/'));
    showToast(`ðŸ“ Log output: ${VAULT_PATHS.logOutput.join('/')}`);
    return true;
  }
  return false;
}

// â”€â”€ EVENTS SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Events are stored as individual .md files in the events folder.
// Each file has YAML frontmatter: title, date (YYYY-MM-DD), time (HH:MM optional), note

async function pickEventsFolder() {
  if (!S.vaultDirHandle) { showToast('Connect a vault first in Settings'); return false; }
  S.eventsDirHandle = await _navSubDir(S.vaultDirHandle, VAULT_PATHS.events, true);
  if (S.eventsDirHandle) {
    LS.set('eventsFolderName', VAULT_PATHS.events.join('/'));
    showToast(`âœ“ Events folder: ${VAULT_PATHS.events.join('/')}`);
    return true;
  }
  return false;
}

async function restoreEventsHandle() {
  // Derived from vault via deriveSubHandles() â€” nothing to restore from IDB separately
}

async function loadEvents() {
  if (!S.eventsDirHandle) return [];
  try {
    const p = await S.eventsDirHandle.requestPermission({ mode: 'readwrite' });
    if (p !== 'granted') return [];
    const events = [];
    for await (const entry of S.eventsDirHandle.values()) {
      if (entry.kind !== 'file' || !entry.name.endsWith('.md')) continue;
      try {
        const file = await entry.getFile();
        const text = await file.text();
        const titleM  = text.match(/^title:\s*(.+)/m);
        const dateM   = text.match(/^date:\s*(\d{4}-\d{2}-\d{2})/m);
        const timeM   = text.match(/^time:\s*(.+)/m);
        const noteM   = text.match(/^note:\s*(.+)/m);
        if (!titleM || !dateM) continue;
        const body = text.replace(/^---[\s\S]*?---\s*/m, '').trim();
        events.push({
          filename: entry.name,
          handle: entry,
          title: titleM[1].trim().replace(/^["']|["']$/g, ''),
          date: dateM[1].trim(),
          time: timeM ? timeM[1].trim() : '',
          note: noteM ? noteM[1].trim().replace(/^["']|["']$/g, '') : body.slice(0, 80),
        });
      } catch {}
    }
    events.sort((a, b) => a.date.localeCompare(b.date));
    return events;
  } catch { return []; }
}

async function saveEvent(ev, oldFilename) {
  if (!S.eventsDirHandle) { showToast('No events folder set'); return false; }
  const p = await S.eventsDirHandle.requestPermission({ mode: 'readwrite' });
  if (p !== 'granted') { showToast('Permission denied'); return false; }
  const slug = ev.title.replace(/[^a-z0-9]/gi, '_').toLowerCase().slice(0, 30);
  const filename = oldFilename || `${ev.date.replace(/-/g,'')}_${slug}.md`;
  const content = `---\ntitle: ${JSON.stringify(ev.title)}\ndate: ${ev.date}\n${ev.time ? 'time: ' + ev.time + '\n' : ''}${ev.note ? 'note: ' + JSON.stringify(ev.note) + '\n' : ''}---\n${ev.note || ''}`;
  try {
    if (oldFilename && oldFilename !== filename) {
      try { await S.eventsDirHandle.removeEntry(oldFilename); } catch {}
    }
    const fh = await S.eventsDirHandle.getFileHandle(filename, { create: true });
    const w = await fh.createWritable(); await w.write(content); await w.close();
    return true;
  } catch (e) { showToast('\u26a0 Save failed'); return false; }
}

async function deleteEvent(filename) {
  if (!S.eventsDirHandle) return;
  try { await S.eventsDirHandle.removeEntry(filename); } catch {}
}

function showAddEventSheet(existingEvent, onSaved) {
  const isEdit = !!existingEvent;
  const todayISO = new Date().toISOString().slice(0, 10);
  const ov = document.createElement('div'); ov.className = 'modal-overlay';
  ov.innerHTML = `<div class="modal" style="max-width:340px">
    <div class="modal-handle"></div>
    <div style="font-size:16px;font-weight:800;margin-bottom:16px">${isEdit ? 'âœŽ Edit Event' : 'ï¼‹ New Event'}</div>
    <div style="display:flex;flex-direction:column;gap:10px">
      <input id="ev-title" type="text" placeholder="Event title" value="${isEdit ? existingEvent.title.replace(/"/g,'&quot;') : ''}"
        style="background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:10px 12px;color:var(--text);font-family:var(--font-mono);font-size:14px;outline:none"/>
      <div style="display:flex;gap:8px">
        <div style="flex:1">
          <div style="font-size:10px;font-family:var(--font-mono);color:var(--muted);margin-bottom:4px;letter-spacing:.5px">DATE</div>
          <input id="ev-date" type="date" value="${isEdit ? existingEvent.date : todayISO}"
            style="width:100%;background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:9px 10px;color:var(--text);font-family:var(--font-mono);font-size:13px;outline:none;color-scheme:dark"/>
        </div>
        <div style="flex:1">
          <div style="font-size:10px;font-family:var(--font-mono);color:var(--muted);margin-bottom:4px;letter-spacing:.5px">TIME (optional)</div>
          <input id="ev-time" type="time" value="${isEdit ? existingEvent.time : ''}"
            style="width:100%;background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:9px 10px;color:var(--text);font-family:var(--font-mono);font-size:13px;outline:none;color-scheme:dark"/>
        </div>
      </div>
      <textarea id="ev-note" placeholder="Notes (optional)" rows="3"
        style="background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:10px 12px;color:var(--text);font-family:var(--font-mono);font-size:13px;outline:none;resize:vertical">${isEdit ? (existingEvent.note||'').replace(/</g,'&lt;') : ''}</textarea>
    </div>
    <div style="display:flex;gap:8px;margin-top:14px">
      <button class="btn btn-green" id="ev-save" style="flex:2">${isEdit ? 'âœ“ Save' : 'ï¼‹ Add'}</button>
    </div>
  </div>`;
  document.body.appendChild(ov);
  ov.addEventListener('click', e => { if (e.target === ov) ov.remove(); });
  setTimeout(() => ov.querySelector('#ev-title').focus(), 80);

  ov.querySelector('#ev-save').addEventListener('click', async () => {
    const title = ov.querySelector('#ev-title').value.trim();
    const date  = ov.querySelector('#ev-date').value;
    const time  = ov.querySelector('#ev-time').value;
    const note  = ov.querySelector('#ev-note').value.trim();
    if (!title) { showToast('Enter a title'); return; }
    if (!date)  { showToast('Pick a date'); return; }
    const btn = ov.querySelector('#ev-save');
    btn.disabled = true; btn.textContent = 'Savingâ€¦';
    const ok = await saveEvent({ title, date, time, note }, isEdit ? existingEvent.filename : null);
    if (ok) { ov.remove(); if (onSaved) onSaved(); showToast(isEdit ? 'âœ“ Event updated' : 'âœ“ Event added'); }
    else { btn.disabled = false; btn.textContent = isEdit ? 'âœ“ Save' : 'ï¼‹ Add'; }
  });
}

async function renderEventsCard() {
  const card = document.getElementById('card-events');
  if (!card) return;
  const body = card.querySelector('.card-body');
  if (!body) return;

  if (!S.eventsDirHandle) {
    body.innerHTML = `<div class="empty-state" style="padding:16px 0;line-height:1.8;font-size:12px;font-family:var(--font-mono);color:var(--muted);text-align:center">
      No events folder set<br>
      <button onclick="showSettings()" style="margin-top:8px;padding:6px 14px;background:var(--bg3);border:1px solid var(--border);border-radius:8px;color:var(--text);font-size:11px;font-family:var(--font-mono);cursor:pointer">âš™ Open Settings</button>
    </div>`;
    return;
  }

  const events = await loadEvents();
  const now = new Date(); now.setHours(0,0,0,0);
  const upcoming = events.filter(e => new Date(e.date + 'T00:00:00') >= now);
  const past = events.filter(e => new Date(e.date + 'T00:00:00') < now).slice(-2).reverse();

  function daysUntil(dateStr) {
    const d = new Date(dateStr + 'T00:00:00');
    const diff = Math.round((d - now) / 86400000);
    if (diff === 0) return 'Today';
    if (diff === 1) return 'Tomorrow';
    if (diff < 7) return `In ${diff} days`;
    if (diff < 30) return `In ${Math.round(diff/7)}w`;
    if (diff < 365) return `In ${Math.round(diff/30)}mo`;
    return `${d.toLocaleDateString(undefined,{month:'short',day:'numeric'})}`;
  }

  function eventHTML(ev, isPast) {
    const ds = daysUntil(ev.date);
    return `<div class="event-row${isPast?' event-past':''}" data-filename="${ev.filename}" style="display:flex;align-items:flex-start;gap:10px;padding:8px 10px;margin-bottom:4px;background:var(--bg3);border-radius:10px;border:1px solid var(--border);cursor:pointer;transition:background .1s">
      <div style="flex-shrink:0;text-align:center;min-width:36px">
        <div style="font-size:10px;font-family:var(--font-mono);color:${isPast?'var(--muted)':'var(--accent)'};font-weight:700">${isPast ? new Date(ev.date+'T00:00:00').toLocaleDateString(undefined,{month:'short',day:'numeric'}) : ds}</div>
        ${ev.time ? `<div style="font-size:9px;font-family:var(--font-mono);color:var(--muted)">${ev.time}</div>` : ''}
      </div>
      <div style="flex:1;min-width:0">
        <div style="font-size:13px;font-weight:700;color:${isPast?'var(--muted)':'var(--text)'};white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${ev.title}</div>
        ${ev.note ? `<div style="font-size:11px;font-family:var(--font-mono);color:var(--muted);margin-top:2px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${ev.note}</div>` : ''}
      </div>
    </div>`;
  }

  let html = '';
  if (upcoming.length === 0 && past.length === 0) {
    html = `<div style="text-align:center;font-size:12px;font-family:var(--font-mono);color:var(--muted);padding:12px 0">No upcoming events</div>`;
  } else {
    if (upcoming.length) html += upcoming.map(e => eventHTML(e, false)).join('');
    if (past.length) {
      html += `<div style="font-size:9px;font-family:var(--font-mono);color:var(--muted);letter-spacing:1px;text-transform:uppercase;padding:6px 2px 2px">Past</div>`;
      html += past.map(e => eventHTML(e, true)).join('');
    }
  }
  html += `<button id="ev-add-btn" class="btn btn-ghost" style="width:100%;margin-top:6px;font-size:12px">ï¼‹ Add Event</button>`;
  body.innerHTML = html;

  body.querySelectorAll('.event-row').forEach(row => {
    row.addEventListener('click', async () => {
      const filename = row.dataset.filename;
      const ev = events.find(e => e.filename === filename);
      if (!ev) return;
      // Show detail/edit popup
      const dov = document.createElement('div'); dov.className = 'modal-overlay';
      const ds2 = daysUntil(ev.date);
      dov.innerHTML = `<div class="modal" style="max-width:340px">
        <div class="modal-handle"></div>
        <div style="font-size:18px;font-weight:800;margin-bottom:6px">${ev.title}</div>
        <div style="font-size:12px;font-family:var(--font-mono);color:var(--accent);margin-bottom:4px">${ev.date}${ev.time?' Â· '+ev.time:''} Â· <span style="color:var(--muted)">${ds2}</span></div>
        ${ev.note ? `<div style="font-size:13px;color:var(--muted);font-family:var(--font-mono);margin:10px 0;line-height:1.6">${ev.note.replace(/</g,'&lt;')}</div>` : ''}
        <div style="display:flex;gap:8px;margin-top:14px">
          <button class="btn btn-ghost" style="flex:1" id="dev-edit">âœŽ Edit</button>
          <button class="btn btn-ghost" style="flex:1;color:var(--danger);border-color:rgba(255,68,102,.3)" id="dev-del">âœ• Delete</button>
          <button class="btn btn-ghost" style="flex:1" id="dev-close">Close</button>
        </div>
      </div>`;
      document.body.appendChild(dov);
      const dclose = () => dov.remove();
      dov.addEventListener('click', e => { if (e.target === dov) dclose(); });
      dov.querySelector('#dev-close').addEventListener('click', dclose);
      dov.querySelector('#dev-edit').addEventListener('click', () => { dclose(); showAddEventSheet(ev, () => renderEventsCard()); });
      dov.querySelector('#dev-del').addEventListener('click', async () => {
        if (!confirm(`Delete "${ev.title}"?`)) return;
        await deleteEvent(ev.filename);
        dclose();
        renderEventsCard();
        showToast('Event deleted');
      });
    });
  });

  body.querySelector('#ev-add-btn')?.addEventListener('click', () => {
    showAddEventSheet(null, () => renderEventsCard());
  });
}

// â”€â”€ END EVENTS SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€ LOG WRITING HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function sanitizeForYAML(input) {
  if (typeof input !== 'string') return input;
  const needsQuoting = /[:"'#\[\]{}&*!|>%@`]/.test(input) ||
    input.trim() !== input ||
    /^[0-9]/.test(input) ||
    /^(true|false|null|yes|no)$/i.test(input);
  if (!needsQuoting) return input;
  return '"' + input.replace(/"/g, '\\"') + '"';
}

function extractTagsFromText(text) {
  const tags = (text.match(/#[\w]+/g) || []).map(t => t.slice(1));
  const cleaned = text.replace(/#[\w]+/g, '').replace(/\s{2,}/g, ' ').trim();
  return { tags, cleaned };
}

function fmtDateYMD(d) {
  return d.getFullYear() + '-' +
    String(d.getMonth()+1).padStart(2,'0') + '-' +
    String(d.getDate()).padStart(2,'0');
}
function fmtTimeHMA(d) {
  let h = d.getHours(), m = d.getMinutes();
  const ap = h >= 12 ? 'pm' : 'am';
  h = h % 12 || 12;
  return String(h).padStart(2,'0') + ':' + String(m).padStart(2,'0') + ' ' + ap;
}

// â”€â”€ FILE WRITE HELPER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Chrome Android PWA bug: createWritable() throws InvalidStateError on some handles.
// Fix: call getFile() first to "activate" the handle, then createWritable().
// If that also fails, fall back to truncate+write via seek.
async function _writeFileHandle(fh, content) {
  // Warm up the handle (fixes Chrome Android InvalidStateError)
  try { await fh.getFile(); } catch {}

  let w;
  try {
    w = await fh.createWritable({ keepExistingData: false });
  } catch(e) {
    // Last resort: createWritable with no options
    w = await fh.createWritable();
  }

  try {
    await w.write(content);
    await w.close();
  } catch(e) {
    try { await w.abort(); } catch {}
    throw e;
  }
}

async function writeLogEntry(logText) {
  const now = new Date();
  const dateStr = fmtDateYMD(now);
  const timeStr = fmtTimeHMA(now);

  const { tags, cleaned } = extractTagsFromText(logText);
  const sanitizedLog = sanitizeForYAML(cleaned);
  const finalTags = tags.length ? tags : ['explore'];

  // â”€â”€ Build content â”€â”€
  let newContent;
  if (S.logTemplateHandle) {
    try {
      const perm = await S.logTemplateHandle.requestPermission({ mode: 'read' });
      if (perm === 'granted') {
        const file = await S.logTemplateHandle.getFile();
        let templateText = await file.text();
        templateText = templateText
          .replace(/\{\{date:YYYY-MM-DD\}\}/g, dateStr)
          .replace(/\{\{DATE:hh:mm a\}\}/g, timeStr);
        const fmMatch = templateText.match(/^(---\n)([\s\S]+?)(\n---)([ \S]*)/);
        if (fmMatch) {
          const [, open, yaml, close, body] = fmMatch;
          let yamlLines = yaml.split('\n');
          const logIdx = yamlLines.findIndex(l => l.startsWith('log:'));
          if (logIdx !== -1) yamlLines[logIdx] = `log: ${sanitizedLog}`;
          else yamlLines.push(`log: ${sanitizedLog}`);
          const tagsIdx = yamlLines.findIndex(l => l.trim() === 'tags:');
          if (tagsIdx !== -1) {
            let ei = tagsIdx + 1;
            while (ei < yamlLines.length && /^\s+-/.test(yamlLines[ei])) ei++;
            yamlLines.splice(tagsIdx, ei - tagsIdx);
          }
          yamlLines.push('tags:', ...finalTags.map(t => `  - ${t}`));
          newContent = open + yamlLines.join('\n') + close + body;
        }
      }
    } catch(e) { console.warn('Template read failed:', e); }
  }
  if (!newContent) {
    newContent = `---\ndate: ${dateStr}\ntime: ${timeStr}\nlog: ${sanitizedLog}\ntags:\n${finalTags.map(t => `  - ${t}`).join('\n')}\n---\n`;
  }

  // â”€â”€ Generate filename â”€â”€
  const ts = now.toISOString().replace(/[-:.TZ]/g, '').slice(0, 14);
  const fmt = LS.get('logOutputFormat') || '{{date:YYYY}}/{{date:YYYYMMDDHHmmss}}';
  const basePath = applyDateFormat(fmt, now);
  const pathParts = basePath.split('/');
  const baseFilename = (pathParts.pop() || ts) + '.md';
  const subDirs = pathParts.filter(Boolean);
  const id = ts + '_' + Math.random().toString(36).slice(2, 6);

  // â”€â”€ Save to IDB (always) â”€â”€
  const idbEntry = {
    id,
    filename: baseFilename,
    path: [...subDirs, baseFilename].join('/'),
    content: newContent,
    preview: sanitizedLog.slice(0, 120),
    tags: finalTags,
    dateLabel: _filenameToLabel(baseFilename),
    ts: now.getTime(),
  };
  try { await IDBLogs.save(idbEntry); } catch(e) { console.warn('IDB save failed:', e); }

  // â”€â”€ Write to folder (auto, no picker every time) â”€â”€
  await _writeLogToFolder(idbEntry, newContent, subDirs, baseFilename);
  return true;
}

// Tries to write using the stored dir handle.
// If it fails or doesn't exist, prompts once to pick the folder, then retries.
async function _writeLogToFolder(idbEntry, content, subDirs, baseFilename) {
  // Activate pending handle if available (requires user gesture â€” we're in save click chain)
  if (!S.logOutputDirHandle) await _activateLogOutputHandle();

  // Try with existing handle first
  if (S.logOutputDirHandle) {
    const ok = await _tryWriteLog(S.logOutputDirHandle, idbEntry, content, subDirs, baseFilename);
    if (ok) return;
    // Handle went stale â€” clear and re-derive from vault
    S.logOutputDirHandle = null;
  }

  // Re-derive from vault
  if (S.vaultDirHandle) {
    S.logOutputDirHandle = await _navSubDir(S.vaultDirHandle, VAULT_PATHS.logOutput, true);
    if (S.logOutputDirHandle) {
      const ok = await _tryWriteLog(S.logOutputDirHandle, idbEntry, content, subDirs, baseFilename);
      if (ok) return;
    }
  }

  showToast('âš  Log folder unavailable â€” connect vault in Settings');
}

// Attempts a write with a given dir handle. Returns true on success, false on any error.
async function _tryWriteLog(rootHandle, idbEntry, content, subDirs, baseFilename) {
  try {
    let dir = rootHandle;
    for (const seg of subDirs) {
      dir = await dir.getDirectoryHandle(seg, { create: true });
    }

    // Unique filename
    let filename = baseFilename;
    let suffix = 0;
    for (;;) {
      let exists = false;
      try { await dir.getFileHandle(filename, { create: false }); exists = true; } catch {}
      if (!exists) break;
      suffix++;
      const dot = baseFilename.lastIndexOf('.');
      filename = baseFilename.slice(0, dot) + '_' + suffix + baseFilename.slice(dot);
    }

    const fh = await dir.getFileHandle(filename, { create: true });
    const w = await fh.createWritable();
    await w.write(content);
    await w.close();

    idbEntry.filename = filename;
    idbEntry.path = [...subDirs, filename].join('/') || filename;
    await IDBLogs.save(idbEntry);

    showToast('\u2713 Log saved');
    return true;
  } catch(e) {
    console.error('_tryWriteLog failed:', e);
    return false;
  }
}

// â”€â”€ LOG TEXT POPUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showLogTextPopup() {
  _openLogTextEditor();
}

function _openLogTextEditor() {

  const ov = document.createElement('div');
  ov.className = 'sched-edit-popup';
  ov.innerHTML = `<div class="sched-edit-sheet" style="max-height:90dvh">
    <div class="modal-handle"></div>
    <div style="font-size:16px;font-weight:800;margin-bottom:4px">ðŸ“ Text Log</div>
    <div style="font-size:11px;font-family:var(--font-mono);color:var(--muted);margin-bottom:12px">
      Use #hashtags to auto-tag your entry
    </div>
    <div style="font-size:13px;font-weight:700;color:var(--text);margin-bottom:8px">What's on your mind?</div>
    <textarea id="log-text-input" placeholder="Type your thoughtsâ€¦ #idea #work"
      style="width:100%;min-height:140px;resize:vertical;background:var(--bg3);border:1px solid var(--border);border-radius:10px;padding:13px 14px;color:var(--text);font-family:var(--font-mono);font-size:14px;outline:none;line-height:1.6;margin-bottom:14px;transition:border-color .15s"></textarea>
    <div id="log-tag-preview" style="min-height:22px;margin-bottom:12px;display:flex;flex-wrap:wrap;gap:6px"></div>
    <div style="display:flex;gap:10px">
      <button class="btn btn-ghost" id="log-cancel" style="flex:1">Cancel</button>
      <button class="btn btn-green" id="log-ok" style="flex:2">âœ“ Save Log</button>
    </div>
  </div>`;
  document.body.appendChild(ov);

  const textarea = ov.querySelector('#log-text-input');
  const tagPreview = ov.querySelector('#log-tag-preview');
  const close = () => document.body.removeChild(ov);

  // Live tag preview as user types
  textarea.addEventListener('input', () => {
    const tags = (textarea.value.match(/#[\w]+/g) || []);
    tagPreview.innerHTML = tags.map(t =>
      `<span style="background:rgba(0,255,136,.12);border:1px solid rgba(0,255,136,.3);border-radius:20px;padding:2px 10px;font-size:11px;font-family:var(--font-mono);color:var(--accent)">${t}</span>`
    ).join('');
    textarea.style.borderColor = 'var(--accent)';
  });
  textarea.addEventListener('blur', () => { textarea.style.borderColor = 'var(--border)'; });
  textarea.addEventListener('focus', () => { textarea.style.borderColor = 'var(--accent)'; });

  ov.addEventListener('click', e => { if (e.target === ov) close(); });
  ov.querySelector('#log-cancel').addEventListener('click', close);

  ov.querySelector('#log-ok').addEventListener('click', async () => {
    const text = textarea.value.trim();
    if (!text) { showToast('Write something first'); return; }
    const btn = ov.querySelector('#log-ok');
    btn.disabled = true; btn.textContent = 'Savingâ€¦';
    try {
      await writeLogEntry(text);
    } catch(e) {
      showToast('âš  Save error: ' + (e.name || 'error'));
      btn.disabled = false; btn.textContent = 'âœ“ Save Log';
      return;
    }
    close();
  });

  setTimeout(() => textarea.focus(), 100);
}

// â”€â”€ LOGS TAB â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Virtualized log viewer â€” handles thousands of files without DOM bloat.
// Row height is fixed at 72px for predictable math.
const LOG_ROW_H = 72;
let _logsTabMounted = false;
let _allLogs = [];      // [{filename, path, date, preview, tags, content}]
let _filteredLogs = []; // subset after search
let _logsLoading = false;
let _logsSearchQ = '';
let _logsViewport = null;
let _logsSpacerEl = null;
let _logsRenderedRange = { start: 0, end: 0 };
let _logsNodes = {};    // index â†’ DOM node (pooled)

let _logsDateFilter = 'today'; // 'today' | 'week' | 'month' | 'year' | 'all'

// â”€â”€ LOGS POPUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showLogsPopup() {
  const existing = document.getElementById('logs-popup-ov');
  if (existing) { existing.remove(); return; }
  const ov = document.createElement('div');
  ov.id = 'logs-popup-ov';
  ov.className = 'modal-overlay';
  ov.style.cssText = 'align-items:flex-end;z-index:200';
  ov.innerHTML = `<div style="background:var(--bg2);border:1px solid var(--border);border-radius:20px 20px 0 0;width:100%;max-width:480px;height:88dvh;display:flex;flex-direction:column;animation:slideUp .3s cubic-bezier(.34,1.56,.64,1);overflow:hidden">
    <div style="padding:14px 20px 10px;border-bottom:1px solid var(--border);display:flex;align-items:center;justify-content:space-between;flex-shrink:0">
      <span style="font-size:14px;font-weight:800;letter-spacing:-.3px">Archive</span>
      <button id="lp-close" style="width:28px;height:28px;border-radius:8px;border:1px solid var(--border);background:var(--bg3);color:var(--text);font-size:14px;cursor:pointer;display:flex;align-items:center;justify-content:center;line-height:1">âœ•</button>
    </div>
    <div id="lp-body" style="flex:1;display:flex;flex-direction:column;min-height:0;overflow:hidden;padding:10px 16px 16px">
      <div class="logs-toolbar" style="margin-bottom:10px">
        <input class="logs-search" id="lp-search" type="search" placeholder="Search logsâ€¦" autocomplete="off"/>
        <select id="lp-date-filter" style="background:var(--bg2);border:1px solid var(--border);border-radius:8px;padding:6px 8px;color:var(--text);font-family:var(--font-mono);font-size:11px;outline:none;cursor:pointer;flex-shrink:0">
          <option value="today">Today</option>
          <option value="week">This Week</option>
          <option value="month">This Month</option>
          <option value="year">This Year</option>
          <option value="all">All Time</option>
        </select>
      </div>
      <div style="flex:1;min-height:0;position:relative">
        <div class="logs-viewport" id="lp-viewport" style="position:absolute;inset:0;overflow-y:auto;-webkit-overflow-scrolling:touch">
          <div class="logs-spacer" id="lp-spacer"></div>
        </div>
      </div>
      <div class="logs-status" id="lp-status" style="margin-top:6px"></div>
    </div>
  </div>`;
  document.body.appendChild(ov);
  ov.addEventListener('click', e => { if (e.target === ov) ov.remove(); });
  ov.querySelector('#lp-close').addEventListener('click', () => ov.remove());

  // Reset log state for fresh popup render
  _logsTabMounted = false;
  _allLogs = [];
  _filteredLogs = [];
  _logsNodes = {};
  _logsRenderedRange = { start: 0, end: 0 };
  _logsViewport = ov.querySelector('#lp-viewport');
  _logsSpacerEl = ov.querySelector('#lp-spacer');
  window._logsStatusElId = 'lp-status';

  _logsViewport.addEventListener('scroll', () => _logsVirtualRender(), { passive: true });
  ov.querySelector('#lp-search').addEventListener('input', e => {
    _logsSearchQ = e.target.value.trim().toLowerCase(); _logsApplyFilter();
  });
  ov.querySelector('#lp-date-filter').addEventListener('change', e => {
    _logsDateFilter = e.target.value; if (S.logOutputDirHandle) _logsApplyFilter();
  });

  // Clean up when popup closes
  ov.addEventListener('animationend', () => {});
  const obs = new MutationObserver(() => {
    if (!document.contains(ov)) { _logsViewport = null; _logsSpacerEl = null; obs.disconnect(); }
  });
  obs.observe(document.body, { childList: true });

  loadAllLogs();
}

async function renderLogsTab() {
  // No-op â€” logs are now in the Archive popup (showLogsPopup)
}

async function loadAllLogs() {
  if (_logsLoading) return;
  _logsLoading = true;
  _setLogsStatus('Loadingâ€¦');

  const entries = [];

  // â”€â”€ 1. Load from IDB (works on all platforms) â”€â”€
  try {
    const idbLogs = await IDBLogs.getAll();
    for (const log of idbLogs) {
      entries.push({
        filename: log.filename,
        path: log.path,
        handle: null,       // no file handle â€” IDB only
        idbId: log.id,      // IDB key for edits/deletes
        preview: log.preview,
        tags: log.tags || [],
        dateLabel: log.dateLabel || _filenameToLabel(log.filename),
        _fullText: log.content,
        loaded: true,
        ts: log.ts || 0,
      });
    }
  } catch(e) { console.warn('IDB log load failed:', e); }

  // â”€â”€ 2. Load from folder (desktop) â€” merge, dedup by filename â”€â”€
  if (S.logOutputDirHandle) {
    try {
      const perm = await S.logOutputDirHandle.requestPermission({ mode: 'readwrite' });
      if (perm === 'granted') {
        const folderEntries = [];
        await _scanLogDir(S.logOutputDirHandle, '', folderEntries);
        // Build set of filenames that actually exist on disk
        const folderFilenames = new Set(folderEntries.map(e => e.filename));

        // â”€â”€ Reconcile: remove IDB entries whose files no longer exist on disk â”€â”€
        const toDelete = entries.filter(e => e.idbId && !folderFilenames.has(e.filename));
        for (const stale of toDelete) {
          try { await IDBLogs.delete(stale.idbId); } catch {}
        }
        // Remove stale entries from in-memory list
        const staleIds = new Set(toDelete.map(e => e.idbId));
        entries.splice(0, entries.length, ...entries.filter(e => !staleIds.has(e.idbId)));

        // Add folder entries that aren't already in IDB (dedup by filename)
        const idbFilenames = new Set(entries.map(e => e.filename));
        for (const fe of folderEntries) {
          if (!idbFilenames.has(fe.filename)) entries.push(fe);
        }
      }
    } catch(e) { console.warn('Folder log scan failed:', e.message); }
  }

  if (!entries.length) {
    _logsSetEmpty('No logs yet.<br><small style="color:var(--muted);font-size:11px">Tap the log button to write your first entry.</small>');
    _logsLoading = false; return;
  }

  entries.sort((a, b) => (b.ts || 0) - (a.ts || 0) || b.filename.localeCompare(a.filename));
  _allLogs = entries;
  _logsApplyFilter();
  _logsLoading = false;
}

// Recursively scan a directory for .md files
async function _scanLogDir(dirHandle, prefix, out) {
  try {
    for await (const entry of dirHandle.values()) {
      if (entry.kind === 'directory') {
        await _scanLogDir(entry, prefix ? prefix + '/' + entry.name : entry.name, out);
      } else if (entry.kind === 'file' && entry.name.endsWith('.md')) {
        const path = prefix ? prefix + '/' + entry.name : entry.name;
        // Lazy: only read content when item is rendered (store handle for later)
        out.push({ filename: entry.name, path, handle: entry, preview: null, tags: [], loaded: false });
      }
    }
  } catch {}
}

function _logsApplyFilter() {
  const now = new Date();
  const todayStr2 = now.toISOString().slice(0, 10).replace(/-/g, '');
  const monthStr = now.toISOString().slice(0, 7).replace(/-/g, '');
  const yearStr  = now.getFullYear().toString();
  // Week: compute YYYYMMDD for start of week (Monday)
  const weekStart = new Date(now); weekStart.setDate(now.getDate() - ((now.getDay()+6)%7)); weekStart.setHours(0,0,0,0);
  const weekStartNum = parseInt(weekStart.toISOString().slice(0,10).replace(/-/g,''));

  let base = _allLogs;

  // Date filter
  if (_logsDateFilter !== 'all') {
    base = base.filter(l => {
      const fn = l.filename;
      if (_logsDateFilter === 'today') return fn.includes(todayStr2);
      if (_logsDateFilter === 'week') {
        // extract YYYYMMDD from filename
        const m = fn.match(/(\d{8})/); if (!m) return false;
        return parseInt(m[1]) >= weekStartNum;
      }
      if (_logsDateFilter === 'month') return fn.includes(monthStr) || fn.startsWith(yearStr + '/' + now.toISOString().slice(5,7));
      if (_logsDateFilter === 'year')  return fn.includes(yearStr) || l.path.startsWith(yearStr + '/');
      return true;
    });
  }

  // Search filter
  if (_logsSearchQ) {
    const q = _logsSearchQ;
    base = base.filter(l =>
      l.path.toLowerCase().includes(q) ||
      (l.preview || '').toLowerCase().includes(q) ||
      l.tags.some(t => t.toLowerCase().includes(q))
    );
  }
  _filteredLogs = base;

  // â”€â”€ Purge all existing DOM nodes from the spacer to prevent ghosting â”€â”€
  if (_logsSpacerEl) _logsSpacerEl.querySelectorAll('.log-item').forEach(n => n.remove());
  _logsNodes = {};
  _logsRenderedRange = { start: 0, end: 0 };

  _setLogsStatus(`${_filteredLogs.length.toLocaleString()} log${_filteredLogs.length !== 1 ? 's' : ''}`);
  if (_filteredLogs.length === 0) {
    _logsSetEmpty(_logsSearchQ ? 'No logs match your search.' : `No logs for ${_logsDateFilter === 'today' ? 'today' : _logsDateFilter === 'week' ? 'this week' : _logsDateFilter === 'month' ? 'this month' : _logsDateFilter === 'year' ? 'this year' : 'selected period'}.`);
    return;
  }
  const emp = _logsViewport?.querySelector('.logs-empty');
  if (emp) emp.remove();
  if (_logsSpacerEl) _logsSpacerEl.style.height = (_filteredLogs.length * LOG_ROW_H) + 'px';
  if (_logsViewport) _logsViewport.scrollTop = 0;
  _logsVirtualRender(true);
}

function _logsSetEmpty(msg) {
  if (!_logsViewport) return;
  _logsViewport.querySelectorAll('.log-item').forEach(n => n.remove());
  _logsNodes = {};
  if (_logsSpacerEl) _logsSpacerEl.style.height = '0';
  let emp = _logsViewport.querySelector('.logs-empty');
  if (!emp) { emp = document.createElement('div'); emp.className = 'logs-empty'; _logsViewport.appendChild(emp); }
  emp.innerHTML = msg;
  _setLogsStatus('');
}

function _setLogsStatus(msg) {
  const id = window._logsStatusElId || 'logs-status';
  const el = document.getElementById(id);
  if (el) el.textContent = msg;
}

function _logsVirtualRender(force) {
  if (!_logsViewport || !_logsSpacerEl) return;
  if (_filteredLogs.length === 0) return;

  const scrollTop = _logsViewport.scrollTop;
  const height = _logsViewport.clientHeight || 400;
  const overscan = 8; // extra rows above/below viewport
  const start = Math.max(0, Math.floor(scrollTop / LOG_ROW_H) - overscan);
  const end   = Math.min(_filteredLogs.length - 1, Math.ceil((scrollTop + height) / LOG_ROW_H) + overscan);

  if (!force && start === _logsRenderedRange.start && end === _logsRenderedRange.end) return;
  _logsRenderedRange = { start, end };

  // Remove nodes outside range
  Object.keys(_logsNodes).forEach(i => {
    const ii = parseInt(i);
    if (ii < start || ii > end) { _logsNodes[i].remove(); delete _logsNodes[i]; }
  });

  // Add nodes in range
  for (let i = start; i <= end; i++) {
    if (_logsNodes[i]) continue;
    const log = _filteredLogs[i];
    const node = document.createElement('div');
    node.className = 'log-item';
    node.style.top = (i * LOG_ROW_H) + 'px';
    node.dataset.idx = i;
    _renderLogNode(node, log);
    _logsSpacerEl.appendChild(node);
    _logsNodes[i] = node;

    // Lazy-load content for search highlighting
    if (!log.loaded) {
      _loadLogPreview(log).then(() => {
        if (_logsNodes[i] === node) _renderLogNode(node, log);
      });
    }
    node.addEventListener('click', () => _openLogDetail(log));
  }
}

async function _loadLogPreview(log) {
  if (log.loaded) return;
  log.loaded = true;
  try {
    const file = await log.handle.getFile();
    const text = await file.text();
    log._fullText = text;
    // Extract log field from frontmatter
    const logM = text.match(/^log:\s*(.+)/m);
    log.preview = logM ? logM[1].replace(/^["']|["']$/g, '').trim() : text.replace(/^---[\s\S]*?---\n?/,'').trim().slice(0,120);
    // Extract tags â€” collect all "  - tagname" lines after "tags:" until a non-indented line
    log.tags = [];
    const lines = text.split('\n');
    let inTags = false;
    for (const line of lines) {
      if (/^tags:\s*$/.test(line)) { inTags = true; continue; }
      if (inTags) {
        const m = line.match(/^\s+-\s+(\S+)/);
        if (m) log.tags.push(m[1]);
        else if (line.trim() !== '' && !/^\s/.test(line)) break; // non-indented line ends block
      }
    }
    // Extract timestamp from filename for display
    log.dateLabel = _filenameToLabel(log.filename);
  } catch { log.preview = log.filename; }
}

function _filenameToLabel(name) {
  // Try to extract YYYYMMDDHHmmss pattern
  const m = name.match(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/);
  if (m) {
    const [,Y,Mo,D,H,Min] = m;
    const d = new Date(+Y,+Mo-1,+D,+H,+Min);
    return d.toLocaleString(undefined, {month:'short',day:'numeric',hour:'2-digit',minute:'2-digit'});
  }
  // Fallback: YYYY-MM-DD
  const m2 = name.match(/(\d{4})-(\d{2})-(\d{2})/);
  if (m2) return `${m2[2]}/${m2[3]}/${m2[1]}`;
  return name.replace('.md','');
}

function _renderLogNode(node, log) {
  const time = log.dateLabel || _filenameToLabel(log.filename);
  const preview = (log.preview || log.filename).slice(0, 90);
  const tags = log.tags.slice(0, 3).map(t => `<span class="log-item-tag">#${t}</span>`).join('');
  node.innerHTML = `
    <div class="log-item-header">
      <span class="log-item-time">${time}</span>
      <span class="log-item-filename">${log.path}</span>
    </div>
    <div class="log-item-preview">${preview}</div>
    ${tags ? `<div class="log-item-tags">${tags}</div>` : ''}`;
}

async function _getLogParentDir(log) {
  // Navigate from the root dir handle to the parent folder of this log file
  const parts = log.path.split('/');
  parts.pop(); // remove filename
  let dir = S.logOutputDirHandle;
  for (const seg of parts) {
    if (seg) dir = await dir.getDirectoryHandle(seg, { create: false });
  }
  return dir;
}

async function _ensureWritePermission(dirHandle) {
  const perm = await dirHandle.queryPermission({ mode: 'readwrite' });
  if (perm === 'granted') return true;
  const req = await dirHandle.requestPermission({ mode: 'readwrite' });
  return req === 'granted';
}

async function _openLogDetail(log) {
  // Always reload from disk to get latest content
  log.loaded = false;
  await _loadLogPreview(log);

  const raw = log._fullText || '';
  const bodyOnly = raw.replace(/^---[\s\S]*?---\r?\n?/m, '').trim();
  const displayBody = bodyOnly || log.preview || log.filename;

  const ov = document.createElement('div'); ov.className = 'modal-overlay';
  ov.innerHTML = `<div class="modal" style="max-height:88dvh;overflow-y:auto">
    <div class="modal-handle"></div>
    <div style="font-size:11px;font-family:var(--font-mono);color:var(--accent);margin-bottom:4px">${log.dateLabel || log.filename}</div>
    ${log.tags.length ? `<div style="display:flex;gap:6px;flex-wrap:wrap;margin-bottom:12px">${log.tags.map(t=>`<span class="log-item-tag">#${t}</span>`).join('')}</div>` : ''}
    <div class="log-detail-body" id="ld-body" style="white-space:pre-wrap;word-break:break-word;font-size:13px;line-height:1.6;margin-bottom:16px">${displayBody.replace(/&/g,'&amp;').replace(/</g,'&lt;')}</div>
    <div style="display:flex;gap:8px;margin-top:4px">
      <button class="btn btn-ghost" style="flex:1;font-size:13px" id="ld-edit">âœŽ Edit</button>
      <button class="btn btn-ghost" style="flex:1;font-size:13px;color:var(--danger);border-color:rgba(255,68,102,.3)" id="ld-delete">âœ• Delete</button>
      <button class="btn btn-ghost" style="flex:1;font-size:13px" id="ld-close">Close</button>
    </div>
  </div>`;
  document.body.appendChild(ov);
  const close = () => { if (ov.parentNode) document.body.removeChild(ov); };
  ov.addEventListener('click', e => { if (e.target === ov) close(); });
  ov.querySelector('#ld-close').addEventListener('click', close);

  // â”€â”€ Edit â”€â”€
  ov.querySelector('#ld-edit').addEventListener('click', () => {
    close();
    _openLogEditor(log);
  });

  // â”€â”€ Delete â”€â”€
  ov.querySelector('#ld-delete').addEventListener('click', async () => {
    if (!confirm(`Delete "${log.filename}"?\nThis cannot be undone.`)) return;
    const delBtn = ov.querySelector('#ld-delete');
    delBtn.disabled = true; delBtn.textContent = 'Deletingâ€¦';
    try {
      // Always remove from IDB first (source of truth for archive)
      if (log.idbId) {
        try { await IDBLogs.delete(log.idbId); } catch(e) { console.warn('IDB delete failed:', e); }
      }
      // Also remove from vault folder if handle is available
      if (S.logOutputDirHandle && log.handle) {
        try {
          const dir = await _getLogParentDir(log);
          const ok = await _ensureWritePermission(dir);
          if (ok) await dir.removeEntry(log.filename);
        } catch(e) { console.warn('Folder delete failed (IDB already cleaned):', e); }
      }
      _allLogs = _allLogs.filter(l => l.path !== log.path);
      _logsApplyFilter();
      showToast('ðŸ—‘ Log deleted');
      close();
    } catch(e) {
      console.error('Delete failed', e);
      showToast('Delete failed: ' + e.message);
      delBtn.disabled = false; delBtn.textContent = 'âœ• Delete';
    }
  });
}

// â”€â”€ LOG EDITOR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function _openLogEditor(log) {
  const ov = document.createElement('div'); ov.className = 'modal-overlay';
  const rawText = log._fullText || '';

  // â”€â”€ Extract current log text and tags from YAML frontmatter â”€â”€
  const logMatch = rawText.match(/^log:\s*(.*)$/m);
  let currentLog = logMatch ? logMatch[1].replace(/^["']|["']$/g, '').trim() : '';

  // Parse all tags line-by-line (regex lookahead was stopping after first tag)
  let currentTags = [];
  const rawLines = rawText.split('\n');
  let inTagBlock = false;
  for (const line of rawLines) {
    if (/^tags:\s*$/.test(line)) { inTagBlock = true; continue; }
    if (inTagBlock) {
      const m = line.match(/^\s+-\s+(\S+)/);
      if (m) currentTags.push(m[1]);
      else if (line.trim() !== '' && !/^\s/.test(line)) break;
    }
  }
  // Rebuild into "log text #tag1 #tag2" format for the textarea
  const initialValue = currentLog + (currentTags.length ? ' ' + currentTags.map(t => '#' + t).join(' ') : '');

  ov.innerHTML = `<div class="modal" style="max-height:92dvh;overflow-y:auto">
    <div class="modal-handle"></div>
    <div style="font-size:14px;font-weight:800;margin-bottom:4px">âœŽ Edit Log</div>
    <div style="font-size:10px;font-family:var(--font-mono);color:var(--muted);margin-bottom:4px">${log.path}</div>
    <div style="font-size:11px;font-family:var(--font-mono);color:var(--muted);margin-bottom:12px">Use #hashtags to tag your entry</div>
    <textarea id="le-body" placeholder="Your log textâ€¦ #tag1 #tag2"
      style="width:100%;min-height:140px;resize:vertical;background:var(--bg3);border:1px solid var(--border);border-radius:10px;padding:12px 14px;color:var(--text);font-family:var(--font-mono);font-size:14px;outline:none;line-height:1.6;margin-bottom:10px;transition:border-color .15s"></textarea>
    <div id="le-tag-preview" style="min-height:22px;margin-bottom:14px;display:flex;flex-wrap:wrap;gap:6px"></div>
    <div style="display:flex;gap:8px">
      <button class="btn btn-ghost" style="flex:1" id="le-cancel">Cancel</button>
      <button class="btn btn-green" style="flex:2" id="le-save">âœ“ Save Changes</button>
    </div>
  </div>`;
  document.body.appendChild(ov);

  const ta = ov.querySelector('#le-body');
  const tagPreview = ov.querySelector('#le-tag-preview');
  ta.value = initialValue;

  function updateTagPreview() {
    const tags = (ta.value.match(/#[\w]+/g) || []);
    tagPreview.innerHTML = tags.map(t =>
      `<span style="background:rgba(0,255,136,.12);border:1px solid rgba(0,255,136,.3);border-radius:20px;padding:2px 10px;font-size:11px;font-family:var(--font-mono);color:var(--accent)">${t}</span>`
    ).join('');
  }
  updateTagPreview();
  ta.addEventListener('input', () => { updateTagPreview(); ta.style.borderColor = 'var(--accent)'; });
  ta.addEventListener('focus', () => ta.style.borderColor = 'var(--accent)');
  ta.addEventListener('blur',  () => ta.style.borderColor = 'var(--border)');

  const close = () => document.body.removeChild(ov);
  ov.addEventListener('click', e => { if (e.target === ov) close(); });
  ov.querySelector('#le-cancel').addEventListener('click', close);

  ov.querySelector('#le-save').addEventListener('click', async () => {
    const inputText = ta.value.trim();
    if (!inputText) { showToast('Write something first'); return; }
    const btn = ov.querySelector('#le-save');
    btn.disabled = true; btn.textContent = 'Savingâ€¦';

    try {
      // â”€â”€ Parse new log text + tags from user input â”€â”€
      const { tags: newTags, cleaned: newLogText } = extractTagsFromText(inputText);
      const sanitizedLog = sanitizeForYAML(newLogText);
      const finalTags = newTags.length ? newTags : ['explore'];

      // â”€â”€ Rebuild YAML frontmatter cleanly â”€â”€
      // Normalise line endings first
      const normRaw = rawText.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
      const fmMatch = normRaw.match(/^---\n([\s\S]*?)\n---/);
      let newFullText;
      if (fmMatch) {
        // Parse existing YAML lines, drop old log/tags, reinsert
        let yamlLines = fmMatch[1].split('\n');
        // Remove old log: line
        yamlLines = yamlLines.filter(l => !l.startsWith('log:'));
        // Remove old tags block
        const ti = yamlLines.findIndex(l => /^tags:\s*$/.test(l));
        if (ti !== -1) {
          let end = ti + 1;
          while (end < yamlLines.length && /^\s+-\s/.test(yamlLines[end])) end++;
          yamlLines.splice(ti, end - ti);
        }
        // Append updated log + tags
        yamlLines.push(`log: ${sanitizedLog}`);
        yamlLines.push('tags:');
        finalTags.forEach(t => yamlLines.push(`  - ${t}`));

        const bodyAfterFm = normRaw.slice(fmMatch[0].length); // everything after closing ---
        newFullText = '---\n' + yamlLines.join('\n') + '\n---' + bodyAfterFm;
      } else {
        // No frontmatter â€” prepend one
        newFullText = `---\nlog: ${sanitizedLog}\ntags:\n${finalTags.map(t=>`  - ${t}`).join('\n')}\n---\n${normRaw}`;
      }

      // â”€â”€ Write: IDB first, then folder â”€â”€
      // 1. Update IDB entry (always works)
      if (log.idbId) {
        try {
          const existing = await IDBLogs.get(log.idbId);
          if (existing) {
            existing.content = newFullText;
            existing.preview = sanitizedLog.slice(0, 120);
            existing.tags = finalTags;
            await IDBLogs.save(existing);
          }
        } catch(e) { console.warn('IDB log update failed:', e); }
      }

      // 2. Write to folder â€” via file handle (known file) or folder path (IDB-only log)
      const writeToFolder = async () => {
        if (log.handle) {
          // File handle from folder scan â€” write directly
          let perm = await log.handle.queryPermission({ mode: 'readwrite' }).catch(() => 'prompt');
          if (perm !== 'granted') perm = await log.handle.requestPermission({ mode: 'readwrite' }).catch(() => 'denied');
          if (perm !== 'granted') throw new Error('Permission denied on file handle');
          const w = await log.handle.createWritable({ keepExistingData: false });
          await w.write(newFullText);
          await w.close();
        } else if (S.logOutputDirHandle) {
          // IDB-only log â€” navigate to folder and write
          const perm = await S.logOutputDirHandle.requestPermission({ mode: 'readwrite' });
          if (perm !== 'granted') throw new Error('Permission denied on output folder');
          const pathParts = log.path.split('/');
          const filename = pathParts.pop();
          let dir = S.logOutputDirHandle;
          for (const seg of pathParts) { if (seg) dir = await dir.getDirectoryHandle(seg, { create: true }); }
          const fh = await dir.getFileHandle(filename, { create: true });
          const w = await fh.createWritable({ keepExistingData: false });
          await w.write(newFullText);
          await w.close();
        }
      };
      try {
        await writeToFolder();
      } catch(e) {
        console.error('Folder log edit write failed:', e);
        S.logOutputDirHandle = null;
        showToast('\u26a0 Folder error â€” reconnect vault in Settings');
      }

      // â”€â”€ Update in-memory cache â”€â”€
      log._fullText = newFullText;
      log.loaded = false;
      await _loadLogPreview(log);
      const idx = _filteredLogs.indexOf(log);
      if (idx !== -1 && _logsNodes[idx]) _renderLogNode(_logsNodes[idx], log);
      showToast('âœ“ Log saved');
      close();
    } catch(e) {
      console.error('Save failed', e);
      showToast('\u26a0 Save failed');
      btn.disabled = false; btn.textContent = 'âœ“ Save Changes';
    }
  });

  setTimeout(() => ta.focus(), 100);
}

function autoThemeForTime() { const h = new Date().getHours(); return (h >= 7 && h < 21) ? 'light' : 'dark'; }
function applyTheme(t) {
  LS.set('theme', t);
  const resolved = t === 'auto' ? autoThemeForTime() : t;
  document.documentElement.setAttribute('data-theme', resolved);
  const mc = document.querySelector('meta[name="theme-color"]');
  if (mc) mc.content = resolved === 'light' ? '#f2f2f7' : '#0a0a0f';
}
setInterval(() => { if ((LS.get('theme') || 'auto') === 'auto') applyTheme('auto'); }, 60000);

function isAndroid() { return /android/i.test(navigator.userAgent); }

function showSettings() {
  const ov=document.createElement('div'); ov.className='modal-overlay';
  const vaultName=LS.get('vaultFolderName')||'Not set';
  const vaultOk=!!S.vaultDirHandle;
  const np=S.notifPermission;
  const currentTheme = LS.get('theme') || 'auto';
  const hostedRemotely = !location.hostname.match(/^(localhost|127\.|192\.|10\.|file)/) && location.hostname !== '';
  const notifBlocked = np === 'denied';
  const android = isAndroid();
  const batteryDismissed = LS.get('batteryTipDismissed');

  const batterySection = (android && np === 'granted' && !batteryDismissed) ? `
    <div class="s-section">
      <div class="s-section-title">âš¡ Battery Optimization</div>
      <div style="background:rgba(255,170,0,.07);border:1px solid rgba(255,170,0,.25);border-radius:12px;padding:14px 16px;font-size:12px;font-family:var(--font-mono);color:var(--text);line-height:1.8">
        <div style="color:var(--warn);font-weight:700;margin-bottom:6px">ðŸ”‹ Enable for reliable background alarms</div>
        Android kills Chrome in the background to save battery â€” this stops your alarms from firing when the screen is off.<br><br>
        <b style="color:var(--text)">Fix in 3 taps:</b><br>
        <span style="color:var(--accent)">1.</span> Settings â†’ Apps â†’ <b>Chrome</b><br>
        <span style="color:var(--accent)">2.</span> Battery â†’ <b>Unrestricted</b><br>
        <span style="color:var(--accent)">3.</span> Come back and tap "Done" below
      </div>
      <div style="display:flex;gap:8px;margin-top:10px">
        <button class="btn btn-ghost" id="s-battery-dismiss" style="flex:1;font-size:13px">âœ“ Done / Dismiss</button>
        <button class="btn btn-green" id="s-battery-open" style="flex:2;font-size:13px">Open Android Settings</button>
      </div>
    </div>` : '';

  const _notifsEnabled = LS.get('notifsEnabled') !== false;
  let notifSection = '';
  if (notifBlocked) {
    notifSection = '<div class="s-row">'
      + '<div><div class="s-label">Alarm Notifications</div><div class="s-sub">Background alarm notifications</div></div>'
      + '<span class="pill pill-red">BLOCKED</span>'
      + '</div>'
      + '<div class="notif-fix" style="margin-top:8px">'
      + (hostedRemotely
          ? '<b>Blocked by your hosting provider.</b><br>Host locally or add <code>Permissions-Policy: notifications=(self)</code> to your <code>_headers</code> file.'
          : 'To unblock: <b>Chrome â†’ ðŸ”’ lock â†’ Site settings â†’ Notifications â†’ Allow</b><br>Then reload.')
      + '</div>';
  } else if (np === 'default') {
    notifSection = '<div class="s-row">'
      + '<div><div class="s-label">Alarm Notifications</div><div class="s-sub">Background alarm notifications</div></div>'
      + '<span class="pill pill-amber">OFF</span>'
      + '</div>'
      + '<button class="btn btn-green" style="width:100%;margin-top:8px" id="s-notif">Enable Notifications</button>';
  } else {
    // Granted â€” show toggle
    const _swOn = _notifsEnabled ? 'on' : 'off';
    const _swBg = _notifsEnabled ? 'var(--accent)' : 'rgba(120,120,140,.4)';
    const _swDot = _notifsEnabled ? '14px' : '2px';
    notifSection = '<div class="s-row" style="align-items:center">'
      + '<div><div class="s-label">Alarm Notifications</div><div class="s-sub">'
      + (_notifsEnabled ? 'Alarms will fire in the background' : 'Alarms are silenced')
      + '</div></div>'
      + '<div id="s-notif-toggle" style="cursor:pointer;width:44px;height:24px;border-radius:12px;background:' + _swBg + ';position:relative;transition:background .2s;flex-shrink:0">'
      + '<div style="position:absolute;top:3px;left:' + _swDot + ';width:18px;height:18px;border-radius:50%;background:#fff;transition:left .2s;box-shadow:0 1px 3px rgba(0,0,0,.3)"></div>'
      + '</div>'
      + '</div>';
  }

  const vaultName2 = LS.get('vaultFolderName') || 'vault';
  const backupSection = '';

  ov.innerHTML=`<div class="modal">
    <div class="modal-handle"></div>
    <div class="modal-title">Settings</div>

    <div class="s-section">
      <div class="s-section-title">Appearance</div>
      <div class="s-row" style="flex-direction:column;align-items:stretch;gap:10px">
        <div class="s-label">Theme</div>
        <div class="theme-seg" id="theme-seg">
          <button class="theme-seg-btn${currentTheme==='auto'?' active':''}" data-theme="auto">â˜€ï¸Ž/ðŸŒ™ Auto</button>
          <button class="theme-seg-btn${currentTheme==='dark'?' active':''}" data-theme="dark">ðŸŒ™ Dark</button>
          <button class="theme-seg-btn${currentTheme==='light'?' active':''}" data-theme="light">â˜€ï¸Ž Light</button>
        </div>
      </div>
    </div>

    <div class="s-section">
      <div class="s-section-title">Vault Folder</div>
      <div class="s-row">
        <div><div class="s-label">ðŸ“ ${vaultName}</div><div class="s-sub">All subfolders are derived automatically from this vault root</div></div>
        <span class="pill ${vaultOk?'pill-green':'pill-amber'}">${vaultOk?'LIVE':'OFFLINE'}</span>
      </div>
      <button class="btn btn-ghost" style="width:100%;margin-top:8px" id="s-change-vault">Change Vault Folder</button>
    </div>

    <div class="s-section">
      <div class="s-section-title">Notifications</div>
      ${notifSection}
    </div>

    ${batterySection}

    <button class="btn btn-ghost" style="width:100%" id="s-close">Close</button>
  </div>`;
  document.body.appendChild(ov);
  const close=()=>document.body.removeChild(ov);
  ov.addEventListener('click',e=>{ if(e.target===ov) close(); });
  ov.querySelector('#s-close').addEventListener('click',close);
  ov.querySelector('#s-change-vault').addEventListener('click',async()=>{ close(); const ok=await pickVaultFolder(); if(ok){ await loadFromVault(); renderAll(); }});

  ov.querySelector('#s-notif')?.addEventListener('click',async()=>{ S.notifPermission=await Notification.requestPermission(); close(); showSettings(); });
  // Notifications toggle (soft on/off when permission is granted)
  ov.querySelector('#s-notif-toggle')?.addEventListener('click', () => {
    const nowOn = LS.get('notifsEnabled') !== false;
    const next  = !nowOn;
    LS.set('notifsEnabled', next);
    // Update toggle visually
    const tog = ov.querySelector('#s-notif-toggle');
    const dot = tog?.querySelector('div');
    if (tog) tog.style.background = next ? 'var(--accent)' : 'rgba(120,120,140,.4)';
    if (dot) dot.style.left = next ? '14px' : '2px';
    // Update sub-label
    const sub = ov.querySelector('#s-notif-toggle')?.closest('.s-row')?.querySelector('.s-sub');
    if (sub) sub.textContent = next ? 'Alarms will fire in the background' : 'Alarms are silenced';
    // Sync to SW â€” send full schedule if turning on, empty if turning off
    if (next) {
      syncAlarmsToSW();
      showToast('ðŸ”” Alarm notifications on');
    } else {
      if (navigator.serviceWorker?.controller) {
        navigator.serviceWorker.controller.postMessage({ type: 'SYNC_ALARMS', alarms: [] });
      }
      showToast('ðŸ”• Alarm notifications off');
    }
  });
  // Battery optimization buttons
  ov.querySelector('#s-battery-open')?.addEventListener('click',()=>{
    // Deep-link into Android settings â€” works on most Android versions
    // This opens the app info page for Chrome; user taps Battery themselves
    try { location.href = 'intent:#Intent;action=android.settings.APPLICATION_DETAILS_SETTINGS;data=package:com.android.chrome;end'; }
    catch { showToast('Go to Settings â†’ Apps â†’ Chrome â†’ Battery'); }
    showToast('Settings opened â€” tap Battery â†’ Unrestricted');
  });
  ov.querySelector('#s-battery-dismiss')?.addEventListener('click',()=>{ LS.set('batteryTipDismissed', true); close(); showSettings(); });
  // Theme segment
  ov.querySelectorAll('.theme-seg-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      ov.querySelectorAll('.theme-seg-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      applyTheme(btn.dataset.theme);
    });
  });
  // Vault backup list
  ov.querySelector('#s-list-backups')?.addEventListener('click', async () => {
    close();
    await showVaultBackups();
  });

}

// â”€â”€ INSTALL GUIDE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showInstallGuide() {
  const ov = document.createElement('div'); ov.className='install-guide';
  ov.innerHTML=`<div class="install-modal">
    <div class="modal-handle"></div>
    <div style="font-size:20px;font-weight:800;margin-bottom:6px">ðŸ“² Install as App</div>
    <div style="font-size:12px;font-family:var(--font-mono);color:var(--muted);margin-bottom:20px;line-height:1.6">
      Install once â€” runs offline, no browser chrome, lives on your home screen / taskbar.
    </div>

    <div class="platform-tabs">
      <button class="ptab active" data-p="local">ðŸ’» Local (Best)</button>
      <button class="ptab" data-p="chrome">Chrome Desktop</button>
      <button class="ptab" data-p="android">Android</button>
      <button class="ptab" data-p="ios">iOS</button>
    </div>

    <!-- LOCAL (recommended) -->
    <div class="platform-steps active" id="steps-local">
      <div style="background:rgba(0,255,136,.07);border:1px solid rgba(0,255,136,.2);border-radius:10px;padding:12px 14px;font-size:12px;font-family:var(--font-mono);color:var(--accent);line-height:1.6;margin-bottom:16px">
        âœ¦ Recommended. Runs fully offline, notifications work, zero hosting needed.
      </div>
      <div class="install-step">
        <div class="install-num">1</div>
        <div class="install-text">Put all 4 files (<b>index.html</b>, <b>sw.js</b>, <b>manifest.json</b>, <b>icon.svg</b>) in one folder on your computer.
          <small>e.g. C:\Users\You\HabitTracker\ or ~/HabitTracker/</small>
        </div>
      </div>
      <div class="install-step">
        <div class="install-num">2</div>
        <div class="install-text">Install <b>Node.js</b> (nodejs.org) if you don't have it. Then open Terminal / Command Prompt and run:
          <div style="background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:10px 12px;margin-top:8px;font-size:11px;font-family:var(--font-mono);color:var(--accent)">npx serve C:\path\to\your\folder</div>
          <small>Or on Mac/Linux: <code>npx serve ~/HabitTracker</code></small>
        </div>
      </div>
      <div class="install-step">
        <div class="install-num">3</div>
        <div class="install-text">Open <b>http://localhost:3000</b> in Chrome or Edge.
          <small>Keep the terminal running in background â€” it's your local server.</small>
        </div>
      </div>
      <div class="install-step">
        <div class="install-num">4</div>
        <div class="install-text">In Chrome, click the <b>âŠ• install icon</b> in the address bar (right side) â†’ <b>"Install Vault Dex"</b>.
          <small>The app now appears in your Start Menu / Applications and opens as a standalone window.</small>
        </div>
      </div>
      <div class="install-step">
        <div class="install-num">5</div>
        <div class="install-text">First launch: tap <b>"Choose Vault Folder"</b> â†’ pick your Obsidian vault. Done â€” notifications will work fully.
          <small>On every subsequent launch, tap the amber "Reconnect" button once to re-grant file access.</small>
        </div>
      </div>
    </div>

    <!-- CHROME DESKTOP -->
    <div class="platform-steps" id="steps-chrome">
      <div class="notif-fix" style="margin-bottom:16px;margin-top:0">
        âš  If hosted on Netlify, notifications will be blocked by their server headers. Use Local method for full functionality.
      </div>
      <div class="install-step">
        <div class="install-num">1</div>
        <div class="install-text">Open the app URL in <b>Chrome</b> or <b>Edge</b> on your computer.</div>
      </div>
      <div class="install-step">
        <div class="install-num">2</div>
        <div class="install-text">Look for the <b>âŠ•</b> icon in the address bar (far right). Click it.
          <small>If you don't see it, go to Chrome menu â‹® â†’ "Save and Share" â†’ "Install Vault Dexâ€¦"</small>
        </div>
      </div>
      <div class="install-step">
        <div class="install-num">3</div>
        <div class="install-text">Click <b>"Install"</b> in the popup. The app opens in its own window and gets added to your taskbar / Start Menu.</div>
      </div>
      <div class="install-step">
        <div class="install-num">4</div>
        <div class="install-text">To enable notifications: click the <b>ðŸ”’ lock icon</b> in the address bar â†’ <b>Notifications â†’ Allow</b>. Then reload.</div>
      </div>
    </div>

    <!-- ANDROID -->
    <div class="platform-steps" id="steps-android">
      <div class="install-step">
        <div class="install-num">1</div>
        <div class="install-text">Open the app in <b>Chrome for Android</b>.</div>
      </div>
      <div class="install-step">
        <div class="install-num">2</div>
        <div class="install-text">Tap Chrome's <b>â‹® menu</b> â†’ <b>"Add to Home Screen"</b> â†’ <b>"Add"</b>.
          <small>The â° icon appears on your home screen and opens in full-screen standalone mode.</small>
        </div>
      </div>
      <div class="install-step">
        <div class="install-num">3</div>
        <div class="install-text">Allow notifications when prompted. If blocked: <b>Settings â†’ Apps â†’ Chrome â†’ Notifications â†’ Allow</b>.</div>
      </div>
      <div class="install-step">
        <div class="install-num">4</div>
        <div class="install-text"><b>Allow background alarms (important!)</b><br>
          Go to <b>Settings â†’ Apps â†’ Chrome â†’ Battery â†’ Unrestricted</b>.
          <small>Without this, Android kills Chrome in the background and your alarms won't fire when the screen is off.</small>
          <div style="background:rgba(255,170,0,.08);border:1px solid rgba(255,170,0,.25);border-radius:8px;padding:10px 12px;margin-top:8px;font-size:11px;font-family:var(--font-mono);color:var(--warn);line-height:1.6">
            âš  "Optimized" (Android default) = alarms may be delayed or skipped<br>
            âœ“ "Unrestricted" = alarms fire reliably even with screen off
          </div>
        </div>
      </div>
      <div class="install-step">
        <div class="install-num">5</div>
        <div class="install-text"><b>Note:</b> Android Chrome supports File System Access API â€” vault folder and file writing works fully.
          <small>Tap "Reconnect" once each time you open the app to re-grant write access.</small>
        </div>
      </div>
    </div>

    <!-- iOS -->
    <div class="platform-steps" id="steps-ios">
      <div class="notif-fix" style="margin-bottom:16px;margin-top:0">
        âš  iOS Safari does <b>not</b> support the File System Access API. The vault folder cannot be read or written on iPhone/iPad. Habits will save to browser storage only.
      </div>
      <div class="install-step">
        <div class="install-num">1</div>
        <div class="install-text">Open the app in <b>Safari</b> on iPhone or iPad.</div>
      </div>
      <div class="install-step">
        <div class="install-num">2</div>
        <div class="install-text">Tap the <b>Share button</b> (box with arrow) at the bottom of Safari.</div>
      </div>
      <div class="install-step">
        <div class="install-num">3</div>
        <div class="install-text">Scroll down and tap <b>"Add to Home Screen"</b> â†’ <b>"Add"</b>.
          <small>The â° icon appears on your home screen.</small>
        </div>
      </div>
      <div class="install-step">
        <div class="install-num">4</div>
        <div class="install-text">Push notifications are <b>supported on iOS 16.4+</b> when installed as a PWA. When the app opens, tap <b>Allow</b> when prompted for notifications.</div>
      </div>
    </div>

    <button class="btn btn-ghost" style="width:100%;margin-top:20px" id="ig-close">Close</button>
  </div>`;
  document.body.appendChild(ov);
  ov.addEventListener('click', e=>{ if(e.target===ov) document.body.removeChild(ov); });
  ov.querySelector('#ig-close').addEventListener('click', ()=>document.body.removeChild(ov));
  // Platform tab switching
  ov.querySelectorAll('.ptab').forEach(tab=>{
    tab.addEventListener('click', ()=>{
      ov.querySelectorAll('.ptab').forEach(t=>t.classList.remove('active'));
      ov.querySelectorAll('.platform-steps').forEach(s=>s.classList.remove('active'));
      tab.classList.add('active');
      ov.querySelector('#steps-'+tab.dataset.p).classList.add('active');
    });
  });
}

function showToast(msg) {
  document.querySelector('.toast')?.remove();
  const t=document.createElement('div'); t.className='toast'; t.textContent=msg;
  document.body.appendChild(t); setTimeout(()=>t.remove(),2500);
}

// â”€â”€ FIRST-RUN SETUP SCREEN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showFirstRunSetup() {
  document.getElementById('setup-screen')?.remove();
  const sc=document.createElement('div'); sc.className='setup-screen'; sc.id='setup-screen';
  sc.innerHTML=`<div class="setup-inner">
    <div class="setup-icon">ðŸ“‡</div>
    <div class="setup-title">Vault Dex</div>
    <div class="setup-desc">Select your Obsidian vault folder. The app finds your .md config there, then reads and writes your daily habit data directly to it.</div>
    <button class="btn btn-green" id="fs-pick" style="width:100%;font-size:16px;padding:16px 22px">ðŸ“ Choose Vault Folder</button>
    <div class="setup-note">
      <b>One-time setup.</b> The folder is remembered. On each app launch you'll see a small "Reconnect" button â€” one tap re-grants write access (browser security requirement).<br><br>
      <b>Folder structure expected:</b><br>
      ðŸ“ YourVault/<br>
      &nbsp;&nbsp;ðŸ“„ your-config.md<br>
      &nbsp;&nbsp;ðŸ“ data/ â† daily files written here<br><br>
      To install as a standalone app, tap <b>âš™ Settings â†’ Install Guide</b> after setup.
    </div>
  </div>`;
  document.body.appendChild(sc);
  sc.querySelector('#fs-pick').addEventListener('click', async()=>{
    const ok = await pickVaultFolder();
    if (ok) {
      sc.remove();
      await loadFromVault();
      renderAll();
      showToast('âœ“ Vault connected');
    }
  });
}

// â”€â”€ ALARM STATUS BANNER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Shows a persistent in-app strip under the header indicating whether
// background alarms are armed. Also controls the OS tray status notification.

// â”€â”€ RECONNECT BANNER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showReconnectBanner() {
  const area = document.getElementById('reconnect-area');
  const name = LS.get('vaultFolderName') || 'vault';
  area.innerHTML = `<div class="reconnect-banner">
    <div class="rb-text">ðŸ“ ${name} needs access<div class="rb-sub">Tap once to reconnect â€” won't ask again this session</div></div>
    <button class="reconnect-btn" id="rb-btn">Reconnect</button>
  </div>`;
  area.querySelector('#rb-btn').addEventListener('click', async () => {
    const ok = await reconnectVault();
    if (ok) {
      await loadFromVault();
      area.innerHTML = ''; // clear reconnect banner so alarm banner can appear
      renderAll();
      showToast('âœ“ Vault reconnected');
    } else {
      showToast('Could not reconnect â€” try Settings â†’ Change Vault');
    }
  });
}

// â”€â”€ BATTERY OPTIMIZATION BANNER (Android only) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showBatteryBanner() {
  if (!isAndroid()) return;
  if (S.notifPermission !== 'granted') return;
  if (LS.get('batteryTipDismissed')) return;
  const area = document.getElementById('reconnect-area');
  // Don't replace reconnect banner if it's already showing
  if (area.querySelector('.reconnect-banner')) return;

  const existing = area.querySelector('.battery-banner');
  if (existing) return; // already shown

  const banner = document.createElement('div');
  banner.className = 'battery-banner';
  banner.style.cssText = 'margin:12px 20px 0;background:rgba(255,170,0,.07);border:1px solid rgba(255,170,0,.2);border-radius:12px;padding:12px 16px;display:flex;align-items:center;gap:12px;animation:fadeUp .3s ease';
  banner.innerHTML = `
    <div style="flex:1;font-size:12px;color:var(--warn);font-family:var(--font-mono);line-height:1.5">
      ðŸ”‹ <b>Enable background alarms</b>
      <div style="font-size:11px;color:var(--muted);margin-top:2px">Settings â†’ Apps â†’ Chrome â†’ Battery â†’ <b>Unrestricted</b></div>
    </div>
    <button id="bb-settings" style="padding:7px 12px;background:var(--warn);color:#000;border:none;border-radius:8px;font-size:12px;font-weight:700;cursor:pointer;flex-shrink:0;font-family:var(--font-display)">Fix it</button>
    <button id="bb-dismiss" style="padding:7px 10px;background:transparent;border:1px solid rgba(255,170,0,.3);border-radius:8px;font-size:12px;color:var(--muted);cursor:pointer;flex-shrink:0;font-family:var(--font-mono)">âœ•</button>`;
  area.appendChild(banner);

  banner.querySelector('#bb-settings').addEventListener('click', () => {
    showSettings();
  });
  banner.querySelector('#bb-dismiss').addEventListener('click', () => {
    LS.set('batteryTipDismissed', true);
    banner.remove();
  });
}

// â”€â”€ TODAY SCHEDULE POPUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showTodaySchedulePopup() {
  const existing = document.getElementById('today-sched-ov');
  if (existing) { existing.remove(); return; }

  const todayISO = new Date().toISOString().slice(0,10);
  const now = new Date();
  const allSc = S.config?.schedule || [];

  // â”€â”€ Gather today's items using the central getTodaySchedule() â”€â”€
  // This is the single source of truth â€” all repeat/date logic lives there.
  const todayAll = getTodaySchedule();

  // Split into display categories
  const routineItems  = todayAll.filter(item => item.blockType === 'routine' || (!item.blockType && (item.repeat||'daily')==='daily'));
  const scheduledItems = todayAll.filter(item => item.blockType === 'scheduled' || (item.blockType !== 'routine' && item.blockType !== 'open' && (item.repeat||'daily')!=='daily'));
  const focusedItems  = todayAll.filter(item => item.blockType === 'open');

  // â”€â”€ Merge routine + scheduled â†’ sort by time ascending â”€â”€
  const timelineItems = [...routineItems, ...scheduledItems];
  timelineItems.sort((a, b) => {
    try {
      const ta = schedDate(a.time), tb = schedDate(b.time);
      return ta - tb;
    } catch { return 0; }
  });

  // â”€â”€ Build popup â”€â”€
  const ov = document.createElement('div');
  ov.className = 'today-sched-ov';
  ov.id = 'today-sched-ov';

  const sheet = document.createElement('div');
  sheet.className = 'today-sched-sheet';
  ov.appendChild(sheet);

  // Handle bar
  const handle = document.createElement('div');
  handle.className = 'modal-handle';
  sheet.appendChild(handle);

  // Header
  const hdr = document.createElement('div');
  hdr.className = 'today-sched-hdr';
  hdr.innerHTML = `
    <div>
      <div class="today-sched-title">â° Today's Schedule</div>
    </div>`;
  const closeBtn = document.createElement('button');
  closeBtn.className = 'today-sched-close';
  closeBtn.innerHTML = 'âœ•';
  closeBtn.addEventListener('click', () => ov.remove());
  hdr.appendChild(closeBtn);
  sheet.appendChild(hdr);

  // Body
  const body = document.createElement('div');
  body.className = 'today-sched-body';
  sheet.appendChild(body);

  // â”€â”€ Render timeline â”€â”€
  function renderItem(item, idx, isFocused) {
    const row = document.createElement('div');
    const start  = item.time ? schedDate(item.time) : null;
    const taskEnd = start ? new Date(start.getTime() + (item.duration || 30) * 60000) : null;
    const isCur  = !isFocused && start && now >= start && taskEnd && now < taskEnd;
    const isPast = !isFocused && taskEnd && now >= taskEnd;
    row.className = `tsched-item${isCur ? ' now' : ''}${isPast ? ' past' : ''}`;

    const timeSpan = document.createElement('span');
    timeSpan.className = 'tsched-time';
    if (isFocused) {
      timeSpan.textContent = `~${item.duration || 30}m`;
      timeSpan.style.color = 'var(--muted)';
    } else {
      timeSpan.textContent = item.time || 'â€”';
    }

    const actSpan = document.createElement('span');
    actSpan.className = 'tsched-act';
    actSpan.textContent = item.activity;

    row.appendChild(timeSpan);
    row.appendChild(actSpan);

    if (isCur) {
      const nowPill = document.createElement('span');
      nowPill.className = 'tsched-now-pill';
      nowPill.textContent = 'NOW';
      row.appendChild(nowPill);
    }

    // Tap to log habit â€” only for daily routine items
    const isRoutineItem = item.blockType === 'routine' || (!item.blockType && (item.repeat||'daily') === 'daily');
    row.addEventListener('click', () => {
      if (!isRoutineItem) return;
      const hi = detectHabit(item.activity);
      if (hi) { showManualModal(hi.key); ov.remove(); }
    });
    if (isRoutineItem && detectHabit(item.activity)) {
      row.style.cursor = 'pointer';
    } else {
      row.style.cursor = 'default';
    }

    return row;
  }

  if (!timelineItems.length) {
    body.innerHTML = `<div style="text-align:center;padding:40px 16px;color:var(--muted);font-size:13px;font-family:var(--font-mono);line-height:1.8;opacity:.7">No activities scheduled today.<br>Add items in your vault folder.</div>`;
  } else {
    // Timeline section
    if (timelineItems.length) {
      timelineItems.forEach((item, i) => body.appendChild(renderItem(item, i, false)));
    }
  }

  // Scroll to current item
  document.body.appendChild(ov);
  ov.addEventListener('click', e => { if (e.target === ov) ov.remove(); });

  // Auto-scroll to NOW item after mount
  requestAnimationFrame(() => {
    const nowEl = body.querySelector('.tsched-item.now');
    if (nowEl) nowEl.scrollIntoView({ block: 'center', behavior: 'smooth' });
  });
}

function buildSkeleton() {
  document.getElementById('main-content').innerHTML=`
    <div class="card" id="card-countdown" style="animation-delay:0s">
      <div class="card-header" style="display:flex;align-items:center;justify-content:space-between">
        <span class="card-label">Now</span>
        <div style="display:flex;align-items:center;gap:8px">
          <button id="btn-today-sched" title="Today's Schedule" style="width:34px;height:34px;border-radius:10px;border:1px solid var(--border);background:var(--bg3);color:var(--text);font-size:17px;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all .15s">â°</button>
        </div>
      </div>
      <div class="card-body" style="padding:0">
        <div id="countdown-left" style="padding:14px 16px 16px"></div>
      </div>
    </div>
    <div class="card" id="card-log" style="animation-delay:.05s">
      <div class="card-header"><span class="card-label">Log</span></div>
      <div class="card-body">
        <div style="display:flex;gap:10px">
          <button id="log-text-btn" style="flex:1;min-width:0;padding:14px 10px;border-radius:12px;border:1px solid var(--border);background:var(--bg3);color:var(--text);cursor:pointer;display:flex;align-items:center;justify-content:center;gap:8px;transition:all .15s;font-size:13px;font-family:var(--font-display);font-weight:700" title="Text Log">
            <span style="font-size:22px;line-height:1;flex-shrink:0">ðŸ“</span><span>Log</span>
          </button>
          <button id="log-audio-btn" style="flex:1;min-width:0;padding:14px 10px;border-radius:12px;border:1px solid var(--border);background:var(--bg3);color:var(--text);cursor:pointer;display:flex;align-items:center;justify-content:center;gap:8px;transition:all .15s;font-size:13px;font-family:var(--font-display);font-weight:700" title="Audio Log">
            <span style="font-size:22px;line-height:1;flex-shrink:0">ðŸ“‹</span><span>Archive</span>
          </button>
        </div>
      </div>
    </div>
    <div class="card" id="card-habits" style="animation-delay:.08s">
      <div class="card-header" id="habits-card-header">
        <span class="card-label">Habits</span>
        <div style="display:flex;align-items:center;gap:10px">
          <span id="habit-edit-btn" style="font-size:12px;color:var(--muted);cursor:pointer;font-family:var(--font-mono)">âœŽ edit</span>
        </div>
      </div>
      <div class="card-body"></div>
      <div id="habit-done-ledge" style="display:none;border-top:1px solid var(--border)">
        <button class="habit-done-pill" id="habit-done-pill" style="display:flex;width:100%;border-radius:0 0 var(--radius) var(--radius);padding:10px 16px;justify-content:center;font-size:12px">âœ“ Done Editing</button>
      </div>
    </div>`;

  // â”€â”€ Log text button â”€â”€
  document.getElementById('log-text-btn')?.addEventListener('click', () => showLogTextPopup());
  document.getElementById('log-audio-btn')?.addEventListener('click', () => showLogsPopup());
  document.getElementById('habit-edit-btn')?.addEventListener('click', ()=>{
    S._habitEditMode = !S._habitEditMode;
    renderHabitBars();
  });
  document.getElementById('habit-done-pill')?.addEventListener('click', ()=>{
    S._habitEditMode = false;
    renderHabitBars();
  });

  // No-op stubs (kept so any remaining callers don't throw)
  function commitEdits() {}
  function enterEditMode() {}
  function exitEditMode() {}
  function switchTab() {}
  S._enterSchedEdit = enterEditMode;
  S._switchTab = switchTab;
  S._getEditMode = () => false;
  S._getActiveTab = () => 0;
}

function renderAll() {
  renderCountdown();
  renderHabitBars();
  // Keep SW alarm store in sync
  syncAlarmsToSW();
}

function startTimers() {
  if (S.countdownInterval) clearInterval(S.countdownInterval);
  if (S.checkInterval) clearInterval(S.checkInterval);
  S.countdownInterval=setInterval(()=>{
    tickCountdown();
    if (new Date().getSeconds()===0) {
      renderCountdown();
    }
  }, 1000);
  S.checkInterval=setInterval(checkAlarms, 2000);
}

async function fetchNepaliDate() {
  // Pure JS Nepali date conversion (BS) â€” works fully offline
  // Uses the Bikram Sambat calendar algorithm
  try {
    const now = new Date();
    const yy = now.getFullYear(), mm = now.getMonth() + 1, dd = now.getDate();

    // BS year data: [days in each month] for BS years 2000-2089
    // Each entry: total days in that BS year's months
    const bsData = {
      2082: [31,32,31,32,31,30,30,30,29,29,30,31],
      2083: [31,31,32,31,31,30,30,30,29,30,30,30],
      2084: [31,31,32,31,31,30,30,30,29,30,30,30],
      2085: [31,32,31,32,30,31,30,29,30,29,30,30],
    };
    const bsMonths = ['Baishakh','Jestha','Ashadh','Shrawan','Bhadra','Ashwin','Kartik','Mangsir','Poush','Magh','Falgun','Chaitra'];

    // Known anchor: 2082 Baishakh 1 = 2025 April 14
    const anchor = new Date(2025, 3, 14); // April 14, 2025 = 2082/01/01
    const diffDays = Math.floor((now - anchor) / 86400000);

    let bsYear = 2082, bsMonth = 1, bsDay = 1;
    let remaining = diffDays;

    outer:
    for (let y = 2082; y <= 2090; y++) {
      const months = bsData[y] || [31,31,32,31,31,31,30,30,29,29,30,30];
      for (let m = 0; m < 12; m++) {
        const daysInMonth = months[m];
        if (remaining < daysInMonth) {
          bsYear = y; bsMonth = m + 1; bsDay = 1 + remaining;
          break outer;
        }
        remaining -= daysInMonth;
      }
    }

    return `${bsMonths[bsMonth - 1]} ${bsDay}, ${bsYear}`;
  } catch { return null; }
}

function updateHeaderDate() {
  const el=document.getElementById('header-date');
  if (!el) return;
  const engDate = new Date().toLocaleDateString('en-US',{weekday:'long',month:'short',day:'numeric'}).toUpperCase();
  el.textContent = engDate;
  // Fetch Nepali date asynchronously
  fetchNepaliDate().then(nepDate => {
    if (nepDate && el) el.textContent = engDate + ' / ' + nepDate.toUpperCase();
  });
}

// â”€â”€ BOOT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function boot() {
  // Apply saved theme immediately
  applyTheme(LS.get('theme') || 'auto');

  // Handle habit action from notification click when app was closed
  const urlParams = new URLSearchParams(location.search);
  const pendingHabit = urlParams.get('ha');
  if (pendingHabit) {
    try {
      const { habitKey, habitVal } = JSON.parse(decodeURIComponent(pendingHabit));
      if (habitKey && habitVal !== undefined) {
        setTimeout(() => { updateHabit(habitKey, habitVal); showToast(`âœ“ ${habitKey} logged`); }, 1500);
      }
    } catch {}
    // Clean URL
    history.replaceState({}, '', location.pathname);
  }

  updateHeaderDate();
  setInterval(updateHeaderDate, 60000);

  // Midnight reload of habit data
  const msUntilMidnight=()=>{ const n=new Date(),m=new Date(n); m.setHours(24,0,0,0); return m-n; };
  setTimeout(()=>{ loadFromVault().then(renderHabitBars); setInterval(()=>loadFromVault().then(renderHabitBars), 86400000); }, msUntilMidnight());

  if ('serviceWorker' in navigator) {
    const swReg = await navigator.serviceWorker.register('./sw.js', { scope: './' }).catch(console.error);

    // Request Periodic Background Sync (Chrome Android installed PWA).
    // When granted, the browser wakes the SW ~every minute even when fully closed.
    async function requestPeriodicSync(reg) {
      try {
        if (!reg || !reg.periodicSync) return;
        const status = await navigator.permissions.query({ name: 'periodic-background-sync' });
        if (status.state === 'granted') {
          await reg.periodicSync.register('check-alarms', { minInterval: 60 * 1000 });
        }
      } catch {}
    }
    if (swReg) requestPeriodicSync(swReg);

    // Once controller is available, kick keep-alive and sync alarms
    const kickSW = () => {
      if (navigator.serviceWorker.controller) {
        navigator.serviceWorker.controller.postMessage({ type: 'START_KEEPALIVE' });
        syncAlarmsToSW();
      }
    };
    if (navigator.serviceWorker.controller) {
      kickSW();
    } else {
      navigator.serviceWorker.addEventListener('controllerchange', kickSW, { once: true });
    }

    // Re-sync whenever user returns to the app so SW always has fresh alarm times
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible' && navigator.serviceWorker.controller) {
        syncAlarmsToSW();
      }
    });

    // Listen for messages from SW (notification action clicks)
    navigator.serviceWorker.addEventListener('message', e => {
      if (!e.data) return;
      if (e.data.type === 'HABIT_ACTION') {
        const {habitKey, habitVal} = e.data;
        if (habitKey !== undefined && habitVal !== undefined) {
          updateHabit(habitKey, habitVal);
          showToast(`âœ“ ${habitKey} logged from notification`);
        }
      } else if (e.data.type === 'SNOOZED') {
        const tag = e.data.tag || '';
        const idxMatch = tag.match(/alarm-(\d+)/);
        const mins = e.data.mins || 5;
        if (idxMatch) {
          const schedIdx = parseInt(idxMatch[1]);
          const until = Date.now() + mins * 60000;
          S.snooze[schedIdx] = until;
          renderCountdown();
          showToast(`Snoozed ${mins}m`);
          if (S.notifPermission === 'granted' && navigator.serviceWorker.controller && S.config?.schedule[schedIdx]) {
            const item = S.config.schedule[schedIdx];
            const hi = detectHabit(item.activity);
            const snOpts = S.config.habitTracker?.snoozeOptions || [5, 10];
            const actions = [];
            if (hi) {
              const {key, config: cfg} = hi;
              if (cfg.type === 'incremental') actions.push({ action: `habit:${key}:${cfg.increment}`, title: `âœ“ Done (+${cfg.increment})` });
              else cfg.choices.slice(0, 2).forEach(c => actions.push({ action: `habit:${key}:${c.value}`, title: c.label }));
            }
            actions.push({ action: 'dismiss', title: 'Dismiss' });
            snOpts.slice(0, 1).forEach(m => actions.push({ action: `snooze:${schedIdx}:${m}`, title: `â° +${m}m` }));
            navigator.serviceWorker.controller.postMessage({
              type: 'SCHEDULE_ALARM',
              title: `â° ${item.time} â€” ${item.activity}`,
              body: hi ? `Snooze ended Â· Log ${hi.key}` : 'Snooze ended',
              tag: `alarm-${schedIdx}`,
              delay: mins * 60000,
              actions
            });
          }
        }
      } else if (e.data.type === 'NOTIFICATION_CLICK') {
        // focus app, handled by SW openWindow already
      }
    });

  }

  document.getElementById('btn-reload').addEventListener('click', async()=>{
    if (S.vaultDirHandle) {
      await loadFromVault(); renderAll(); showToast('Reloaded');
    } else {
      const ok = await reconnectVault();
      if (ok) { await loadFromVault(); renderAll(); showToast('âœ“ Vault reconnected'); }
      else { showToast('No vault connected â€” tap âš™ Settings to connect'); }
    }
  });
  document.getElementById('btn-settings').addEventListener('click', showSettings);

  // Load cached config + today's habits for instant render
  // Cache-bust: drop stale cache saved by old parser (items with blockType:scheduled
  // but no createdOn mean they were parsed incorrectly before per-date-time support).
  let cached=LS.get('lastConfig');
  if (cached?.schedule) {
    const hasOldFormat = cached.schedule.some(
      it => it.blockType === 'scheduled' && !it.createdOn && !it.customDates
    );
    if (hasOldFormat) { LS.del('lastConfig'); cached = null; }
  }
  if (cached?.schedule) S.config=cached;
  S.habitData = LS.get('habitData_' + todayStr()) || {};

  buildSkeleton();
  // btn-today-sched is created inside buildSkeleton, so wire it after
  document.getElementById('btn-today-sched').addEventListener('click', showTodaySchedulePopup);
  startTimers();
  renderAll();

  // Attempt to restore vault handle from IndexedDB (optional â€” habit tracker folder)
  const state = await restoreVaultHandle();
  if (state === 'granted') {
    await deriveSubHandles();
    await loadFromVault();
    renderAll();
  } else if (state === 'needs-grant') {
    showReconnectBanner();
  }
  // No vault = fine, app works from localStorage. User connects via Settings.

  // Restore log template + output folder (saved to IDB, auto-reconnect if permission still held)
  await restoreLogTemplateHandle();
  await restoreLogOutputHandle();
  await restoreEventsHandle();

  if (Notification.permission==='default')
    setTimeout(()=>Notification.requestPermission().then(p=>{
      S.notifPermission=p;
      showBatteryBanner();
    }), 2000);
  else {
    setTimeout(showBatteryBanner, 1000);
  }
}

// â”€â”€ OFFLINE / ONLINE BANNER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(function initOfflineBanner() {
  let _offlineBannerDismissed = false;

  function showOfflineBanner() {
    if (document.getElementById('offline-banner')) return;
    _offlineBannerDismissed = false;
    const el = document.createElement('div');
    el.id = 'offline-banner';
    el.innerHTML = `
      <span class="ob-icon">ðŸ“¡</span>
      <div class="ob-text">
        <b>You're offline</b>
        <span>App works locally â€” vault sync paused</span>
      </div>
      <button class="ob-close" title="Dismiss">âœ•</button>`;
    document.body.appendChild(el);
    el.querySelector('.ob-close').addEventListener('click', () => {
      _offlineBannerDismissed = true;
      removeOfflineBanner(true);
    });
  }

  function removeOfflineBanner(animated) {
    const el = document.getElementById('offline-banner');
    if (!el) return;
    if (animated) {
      el.classList.add('dismissing');
      setTimeout(() => el.remove(), 300);
    } else {
      el.remove();
    }
  }

  function showBackOnlineBanner() {
    removeOfflineBanner();
    const t = document.createElement('div');
    t.className = 'toast';
    t.style.cssText += ';border-color:rgba(0,255,136,.4);color:var(--accent)';
    t.textContent = 'âœ“ Back online';
    document.body.appendChild(t);
    setTimeout(() => t.remove(), 2500);
  }

  window.addEventListener('offline', () => showOfflineBanner());

  window.addEventListener('online', () => {
    if (!_offlineBannerDismissed) showBackOnlineBanner();
    else removeOfflineBanner();
  });

  // Show immediately if already offline on load
  if (!navigator.onLine) setTimeout(showOfflineBanner, 800);
})();

boot();

// Prevent pull-to-refresh (overscroll-behavior covers Chrome; this covers iOS Safari)
document.addEventListener('touchmove', e => {
  let el = e.target;
  while (el && el !== document.body) {
    const s = getComputedStyle(el);
    if ((s.overflowY === 'auto' || s.overflowY === 'scroll') && el.scrollHeight > el.clientHeight) return;
    el = el.parentElement;
  }
  if (document.scrollingElement && document.scrollingElement.scrollTop === 0) e.preventDefault();
}, { passive: false });
</script>
</body>
</html>
